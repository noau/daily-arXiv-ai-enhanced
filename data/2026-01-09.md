<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 4]
- [cs.PL](#cs.PL) [Total: 3]
- [cs.GT](#cs.GT) [Total: 1]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [In-SRAM Radiant Foam Rendering on a Graph Processor](https://arxiv.org/abs/2601.04382)
*Zulkhuu Tuya,Ignacio Alzugaray,Nicholas Fry,Andrew J. Davison*

Main category: cs.GR

TL;DR: 论文提出了一种在Graphcore Mk2 IPU上实现的完全在SRAM中的分布式体积渲染系统，利用层次化路由覆盖高效处理光线追踪，保持数据和计算的本地化，实现了接近GPU的性能。


<details>
  <summary>Details</summary>
Motivation: 新兴多核加速器的设计打破了传统体积渲染技术依赖统一大内存的假设，因此需要在分布式内存架构上开发高效的渲染方法。

Method: 研究采用了Radiant Foam Voronoi-cell体积表示法，并在Graphcore Mk2 IPU上实现了一个完全在SRAM中的分布式渲染系统，利用层次化路由覆盖管理和调度光线追踪。

Result: 系统在Mip-NeRF~360场景上实现了接近交互式的渲染速率（约1帧/秒，640x480分辨率），图像和深度质量接近GPU实现，同时将所有场景数据和光线状态保留在SRAM中。

Conclusion: 论文不仅证明了在分布式内存加速器上实现高效体积渲染的可行性，还分析了路由、内存和调度的瓶颈，为未来支持不规则、数据密集型渲染任务的硬件设计提供了参考。

Abstract: Many emerging many-core accelerators replace a single large device memory with hundreds to thousands of lightweight cores, each owning only a small local SRAM and exchanging data via explicit on-chip communication. This organization offers high aggregate bandwidth, but it breaks a key assumption behind many volumetric rendering techniques: that rays can randomly access a large, unified scene representation. Rendering efficiently on such hardware therefore requires distributing both data and computation, keeping ray traversal mostly local, and structuring communication into predictable routes.
  We present a fully in-SRAM, distributed renderer for the \emph{Radiant Foam} Voronoi-cell volumetric representation on the Graphcore Mk2 IPU, a many-core accelerator with tile-local SRAM and explicit inter-tile communication. Our system shards the scene across tiles and forwards rays between shards through a hierarchical routing overlay, enabling ray marching entirely from on-chip SRAM with predictable communication. On Mip-NeRF~360 scenes, the system attains near-interactive throughput (\(\approx\)1\,fps at \mbox{$640\times480$}) with image and depth quality close to the original GPU-based Radiant Foam implementation, while keeping all scene data and ray state in on-chip SRAM. Beyond demonstrating feasibility, we analyze routing, memory, and scheduling bottlenecks that inform how future distributed-memory accelerators can better support irregular, data-movement-heavy rendering workloads.

</details>


### [2] [Differential Locally Injective Grid Deformation and Optimization](https://arxiv.org/abs/2601.04494)
*Julian Knodt,Seung-Hwan Baek*

Main category: cs.GR

TL;DR: 本文提出了一种无反转的网格变形方法，通过优化差分权重自适应压缩空间，是首个利用顶点着色将密集线性系统分解为多个独立顶点集以并行优化的方法。


<details>
  <summary>Details</summary>
Motivation: 传统网格在空间上是均匀的，无法动态调整分辨率以适应细节变化区域。现有的间接网格自适应方法（如四面体网格或局部细分网格）难以实现无反转变形。

Method: 通过顶点着色将密集输入线性系统分解为多个独立顶点集，优化差分权重以实现自适应空间压缩，并扩展到优化具有凸边界的UV网格。

Result: 差分表示法比更新顶点外坐标具有更平滑的优化流形，且通过独立优化顶点集，局部单射性检查更简单，可使用Adam等优化器。

Conclusion: 该方法在等值面提取、图像压缩和网格参数化中展示了其通用性和有效性。

Abstract: Grids are a general representation for capturing regularly-spaced information, but since they are uniform in space, they cannot dynamically allocate resolution to regions with varying levels of detail. There has been some exploration of indirect grid adaptivity by replacing uniform grids with tetrahedral meshes or locally subdivided grids, as inversion-free deformation of grids is difficult. This work develops an inversion-free grid deformation method that optimizes differential weight to adaptively compress space. The method is the first to optimize grid vertices as differential elements using vertex-colorings, decomposing a dense input linear system into many independent sets of vertices which can be optimized concurrently. This method is then also extended to optimize UV meshes with convex boundaries. Experimentally, this differential representation leads to a smoother optimization manifold than updating extrinsic vertex coordinates. By optimizing each sets of vertices in a coloring separately, local injectivity checks are straightforward since the valid region for each vertex is fixed. This enables the use of optimizers such as Adam, as each vertex can be optimized independently of other vertices. We demonstrate the generality and efficacy of this approach through applications in isosurface extraction for inverse rendering, image compaction, and mesh parameterization.

</details>


### [3] [LooseRoPE: Content-aware Attention Manipulation for Semantic Harmonization](https://arxiv.org/abs/2601.05127)
*Etai Sella,Yoav Baron,Hadar Averbuch-Elor,Daniel Cohen-Or,Or Patashnik*

Main category: cs.GR

TL;DR: LooseRoPE 是一种基于扩散模型的新方法，通过松解位置编码的约束，实现了无需文本提示的精确图像编辑，平衡了对输入图像的忠实保留与新插入对象的上下文化。


<details>
  <summary>Details</summary>
Motivation: 现有的基于扩散的图像编辑方法通常依赖于文本或高级指令，提供了直观但粗糙的控制。本文旨在实现无需提示的精确编辑，使用户能够直接通过裁剪和粘贴操作指定修改，同时解决保留粘贴对象身份与上下文协调的挑战。

Method: 通过观察扩散模型中注意力图的作用，提出 LooseRoPE 方法，通过松解旋转位置编码（RoPE）的约束来控制注意力视野，从而平衡输入图像的保留与新对象的上下文化。

Result: LooseRoPE 能够灵活地在保留输入图像和插入对象的上下文化之间平滑调节，实现了无缝的合成效果，无需文本描述或复杂的用户输入。

Conclusion: LooseRoPE 为图像编辑提供了一个直观且灵活的框架，通过调控注意力视野，实现了身份保留和上下文协调的平衡，适用于复杂的图像合成任务。

Abstract: Recent diffusion-based image editing methods commonly rely on text or high-level instructions to guide the generation process, offering intuitive but coarse control. In contrast, we focus on explicit, prompt-free editing, where the user directly specifies the modification by cropping and pasting an object or sub-object into a chosen location within an image. This operation affords precise spatial and visual control, yet it introduces a fundamental challenge: preserving the identity of the pasted object while harmonizing it with its new context. We observe that attention maps in diffusion-based editing models inherently govern whether image regions are preserved or adapted for coherence. Building on this insight, we introduce LooseRoPE, a saliency-guided modulation of rotational positional encoding (RoPE) that loosens the positional constraints to continuously control the attention field of view. By relaxing RoPE in this manner, our method smoothly steers the model's focus between faithful preservation of the input image and coherent harmonization of the inserted object, enabling a balanced trade-off between identity retention and contextual blending. Our approach provides a flexible and intuitive framework for image editing, achieving seamless compositional results without textual descriptions or complex user input.

</details>


### [4] [GenAI-DrawIO-Creator: A Framework for Automated Diagram Generation](https://arxiv.org/abs/2601.05162)
*Jinze Yu,Dayuan Jiang*

Main category: cs.GR

TL;DR: GenAI-DrawIO-Creator是一个利用大型语言模型（LLMs）自动生成和修改draw.io图的框架，显著减少了创建时间并提高了输出质量。


<details>
  <summary>Details</summary>
Motivation: 图在传递复杂信息方面至关重要，但手动创建和修改图仍然是一项劳动密集型任务。

Method: 该框架集成Claude 3.7，通过专门的提示工程和错误检查生成结构化的XML格式图，支持从自然语言或代码生成图，并能从图像复制图。

Result: 模拟评估显示，该方法显著减少了图的创建时间，并生成了具有高结构保真度的输出。

Conclusion: 研究展示了Claude 3.7在处理结构化视觉推理任务中的潜力，为未来AI辅助图应用的研究奠定了基础。

Abstract: Diagrams are crucial for communicating complex information, yet creating and modifying them remains a labor-intensive task. We present GenAI-DrawIO-Creator, a novel framework that leverages Large Language Models (LLMs) to automate diagram generation and manipulation in the structured XML format used by draw.io. Our system integrates Claude 3.7 to reason about structured visual data and produce valid diagram representations. Key contributions include a high-level system design enabling real-time diagram updates, specialized prompt engineering and error-checking to ensure well-formed XML outputs. We demonstrate a working prototype capable of generating accurate diagrams (such as network architectures and flowcharts) from natural language or code, and even replicating diagrams from images. Simulated evaluations show that our approach significantly reduces diagram creation time and produces outputs with high structural fidelity. Our results highlight the promise of Claude 3.7 in handling structured visual reasoning tasks and lay the groundwork for future research in AI-assisted diagramming applications.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [5] [Scalable Floating-Point Satisfiability via Staged Optimization](https://arxiv.org/abs/2601.04492)
*Yuanzhuo Zhang,Zhoulai Fu,Binoy Ravindran*

Main category: cs.PL

TL;DR: StageSAT是一种将SMT求解与数值优化相结合的新方法，通过分阶段优化解决浮点可满足性问题，提高了性能和正确性。


<details>
  <summary>Details</summary>
Motivation: 传统的浮点可满足性求解方法在复杂算术和搜索效率上存在局限，StageSAT旨在通过分阶段优化和投影辅助下降方法解决这些问题。

Method: StageSAT将浮点公式重构为三个精度递增的优化问题阶段：快速投影辅助下降、ULP²优化和n-ULP晶格细化，并引入正交投影防止搜索停滞。

Result: StageSAT在广泛基准测试中表现优于现有方法，解决了更多公式，99.4%的召回率和0%假SAT，速度提升了5-10倍。

Conclusion: 分阶段优化显著提升了浮点可满足性求解的性能和正确性，StageSAT为复杂算术问题提供了可靠且高效的解决方案。

Abstract: This work introduces StageSAT, a new approach to solving floating-point satisfiability that bridges SMT solving with numerical optimization. StageSAT reframes a floating-point formula as a series of optimization problems in three stages of increasing precision. It begins with a fast, projection-aided descent objective to guide the search toward a feasible region, proceeding to bit-level accuracy with ULP$^2$ optimization and a final $n$-ULP lattice refinement.
  By construction, the final stage uses a representing function that is zero if and only if a candidate satisfies all constraints. Thus, when optimization drives the objective to zero, the resulting assignment is a valid solution, providing a built-in guarantee of soundness.
  To improve search, StageSAT introduces a partial monotone descent property on linear constraints via orthogonal projection, preventing the optimizer from stalling on flat or misleading landscapes. Critically, this solver requires no heavy bit-level reasoning or specialized abstractions; it treats complex arithmetic as a black-box, using runtime evaluations to navigate the input space.
  We implement StageSAT and evaluate it on extensive benchmarks, including SMT-COMP'25 suites and difficult cases from prior work. StageSAT proved more scalable and accurate than state-of-the-art optimization-based alternatives. It solved strictly more formulas than any competing solver under the same time budget, finding most satisfiable instances without producing spurious models. This amounts to 99.4% recall on satisfiable cases with 0% false SAT, exceeding the reliability of prior optimization-based solvers. StageSAT also delivered significant speedups (often 5--10$\times$) over traditional bit-precise SMT and numeric solvers. These results demonstrate that staged optimization significantly improves performance and correctness of floating-point satisfiability solving.

</details>


### [6] [Lenses for Partially-Specified States (Extended Version)](https://arxiv.org/abs/2601.04573)
*Kazutaka Matsuda,Minh Nguyen,Meng Wang*

Main category: cs.PL

TL;DR: 提出了一种称为部分状态透镜的框架，用于处理多个视图共享同一源时的更新问题，通过部分指定状态来精确表达用户意图，并支持组合推理和更新保持。


<details>
  <summary>Details</summary>
Motivation: 当多个视图共享同一源数据时，一个视图的更新可能会影响其他视图，这使得在保持用户更新的同时维护一致性变得困难，尤其是在多个视图同时更新的情况下。

Method: 提出部分状态透镜框架，允许部分指定源和视图状态，以精确表达用户更新意图。这些意图被部分排序，为合并来自多个视图的更新意图提供了清晰的语义。

Result: 形式化了部分状态透镜，并提出了支持组合推理和确保更新保持的部分指定感知良好行为性。通过示例展示了该系统的实用性。

Conclusion: 部分状态透镜为解决多视图共享源数据的更新问题提供了一种有效的方法，支持组合推理和更新保持，并通过示例验证了其可行性。

Abstract: A bidirectional transformation is a pair of transformations satisfying certain well-behavedness properties: one maps source data into view data, and the other translates changes on the view back to the source. However, when multiple views share a source, an update on one view may affect the others, making it hard to maintain correspondence while preserving the user's update, especially when multiple views are changed at once. Ensuring these properties within a compositional framework is even more challenging. In this paper, we propose partial-state lenses, which allow source and view states to be partially specified to precisely represent the user's update intentions. These intentions are partially ordered, providing clear semantics for merging intentions of updates coming from multiple views and a refined notion of update preservation compatible with this merging. We formalize partial-state lenses, together with partial-specifiedness-aware well-behavedness that supports compositional reasoning and ensures update preservation. In addition, we demonstrate the utility of the proposed system through examples.

</details>


### [7] [The Squirrel Parser: A Linear-Time PEG Packrat Parser Capable of Left Recursion and Optimal Error Recovery](https://arxiv.org/abs/2601.05012)
*Luke A. D. Hutchison*

Main category: cs.PL

TL;DR: 本文介绍了松鼠解析器，一种PEG打包解析器，能够直接处理所有形式的左递归，并具有最佳的错误恢复能力，同时在线性时间复杂度内完成输入处理。


<details>
  <summary>Details</summary>
Motivation: 传统的递归下降解析器在处理左递归时需要重写语法或使用复杂的算法扩展，本文旨在提供一种更简洁高效的解决方案。

Method: 通过基于位置的状态跟踪和$O(1)$每LR周期的通信来检测循环，以及固定点搜索的迭代扩展，实现了最小化算法。此外，利用约束满足机制搜索最佳错误恢复策略。

Result: 本文提出的解析器在保持线性时间复杂度的同时，实现了最优的错误恢复，并通过一组公理和约束确保了设计的完整性、正确性和直观性。

Conclusion: 松鼠解析器为处理左递归和错误恢复提供了一种高效且理论上有保障的解决方案。

Abstract: We present the squirrel parser, a PEG packrat parser that directly handles all forms of left recursion with optimal error recovery, while maintaining linear time complexity in the length of the input even in the presence of an arbitrary number of errors. Traditional approaches to handling left recursion in a recursive descent parser require grammar rewriting or complex algorithmic extensions. We derive a minimal algorithm from first principles: cycle detection via per-position state tracking and $O(1)$-per-LR-cycle communication from descendant to ancestor recursion frames, and fixed-point search via iterative expansion. For error recovery, we derived a set of four axioms and twelve constraints that must be imposed upon an optimal error recovery design to ensure completeness, correctness, optimality of performance, and intuitiveness of behavior. We utilized a constraint satisfaction mechanism to search the space of all possibilities, arriving at a provably optimal and robust error recovery strategy that maintains perfect performance linearity.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [8] [Mechanism Design for Federated Learning with Non-Monotonic Network Effects](https://arxiv.org/abs/2601.04648)
*Xiang Li,Bing Luo,Jianwei Huang,Yuan Luo*

Main category: cs.GT

TL;DR: 本文提出了一种结合网络效应和应用特定需求的联邦学习激励机制设计SWAN，通过模型交易与共享框架MoTS优化社会福利和激励成本。


<details>
  <summary>Details</summary>
Motivation: 现有联邦学习激励机制忽视了网络效应和不同应用对模型性能的多样化需求，导致激励效果不佳和社会福利低下，甚至不适用于实际部署。

Method: 提出了模型交易与共享框架MoTS，并设计了SWAN机制，通过量化网络效应对异构客户参与的影响，并结合客户支付模式进行激励。

Result: 在硬件原型上的实验表明，SWAN机制显著优于现有机制，社会福利提升高达352.42%，额外激励成本降低93.07%。

Conclusion: SWAN机制有效解决了联邦学习中的网络效应和应用特定需求问题，为实际部署提供了高效的激励解决方案。

Abstract: Mechanism design is pivotal to federated learning (FL) for maximizing social welfare by coordinating self-interested clients. Existing mechanisms, however, often overlook the network effects of client participation and the diverse model performance requirements (i.e., generalization error) across applications, leading to suboptimal incentives and social welfare, or even inapplicability in real deployments. To address this gap, we explore incentive mechanism design for FL with network effects and application-specific requirements of model performance. We develop a theoretical model to quantify the impact of network effects on heterogeneous client participation, revealing the non-monotonic nature of such effects. Based on these insights, we propose a Model Trading and Sharing (MoTS) framework, which enables clients to obtain FL models through either participation or purchase. To further address clients' strategic behaviors, we design a Social Welfare maximization with Application-aware and Network effects (SWAN) mechanism, exploiting model customer payments for incentivization. Experimental results on a hardware prototype demonstrate that our SWAN mechanism outperforms existing FL mechanisms, improving social welfare by up to $352.42\%$ and reducing extra incentive costs by $93.07\%$.

</details>
