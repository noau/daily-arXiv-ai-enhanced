{"id": "2511.06674", "categories": ["cs.GR", "stat.ML"], "pdf": "https://arxiv.org/pdf/2511.06674", "abs": "https://arxiv.org/abs/2511.06674", "authors": ["Wenqi Cao", "Aming Li"], "title": "Modeling and Topology Estimation of Low Rank Dynamical Networks", "comment": null, "summary": "Conventional topology learning methods for dynamical networks become inapplicable to processes exhibiting low-rank characteristics. To address this, we propose the low rank dynamical network model which ensures identifiability. By employing causal Wiener filtering, we establish a necessary and sufficient condition that links the sparsity pattern of the filter to conditional Granger causality. Building on this theoretical result, we develop a consistent method for estimating all network edges. Simulation results demonstrate the parsimony of the proposed framework and consistency of the topology estimation approach."}
{"id": "2511.05700", "categories": ["cs.GT", "cs.CC", "math.CO", "math.OC"], "pdf": "https://arxiv.org/pdf/2511.05700", "abs": "https://arxiv.org/abs/2511.05700", "authors": ["Christoph Grüne", "Dorothee Henke", "Eva Rotenberg", "Lasse Wulf"], "title": "The Complexity of Stackelberg Pricing Games", "comment": null, "summary": "We consider Stackelberg pricing games, which are also known as bilevel pricing problems, or combinatorial price-setting problems. This family of problems consists of games between two players: the leader and the follower. There is a market that is partitioned into two parts: the part of the leader and the part of the leader's competitors. The leader controls one part of the market and can freely set the prices for products. By contrast, the prices of the competitors' products are fixed and known in advance. The follower, then, needs to solve a combinatorial optimization problem in order to satisfy their own demands, while comparing the leader's offers to the offers of the competitors. Therefore, the leader has to hit the intricate balance of making an attractive offer to the follower, while at the same time ensuring that their own profit is maximized.\n  Pferschy, Nicosia, Pacifici, and Schauer considered the Stackelberg pricing game where the follower solves a knapsack problem. They raised the question whether this problem is complete for the second level of the polynomial hierarchy, i.e., $Σ^p_2$-complete. The same conjecture was also made by Böhnlein, Schaudt, and Schauer. In this paper, we positively settle this conjecture. Moreover, we show that this result holds actually in a much broader context: The Stackelberg pricing game is $Σ^p_2$-complete for over 50 NP-complete problems, including most classics such as TSP, vertex cover, clique, subset sum, etc. This result falls in line of recent meta-theorems about higher complexity in the polynomial hierarchy by Grüne and Wulf."}
{"id": "2511.06117", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2511.06117", "abs": "https://arxiv.org/abs/2511.06117", "authors": ["Yacine Hakimi", "Riyadh Baghdadi"], "title": "A Data-driven Analysis of Code Optimizations", "comment": null, "summary": "As the demand for computational power grows, optimizing code through compilers becomes increasingly crucial. In this context, we focus on fully automatic code optimization techniques that automate the process of selecting and applying code transformations for better performance without manual intervention. Understanding how these transformations behave and interact is key to designing more effective optimization strategies. Compiler developers must make numerous design choices when constructing these heuristics. For instance, they may decide whether to allow transformations to be explored in any arbitrary order or to enforce a fixed sequence. While the former may theoretically offer the best performance gains, it significantly increases the search space. This raises an important question: Can a predefined, fixed order of applying transformations speed up the search without severely compromising optimization potential? In this paper, we address this and other related questions that arise in the design of automatic code optimization algorithms. Using a data-driven approach, we generate a large dataset of random programs, apply random optimization sequences, and record their execution times. Through statistical analysis, we provide insights that guide the development of more efficient automatic code optimization algorithms."}
