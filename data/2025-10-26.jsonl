{"id": "2510.19850", "categories": ["cs.PL", "cs.AI", "cs.CL", "cs.HC"], "pdf": "https://arxiv.org/pdf/2510.19850", "abs": "https://arxiv.org/abs/2510.19850", "authors": ["Mostapha Kalami Heris"], "title": "Prompt Decorators: A Declarative and Composable Syntax for Reasoning, Formatting, and Control in LLMs", "comment": null, "summary": "Large Language Models (LLMs) are central to reasoning, writing, and\ndecision-support workflows, yet users lack consistent control over how they\nreason and express outputs. Conventional prompt engineering relies on verbose\nnatural-language instructions, limiting reproducibility, modularity, and\ninterpretability. This paper introduces Prompt Decorators, a declarative,\ncomposable syntax that governs LLM behavior through compact control tokens such\nas +++Reasoning, +++Tone(style=formal), and +++Import(topic=\"Systems\nThinking\"). Each decorator modifies a behavioral dimension, such as reasoning\nstyle, structure, or tone, without changing task content. The framework\nformalizes twenty core decorators organized into two functional families\n(Cognitive & Generative and Expressive & Systemic), each further decomposed\ninto subcategories that govern reasoning, interaction, expression, and\nsession-control. It defines a unified syntax, scoping model, and deterministic\nprocessing pipeline enabling predictable and auditable behavior composition. By\ndecoupling task intent from execution behavior, Prompt Decorators create a\nreusable and interpretable interface for prompt design. Illustrative use cases\ndemonstrate improved reasoning transparency, reduced prompt complexity, and\nstandardized model behavior across domains. The paper concludes with\nimplications for interoperability, behavioral consistency, and the development\nof declarative interfaces for scalable AI systems."}
{"id": "2510.19853", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.19853", "abs": "https://arxiv.org/abs/2510.19853", "authors": ["Assaf Marron", "David Harel"], "title": "A Specification's Realm: Characterizing the Knowledge Required for Executing a Given Algorithm Specification", "comment": null, "summary": "An algorithm specification in natural language or pseudocode is expected to\nbe clear and explicit enough to enable mechanical execution. In this position\npaper we contribute an initial characterization of the knowledge that an\nexecuting agent, human or machine, should possess in order to be able to carry\nout the instructions of a given algorithm specification as a stand-alone\nentity, independent of any system implementation. We argue that, for that\nalgorithm specification, such prerequisite knowledge, whether unique or shared\nwith other specifications, can be summarized in a document of practical size.\nWe term this document the realm of the algorithm specification. The generation\nof such a realm is itself a systematic analytical process, significant parts of\nwhich can be automated with the help of large language models and the reuse of\nexisting documents. The algorithm-specification's realm would consist of\nspecification language syntax and semantics, domain knowledge restricted to the\nreferenced entities, inter-entity relationships, relevant underlying\ncause-and-effect rules, and detailed instructions and means for carrying out\ncertain operations. Such characterization of the realm can contribute to\nmethodological implementation of the algorithm specification in diverse systems\nand to its formalization for mechanical verification. The paper also touches\nupon the question of assessing execution faithfulness, which is distinct from\ncorrectness: in the absence of a reference interpretation of natural language\nor pseudocode specification with a given vocabulary, how can we determine if an\nobserved agent's execution indeed complies with the input specification."}
{"id": "2510.20018", "categories": ["cs.PL", "68N18 (Primary), 03B70 (Secondary)", "F.3.3; D.3.1"], "pdf": "https://arxiv.org/pdf/2510.20018", "abs": "https://arxiv.org/abs/2510.20018", "authors": ["Ryan Kavanagh", "Chuta Sano", "Brigitte Pientka"], "title": "Deconstructed Proto-Quipper: A Rational Reconstruction", "comment": "Submitted to the 35th European Symposium on Programming (ESOP 2026)", "summary": "The Proto-Quipper family of programming languages aims to provide a formal\nfoundation for the Quipper quantum programming language. Unfortunately,\nProto-Quipper languages have complex operational semantics: they are inherently\neffectful, and they rely on set-theoretic operations and fresh name generation\nto manipulate quantum circuits. This makes them difficult to reason about using\nstandard programming language techniques and, ultimately, to mechanize. We\nintroduce Proto-Quipper-A, a rational reconstruction of Proto-Quipper languages\nfor static circuit generation. It uses a linear $\\lambda$-calculus to describe\nquantum circuits with normal forms that closely correspond to box-and-wire\ncircuit diagrams. Adjoint-logical foundations integrate this circuit language\nwith a linear/non-linear functional language and let us reconstruct\nProto-Quipper's circuit programming abstractions using more primitive\nadjoint-logical operations. Proto-Quipper-A enjoys a simple call-by-value\nreduction semantics, and to illustrate its tractability as a foundation for\nProto-Quipper languages, we show that it is normalizing. We show how to use\nstandard logical relations to prove normalization of linear and substructural\nsystems, thereby avoiding the inherent complexity of existing linear logical\nrelations."}
{"id": "2510.20532", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.20532", "abs": "https://arxiv.org/abs/2510.20532", "authors": ["Patrycja Balik", "Szymon JÄ™dras", "Piotr Polesiuk"], "title": "Deciding not to Decide: Sound and Complete Effect Inference in the Presence of Higher-Rank Polymorphism", "comment": null, "summary": "Type-and-effect systems help the programmer to organize data and\ncomputational effects in a program. While for traditional type systems\nexpressive variants with sophisticated inference algorithms have been developed\nand widely used in programming languages, type-and-effect systems did not yet\ngain widespread adoption. One reason for this is that type-and-effect systems\nare more complex and the existing inference algorithms make compromises between\nexpressiveness, intuitiveness, and decidability. In this work, we present an\neffect inference algorithm for a type-and-effect system with subtyping,\nexpressive higher-rank polymorphism, and intuitive set-like semantics of\neffects. In order to deal with scoping issues of higher-rank polymorphism, we\ndelay solving of effect constraints by transforming them into formulae of\npropositional logic. We prove soundness and completeness of our algorithm with\nrespect to a declarative type-and-effect system. All the presented results have\nbeen formalized in the Rocq proof assistant, and the algorithm has been\nsuccessfully implemented in a realistic programming language."}
{"id": "2510.20050", "categories": ["cs.GR"], "pdf": "https://arxiv.org/pdf/2510.20050", "abs": "https://arxiv.org/abs/2510.20050", "authors": ["Floris Gisolf", "Zeno J. M. H. Geradts", "Marcel Worring"], "title": "Interactive Hypergraph Visual Analytics for Exploring Large and Complex Image Collections", "comment": null, "summary": "Analyzing large complex image collections in domains like forensics, accident\ninvestigation, or social media analysis involves interpreting intricate,\noverlapping relationships among images. Traditional clustering and\nclassification methods fail to adequately represent these complex\nrelationships, particularly when labeled data or suitable pre-trained models\nare unavailable. Hypergraphs effectively capture overlapping relationships, but\nto translate their complexity into information and insights for domain expert\nusers visualization is essential. We propose an interactive visual analytics\napproach specifically designed for the construction, exploration, and analysis\nof hypergraphs on large-scale complex image collections. Our core contributions\ninclude: (1) a scalable pipeline for constructing hypergraphs directly from raw\nimage data, including a similarity measure to evaluate constructed hypergraphs\nagainst a ground truth, (2) interactive visualization techniques that integrate\nspatial hypergraph representations, interactive grids, and matrix\nvisualizations, enabling users to dynamically explore and interpret\nrelationships without becoming overwhelmed and disoriented, and (3) practical\ninsights on how domain experts can effectively use the application, based on\nevaluation with real-life image collections. Our results demonstrate that our\nvisual analytics approach facilitates iterative exploration, enabling domain\nexperts to efficiently derive insights from image collections containing tens\nof thousands of images."}
{"id": "2510.20020", "categories": ["cs.GT", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.20020", "abs": "https://arxiv.org/abs/2510.20020", "authors": ["Luise Ge", "Gregory Kehne", "Yevgeniy Vorobeychik"], "title": "Optimized Distortion in Linear Social Choice", "comment": null, "summary": "Social choice theory offers a wealth of approaches for selecting a candidate\non behalf of voters based on their reported preference rankings over options.\nWhen voters have underlying utilities for these options, however, using\npreference rankings may lead to suboptimal outcomes vis-\\`a-vis utilitarian\nsocial welfare. Distortion is a measure of this suboptimality, and provides a\nworst-case approach for developing and analyzing voting rules when utilities\nhave minimal structure. However in many settings, such as common paradigms for\nvalue alignment, alternatives admit a vector representation, and it is natural\nto suppose that utilities are parametric functions thereof. We undertake the\nfirst study of distortion for linear utility functions. Specifically, we\ninvestigate the distortion of linear social choice for deterministic and\nrandomized voting rules. We obtain bounds that depend only on the dimension of\nthe candidate embedding, and are independent of the numbers of candidates or\nvoters. Additionally, we introduce poly-time instance-optimal algorithms for\nminimizing distortion given a collection of candidates and votes. We\nempirically evaluate these in two real-world domains: recommendation systems\nusing collaborative filtering embeddings, and opinion surveys utilizing\nlanguage model embeddings, benchmarking several standard rules against our\ninstance-optimal algorithms."}
{"id": "2510.20547", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.20547", "abs": "https://arxiv.org/abs/2510.20547", "authors": ["Nikolaus Huber", "Susanne Graf", "Philipp RÃ¼mmer", "Wang Yi"], "title": "Compiling the Mimosa programming language to RTOS tasks", "comment": null, "summary": "This paper introduces a compilation scheme for programs written in the Mimosa\nprogramming language, which builds upon the MIMOS model of computation. Mimosa\ndescribes embedded systems software as a collection of time-triggered processes\nwhich communicate through FIFO queues. We formally describe an adaptation of\nthe Lustre compilation scheme to the semantics of Mimosa and show how the\ncoordination layer can be mapped to real-time operating system primitives."}
{"id": "2510.20606", "categories": ["cs.GT", "cs.CY", "cs.LG", "econ.TH"], "pdf": "https://arxiv.org/pdf/2510.20606", "abs": "https://arxiv.org/abs/2510.20606", "authors": ["L. Elisa Celis", "Lingxiao Huang", "Milind Sohoni", "Nisheeth K. Vishnoi"], "title": "Strategic Costs of Perceived Bias in Fair Selection", "comment": "The paper has been accepted by NeurIPS 2025", "summary": "Meritocratic systems, from admissions to hiring, aim to impartially reward\nskill and effort. Yet persistent disparities across race, gender, and class\nchallenge this ideal. Some attribute these gaps to structural inequality;\nothers to individual choice. We develop a game-theoretic model in which\ncandidates from different socioeconomic groups differ in their perceived\npost-selection value--shaped by social context and, increasingly, by AI-powered\ntools offering personalized career or salary guidance. Each candidate\nstrategically chooses effort, balancing its cost against expected reward;\neffort translates into observable merit, and selection is based solely on\nmerit. We characterize the unique Nash equilibrium in the large-agent limit and\nderive explicit formulas showing how valuation disparities and institutional\nselectivity jointly determine effort, representation, social welfare, and\nutility. We further propose a cost-sensitive optimization framework that\nquantifies how modifying selectivity or perceived value can reduce disparities\nwithout compromising institutional goals. Our analysis reveals a\nperception-driven bias: when perceptions of post-selection value differ across\ngroups, these differences translate into rational differences in effort,\npropagating disparities backward through otherwise \"fair\" selection processes.\nWhile the model is static, it captures one stage of a broader feedback cycle\nlinking perceptions, incentives, and outcome--bridging rational-choice and\nstructural explanations of inequality by showing how techno-social environments\nshape individual incentives in meritocratic systems."}
{"id": "2510.20688", "categories": ["cs.PL", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.20688", "abs": "https://arxiv.org/abs/2510.20688", "authors": ["Oliver Braunsdorf", "Tim Lange", "Konrad Hohentanner", "Julian Horsch", "Johannes Kinder"], "title": "SafeFFI: Efficient Sanitization at the Boundary Between Safe and Unsafe Code in Rust and Mixed-Language Applications", "comment": null, "summary": "Unsafe Rust code is necessary for interoperability with C/C++ libraries and\nimplementing low-level data structures, but it can cause memory safety\nviolations in otherwise memory-safe Rust programs. Sanitizers can catch such\nmemory errors at runtime, but introduce many unnecessary checks even for memory\naccesses guaranteed safe by the Rust type system. We introduce SafeFFI, a\nsystem for optimizing memory safety instrumentation in Rust binaries such that\nchecks occur at the boundary between unsafe and safe code, handing over the\nenforcement of memory safety from the sanitizer to the Rust type system. Unlike\nprevious approaches, our design avoids expensive whole-program analysis and\nadds much less compile-time overhead (2.64x compared to over 8.83x). On a\ncollection of popular Rust crates and known vulnerable Rust code, SafeFFI\nachieves superior performance compared to state-of-the-art systems, reducing\nsanitizer checks by up to 98%, while maintaining correctness and flagging all\nspatial and temporal memory safety violations."}
