{"id": "2511.20859", "categories": ["cs.GT", "cs.AI", "cs.MA", "econ.TH", "q-bio.PE"], "pdf": "https://arxiv.org/pdf/2511.20859", "abs": "https://arxiv.org/abs/2511.20859", "authors": ["Sam Ganzfried"], "title": "Computing Evolutionarily Stable Strategies in Multiplayer Games", "comment": null, "summary": "We present an algorithm for computing all evolutionarily stable strategies in nondegenerate normal-form games with three or more players."}
{"id": "2511.20929", "categories": ["cs.GT"], "pdf": "https://arxiv.org/pdf/2511.20929", "abs": "https://arxiv.org/abs/2511.20929", "authors": ["Anton Baychkov", "Markus Brill", "Jannik Peters"], "title": "Utilitarian Guarantees for the Method of Equal Shares", "comment": null, "summary": "In recent years, research in Participatory Budgeting (PB) has put a greater emphasis on rules satisfying notions of fairness and proportionality, with the Method of Equal Shares (MES) being a prominent example. However, proportionality can come at a cost to the total utilitarian welfare. Our work formalizes this relationship, by deriving minimum utilitarian welfare guarantees for MES for a subclass of satisfaction functions called DNS functions, which includes two of the most popular ways of measuring a voter's utility in the PB setting: considering (1) the total cost of approved projects or (2) the total number of those projects. Our results are parameterized in terms of minimum and maximum project costs, which allows us to improve on the mostly negative results found in prior studies, and reduce to the existing multiwinner guarantee when project costs are equal. We show that our guarantees are asymptotically tight for rules satisfying Extended Justified Representation up to one project, showing that no proportional rule can achieve a better utilitarian guarantee than MES."}
{"id": "2511.21099", "categories": ["cs.GT", "cs.DS"], "pdf": "https://arxiv.org/pdf/2511.21099", "abs": "https://arxiv.org/abs/2511.21099", "authors": ["Chandra Chekuri", "Pooja Kulkarni", "Ruta Mehta", "Jan Vondrak"], "title": "Cycle Cancellation for Submodular Fractional Allocations and Applications", "comment": "20 pages", "summary": "We consider discrete allocation problem where $m$ indivisible goods are to be divided among $n$ agents. When agents' valuations are additive, the well-known cycle cancelling lemma by Lenstra, Shmoys, and Tardos plays a key role in design and analysis of rounding algorithms.\n  In this paper, we prove an analogous lemma for the case of submodular valuations. Our algorithm removes cycles in the support graph of a fractional allocation while guaranteeing that each agent's value, measured using the multilinear extension, does not decrease.\n  We demonstrate applications of the cycle-canceling algorithm, along with other ideas, to obtain new algorithms and results for three well-studied allocation objectives: max-min (Santa Claus problem), Nash social welfare (NSW), and maximin-share (MMS). For the submodular NSW problem, we obtain a $\\frac{1}{5}$-approximation; for the MMS problem, we obtain a $\\frac{1}{2}(1-1/e)$-approximation through new simple algorithms. For various special cases where the goods are \"small\" valued or the number of agents is constant, we obtain tight/best-known approximation algorithms. All our results are in the value-oracle model."}
{"id": "2511.21162", "categories": ["cs.GT"], "pdf": "https://arxiv.org/pdf/2511.21162", "abs": "https://arxiv.org/abs/2511.21162", "authors": ["Bhaskar Ray Chaudhury", "Christian Kroer", "Ruta Mehta", "Tianlong Nan"], "title": "Tâtonnement Dynamics for Fisher Markets with Chores", "comment": "46 pages, 7 figures", "summary": "In this paper, we initiate the study of tâtonnement dynamics in markets with chores. Tâtonnement is a fundamental market dynamics, capturing how prices evolve when they are adjusted in proportion of their excess demand. While its convergence to a competitive equilibrium (CE) is well understood in goods markets for broad classes of utilities, no analogous results are known for chore markets.\n  Analyzing tâtonnement in the chores market presents new challenges. Several elegant structural properties that facilitate convergence in goods markets-such as convexity of the equilibrium price set and monotonicity of excess demand under the tâtonnement price updates-fail to hold in the chore setting. Consistent with these difficulties, we first show that naïve tâtonnement diverges. To overcome this, we propose a modified process called relative tâtonnement, where prices are updated according to normalized excess demand. We prove its convergence to a CE under suitable step-size choices for a broad class of disutility functions, namely continuous, convex, and 1-homogeneous (CCH) disutilities. This class includes many standard forms such as linear and convex CES disutilities. Our proof proceeds by introducing a nonsmooth, nonconvex yet regular objective function-a generalization of the objective in the Eisenberg-Gale-type dual program introduced by [CKMN24].\n  For convex CES disutilities, where disutility is the weighted $p$-norm of the individual chore disutilities for $p \\in (1, \\infty)$, we show that relative tâtonnement converges to an $\\varepsilon$-CE in $O(1/\\varepsilon^2)$ iterations. This quadratic convergence rate is established by leveraging the polar gauge (or gauge dual) of the disutility function. Finally, following the framework of [AH58], we analyze the stability of CE and provide a complete characterization of local stability."}
{"id": "2511.21459", "categories": ["cs.GR"], "pdf": "https://arxiv.org/pdf/2511.21459", "abs": "https://arxiv.org/abs/2511.21459", "authors": ["Lorenzo De Rebotti", "Emanuele Giacomini", "Giorgio Grisetti", "Luca Di Giammarino"], "title": "Resolution Where It Counts: Hash-based GPU-Accelerated 3D Reconstruction via Variance-Adaptive Voxel Grids", "comment": "Accepted for publication in ACM Transaction on Graphics. Project site: https://rvp-group.github.io/mrhash/", "summary": "Efficient and scalable 3D surface reconstruction from range data remains a core challenge in computer graphics and vision, particularly in real-time and resource-constrained scenarios. Traditional volumetric methods based on fixed-resolution voxel grids or hierarchical structures like octrees often suffer from memory inefficiency, computational overhead, and a lack of GPU support. We propose a novel variance-adaptive, multi-resolution voxel grid that dynamically adjusts voxel size based on the local variance of signed distance field (SDF) observations. Unlike prior multi-resolution approaches that rely on recursive octree structures, our method leverages a flat spatial hash table to store all voxel blocks, supporting constant-time access and full GPU parallelism. This design enables high memory efficiency and real-time scalability. We further demonstrate how our representation supports GPU-accelerated rendering through a parallel quad-tree structure for Gaussian Splatting, enabling effective control over splat density. Our open-source CUDA/C++ implementation achieves up to 13x speedup and 4x lower memory usage compared to fixed-resolution baselines, while maintaining on par results in terms of reconstruction accuracy, offering a practical and extensible solution for high-performance 3D reconstruction."}
{"id": "2511.20782", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2511.20782", "abs": "https://arxiv.org/abs/2511.20782", "authors": ["Russel Arbore", "Alvin Cheung", "Max Willsey"], "title": "Optimism in Equality Saturation", "comment": null, "summary": "Equality saturation is a technique for program optimization based on non-destructive rewriting and a form of program analysis called e-class analysis. The current form of e-class analysis is pessimistic and therefore ineffective at analyzing cyclic programs, such as those in SSA form. We propose an abstract interpretation algorithm that can precisely analyze cycles during equality saturation. This results in a unified algorithm for optimistic analysis and non-destructive rewriting. We instantiate this approach on a prototype abstract interpreter for SSA programs using a new semantics of SSA. Our prototype can analyze simple example programs more precisely than clang and gcc."}
{"id": "2511.21262", "categories": ["cs.GT", "cs.CC", "cs.MA"], "pdf": "https://arxiv.org/pdf/2511.21262", "abs": "https://arxiv.org/abs/2511.21262", "authors": ["Caspar Oesterheld", "Vincent Conitzer"], "title": "Choosing What Game to Play without Selecting Equilibria: Inferring Safe (Pareto) Improvements in Binary Constraint Structures", "comment": "In Proceedings TARK 2025, arXiv:2511.20540", "summary": "We consider a setting in which a principal gets to choose which game from some given set is played by a group of agents. The principal would like to choose a game that favors one of the players, the social preferences of the players, or the principal's own preferences. Unfortunately, given the potential multiplicity of equilibria, it is conceptually unclear how to tell which of even any two games is better. Oesterheld et al. (2022) propose that we use assumptions about outcome correspondence -- i.e., about how the outcomes of different games relate -- to allow comparisons in some cases. For example, it seems reasonable to assume that isomorphic games are played isomorphically. From such assumptions we can sometimes deduce that the outcome of one game G' is guaranteed to be better than the outcome of another game G, even if we do not have beliefs about how each of G and G' will be played individually. Following Oesterheld et al., we then call G' a safe improvement on G.\n  In this paper, we study how to derive safe improvement relations. We first show that if we are given a set of games and arbitrary assumptions about outcome correspondence between these games, deriving safe improvement relations is co-NP-complete. We then study the (in)completeness of a natural set of inference rules for outcome correspondence. We show that in general the inference rules are incomplete. However, we also show that under natural, generally applicable assumptions about outcome correspondence the rules are complete."}
{"id": "2511.21209", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2511.21209", "abs": "https://arxiv.org/abs/2511.21209", "authors": ["Yee-Jian Tan", "Andreas Nuyts", "Dominique Devriese"], "title": "Towards Computational UIP in Cubical Agda", "comment": null, "summary": "Some advantages of Cubical Type Theory, as implemented by Cubical Agda, over intensional Martin-Löf Type Theory include Quotient Inductive Types (QITs), which exist as instances of Higher Inductive Types, and functional extensionality, which is provable in Cubical Type Theory. However, HoTT features an infinite hierarchy of equalities that may become unwieldy in formalisations. Fortunately, QITs and functional extensionality are both preserved even if the equality levels of Cubical Type Theory are truncated to only homotopical Sets (h-Sets). In other words, removing the univalence axiom from Cubical Type Theory and instead postulating a conflicting axiom: the Uniqueness of Identity Proofs (UIP) postulate. Since univalence is proved in Cubical Type Theory from the so-called Glue Types, therefore, it is known that one can first remove the Glue Types (thus removing univalence) and then set-truncate all equalities (essentially assuming UIP), à la XTT. The result is a \"h-Set Cubical Type Theory\" that retains features such as functional extensionality and QITs.\n  However, in Cubical Agda, there are currently only two unsatisfying ways to achieve h-Set Cubical Type Theory. The first is to give up on the canonicity of the theory and simply postulate the UIP axiom, while the second way is to use a standard result stating \"type formers preserve h-levels\" to manually prove UIP for every defined type. The latter is, however, laborious work best suited for an automatic implementation by the proof assistant. In this project, we analyse formulations of UIP and detail their computation rules for Cubical Agda, and evaluate their suitability for implementation. We also implement a variant of Cubical Agda without Glue, which is already compatible with postulated UIP, in anticipation of a future implementation of UIP in Cubical Agda."}
{"id": "2511.21637", "categories": ["cs.GT", "cs.DS", "econ.TH"], "pdf": "https://arxiv.org/pdf/2511.21637", "abs": "https://arxiv.org/abs/2511.21637", "authors": ["Vijay V. Vazirani"], "title": "Arctic Auctions, Linear Fisher Markets, and Rational Convex Programs", "comment": "24 pages", "summary": "This paper unifies two foundational constructs from economics and algorithmic game theory, the Arctic Auction and the linear Fisher market, to address the efficient allocation of differentiated goods in complex markets. Our main contributions are showing that an equilibrium for the Arctic Auction is captured by a Rational Convex Program, and deriving the first combinatorial polynomial-time algorithm for computing Arctic Auction equilibria."}
{"id": "2511.21509", "categories": ["cs.PL", "cs.SC", "cs.SE"], "pdf": "https://arxiv.org/pdf/2511.21509", "abs": "https://arxiv.org/abs/2511.21509", "authors": ["Dirk Beyer", "Gidon Ernst", "Martin Jonáš", "Marian Lingsch-Rosenfeld"], "title": "SV-LIB 1.0: A Standard Exchange Format for Software-Verification Tasks", "comment": null, "summary": "In the past two decades, significant research and development effort went into the development of verification tools for individual languages, such asC, C++, and Java. Many of the used verification approaches are in fact language-agnostic and it would be beneficial for the technology transfer to allow for using the implementations also for other programming and modeling languages. To address the problem, we propose SV-LIB, an exchange format and intermediate language for software-verification tasks, including programs, specifications, and verification witnesses. SV-LIBis based on well-known concepts from imperative programming languages and uses SMT-LIB to represent expressions and sorts used in the program. This makes it easy to parse and to build into existing infrastructure, since many verification tools are based on SMT solvers already. Furthermore, SV-LIBdefines a witness format for both correct and incorrect SV-LIB programs, together with means for specifying witness-validation tasks. This makes it possible both to implement independent witness validators and to reuse some verifiers also as validators for witnesses. This paper presents version 1.0 of the SV-LIBformat, including its design goals, the syntax, and informal semantics. Formal semantics and further extensions to concurrency are planned for future versions."}
