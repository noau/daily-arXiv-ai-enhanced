<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 1]
- [cs.PL](#cs.PL) [Total: 3]
- [cs.GT](#cs.GT) [Total: 1]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [Neighborhood-Preserving Voronoi Treemaps](https://arxiv.org/abs/2508.03445)
*Patrick Paetzold,Rebecca Kehlbeck,Yumeng Xue,Bin Chen,Yunhai Wang,Oliver Deussen*

Main category: cs.GR

TL;DR: 该论文提出了一种基于数据相似性的Voronoi树图算法，通过相似性匹配和贪婪交换优化，生成保留邻域关系的树图。


<details>
  <summary>Details</summary>
Motivation: 传统Voronoi树图仅展示层次结构，而数据中常存在其他属性（如地理边界或语义相似性）。论文旨在通过结合数据相似性，生成更具信息量的邻域保留树图。

Method: 方法包括：1) 数据预处理中引入相似性考量；2) 使用Kuhn-Munkres匹配将相似性与CVT单元对齐；3) 通过贪婪交换优化单元邻域；4) 迭代调整单元大小以保持邻域关系。

Result: 通过实际案例（信息图和语言学数据）验证了方法的实用性，并使用树图指标和邻域保留度量进行定量评估。

Conclusion: 论文提出的算法能有效生成保留数据相似性的Voronoi树图，为复杂数据的可视化提供了新工具。

Abstract: Voronoi treemaps are used to depict nodes and their hierarchical
relationships simultaneously. However, in addition to the hierarchical
structure, data attributes, such as co-occurring features or similarities,
frequently exist. Examples include geographical attributes like shared borders
between countries or contextualized semantic information such as embedding
vectors derived from large language models. In this work, we introduce a
Voronoi treemap algorithm that leverages data similarity to generate
neighborhood-preserving treemaps. First, we extend the treemap layout pipeline
to consider similarity during data preprocessing. We then use a Kuhn-Munkres
matching of similarities to centroidal Voronoi tessellation (CVT) cells to
create initial Voronoi diagrams with equal cell sizes for each level. Greedy
swapping is used to improve the neighborhoods of cells to match the data's
similarity further. During optimization, cell areas are iteratively adjusted to
their respective sizes while preserving the existing neighborhoods. We
demonstrate the practicality of our approach through multiple real-world
examples drawn from infographics and linguistics. To quantitatively assess the
resulting treemaps, we employ treemap metrics and measure neighborhood
preservation.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [2] [Compositional Quantum Control Flow with Efficient Compilation in Qunity](https://arxiv.org/abs/2508.02857)
*Mikhail Mints,Finn Voichick,Leonidas Lampropoulos,Robert Rand*

Main category: cs.PL

TL;DR: 本文提出了一种高效编译高级量子控制流结构的方法，改进了Qunity语言，并通过优化技术显著减少了量子比特和门的使用。


<details>
  <summary>Details</summary>
Motivation: 现有量子编程语言基于量子电路模型，高级抽象（尤其是量子控制流）难以实现。Qunity语言虽然提供了此类抽象，但缺乏实际实现且编译效率低下。

Method: 在Qunity基础上引入更广泛的高级抽象，开发了完整的Qunity编译器，将其转换为OpenQASM 3，并优化编译过程中的多个阶段。

Result: 通过低层电路优化和高层程序结构优化，显著减少了编译后的量子比特和门的使用量。

Conclusion: 本研究实现了高效的高级别量子控制流编译，为量子编程语言的实际应用提供了重要改进。

Abstract: Most existing quantum programming languages are based on the quantum circuit
model of computation, as higher-level abstractions are particularly challenging
to implement - especially ones relating to quantum control flow. The Qunity
language, proposed by Voichick et al., offered such an abstraction in the form
of a quantum control construct, with great care taken to ensure that the
resulting language is still realizable. However, Qunity lacked a working
implementation, and the originally proposed compilation procedure was very
inefficient, with even simple quantum algorithms compiling to unreasonably
large circuits.
  In this work, we focus on the efficient compilation of high-level quantum
control flow constructs, using Qunity as our starting point. We introduce a
wider range of abstractions on top of Qunity's core language that offer
compelling trade-offs compared to its existing control construct. We create a
complete implementation of a Qunity compiler, which converts high-level Qunity
code into the quantum assembly language OpenQASM 3. We develop optimization
techniques for multiple stages of the Qunity compilation procedure, including
both low-level circuit optimizations as well as methods that consider the
high-level structure of a Qunity program, greatly reducing the number of qubits
and gates used by the compiler.

</details>


### [3] [SAGE-HLS: Syntax-Aware AST-Guided LLM for High-Level Synthesis Code Generation](https://arxiv.org/abs/2508.03558)
*M Zafir Sadik Khan,Nowfel Mashnoor,Mohammad Akyash,Kimia Azar,Hadi Kamali*

Main category: cs.PL

TL;DR: 本文介绍了SAGE-HLS，一种专门用于高级综合（HLS）代码生成的微调大语言模型（LLM），通过将Verilog代码转换为C/C++并构建数据集，结合指令提示和AST引导的微调策略，提高了代码生成的成功率和功能性正确性。


<details>
  <summary>Details</summary>
Motivation: 在电子设计自动化（EDA）领域，高级综合（HLS）在硬件设计自动化和优化方面面临挑战，尤其是缺乏公开可用的HLS代码数据集。虽然大语言模型（LLM）在代码生成方面表现出色，但在HLS中的应用受到限制。

Method: 本文提出了SAGE-HLS模型，包括三个关键创新：（1）将Verilog代码转换为C/C++，构建16.7K的HLS代码数据集；（2）基于指令提示和AST引导的微调策略；（3）使用VerilogEval开发半自动化评估框架。

Result: 实验表明，基于QwenCoder（2.5）7B模型的SAGE-HLS在代码可合成性上达到近100%的成功率，在功能性正确性上达到75%的成功率。

Conclusion: SAGE-HLS通过独特的数据集构建和微调策略，显著提高了HLS代码生成的效率和准确性，为EDA领域提供了新的解决方案。

Abstract: In today's rapidly evolving field of electronic design automation (EDA), the
complexity of hardware designs is increasing, necessitating more sophisticated
automation solutions. High-level synthesis (HLS), as a pivotal solution,
automates hardware designs from high-level abstractions (e.g., C/C++). However,
it faces significant challenges, particularly in design space exploration and
optimization. While large language models (LLMs) have shown notable
capabilities in code generation, their application to HLS has been limited due
to the scarcity of (publicly) available HLS code datasets. Hence, research in
this domain has primarily focused on techniques such as prompt engineering and
retrieval-augmented generation (RAG). To overcome this limitation, this paper
introduces SAGE-HLS, the first-of-its-kind fine-tuned LLM specifically for HLS
code generation. Our method includes three key advancements: (i) We implement
Verilog-to-C/C++ porting, converting verified and synthesizable Verilog codes
into corresponding C, creating a dataset of 16.7K HLS codes; (ii) We implement
a fine-tuning strategy, which is based on instruction prompting to code
generation guided by abstract syntax tree (AST); (iii) We develop a
semi-automated evaluation framework using VerilogEval to assess the
functionality of the generated HLS code. Our experiments show that SAGE-HLS,
fined-tuned on the QwenCoder (2.5) 7B model, achieves a near 100% success rate
in code synthesizability and a 75% success rate in functional correctness.

</details>


### [4] [Teaching Introductory Functional Programming Using Haskelite](https://arxiv.org/abs/2508.03640)
*Pedro Vasconcelos*

Main category: cs.PL

TL;DR: 本论文报告了在波尔图大学的教学中，使用逐步跟踪解释器辅助学习Haskell子集的经验，展示了其对初学者的帮助效果。


<details>
  <summary>Details</summary>
Motivation: 学习函数式编程需要掌握基于替换的计算模型，尽管替换概念在高中代数中已有所涉及，但学生在递归定义、代数数据类型和高阶函数等新场景中仍感困难。

Method: 论文介绍了在函数式编程入门课程中使用逐步跟踪解释器的经验，详细描述了该解释器的使用方法，并收集了学生的反馈。

Result: 学生对逐步跟踪解释器的使用反馈表明，它有助于澄清误解并加深对函数式编程的理解。

Conclusion: 论文总结了使用逐步跟踪解释器的教学经验，并指出了未来进一步研究的方向。

Abstract: Learning functional programming requires learning a substitution-based
computational model. While substitution should be a familiar concept from
high-school algebra, students often have difficulty applying it to new
settings, such as recursive definitions, algebraic data types and higher-order
functions. Step-by-step interpreters have been shown to help beginners by
clarifying misconceptions and improving understanding.
  This paper reports on the experience of using a step-by-step tracing
interpreter for a subset of Haskell while teaching an introductory functional
programming course at the University of Porto. We describe the use of the
interpreter, present some feedback obtained from students, reflect on the
lessons learned and point directions for further work.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [5] [Approximate Proportionality in Online Fair Division](https://arxiv.org/abs/2508.03253)
*Davin Choo,Winston Fu,Derek Khu,Tzeh Yuan Neoh,Tze-Yang Poon,Nicholas Teh*

Main category: cs.GT

TL;DR: 研究了在线公平分割问题，发现贪婪算法在自适应对手下无法保证PROP1的近似性，但在非自适应对手下，随机分配可以高概率实现PROP1近似。并提出一种基于MIV预测的算法，但更强的公平性如EF1、MMS和PROPX即使有完美预测也无法近似。


<details>
  <summary>Details</summary>
Motivation: 以往研究已证明在线公平分割问题中经典公平性（如无嫉妒和最大化最小份额）的近似性是不可能的，因此研究转向更宽松的PROP1公平性，其近似性仍未被解决。

Method: 首先分析了贪婪算法在自适应对手下的表现，发现无法保证PROP1近似。接着研究了非自适应对手下的随机分配算法，以及基于MIV预测的算法。

Result: 贪婪算法在自适应对手下完全失败，但随机分配在非自适应对手下能以高概率实现PROP1近似。MIV预测算法能提供鲁棒的PROP1近似，但对EF1、MMS和PROPX则无法近似。

Conclusion: PROP1公平性在非自适应对手和预测信息的帮助下可实现近似，但更强的公平性即使有完美预测仍无法近似。

Abstract: We study the online fair division problem, where indivisible goods arrive
sequentially and must be allocated immediately and irrevocably to agents. Prior
work has established strong impossibility results for approximating classic
fairness notions, such as envy-freeness and maximin share fairness, in this
setting. In contrast, we focus on proportionality up to one good (PROP1), a
natural relaxation of proportionality whose approximability remains unresolved.
We begin by showing that three natural greedy algorithms fail to guarantee any
positive approximation to PROP1 in general, against an adaptive adversary. This
is surprising because greedy algorithms are commonly used in fair division and
a natural greedy algorithm is known to be able to achieve PROP1 under
additional information assumptions. This hardness result motivates the study of
non-adaptive adversaries and the use of side-information, in the spirit of
learning-augmented algorithms. For non-adaptive adversaries, we show that the
simple uniformly random allocation can achieve a meaningful PROP1 approximation
with high probability. Meanwhile, we present an algorithm that obtain robust
approximation ratios against PROP1 when given predictions of the maximum item
value (MIV). Interestingly, we also show that stronger fairness notions such as
EF1, MMS, and PROPX remain inapproximable even with perfect MIV predictions.

</details>
