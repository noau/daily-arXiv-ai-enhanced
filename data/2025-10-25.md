<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 1]
- [cs.PL](#cs.PL) [Total: 6]
- [cs.GT](#cs.GT) [Total: 2]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [Interactive Hypergraph Visual Analytics for Exploring Large and Complex Image Collections](https://arxiv.org/abs/2510.20050)
*Floris Gisolf,Zeno J. M. H. Geradts,Marcel Worring*

Main category: cs.GR

TL;DR: 提出了一种用于大规模复杂图像集合超图构建和探索的交互式视觉分析方法，结合了可扩展的管道和交互式可视化技术，帮助专家高效解读图像关系。


<details>
  <summary>Details</summary>
Motivation: 传统聚类和分类方法无法充分表示图像间的复杂重叠关系，而超图虽然能捕捉这些关系，但需可视化将其复杂性转化为可解释的信息。

Method: 提出了一个可扩展的管道来直接从原始图像数据构建超图，并结合交互式可视化技术（如空间超图表示、交互网格和矩阵可视化）支持动态探索。

Result: 实验结果表明，该方法支持专家高效地从包含数万张图像的集合中迭代探索和提取见解。

Conclusion: 该视觉分析方法有效支持了领域专家对大规模图像集合中复杂关系的探索和分析，具有实用价值。

Abstract: Analyzing large complex image collections in domains like forensics, accident
investigation, or social media analysis involves interpreting intricate,
overlapping relationships among images. Traditional clustering and
classification methods fail to adequately represent these complex
relationships, particularly when labeled data or suitable pre-trained models
are unavailable. Hypergraphs effectively capture overlapping relationships, but
to translate their complexity into information and insights for domain expert
users visualization is essential. We propose an interactive visual analytics
approach specifically designed for the construction, exploration, and analysis
of hypergraphs on large-scale complex image collections. Our core contributions
include: (1) a scalable pipeline for constructing hypergraphs directly from raw
image data, including a similarity measure to evaluate constructed hypergraphs
against a ground truth, (2) interactive visualization techniques that integrate
spatial hypergraph representations, interactive grids, and matrix
visualizations, enabling users to dynamically explore and interpret
relationships without becoming overwhelmed and disoriented, and (3) practical
insights on how domain experts can effectively use the application, based on
evaluation with real-life image collections. Our results demonstrate that our
visual analytics approach facilitates iterative exploration, enabling domain
experts to efficiently derive insights from image collections containing tens
of thousands of images.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [2] [Prompt Decorators: A Declarative and Composable Syntax for Reasoning, Formatting, and Control in LLMs](https://arxiv.org/abs/2510.19850)
*Mostapha Kalami Heris*

Main category: cs.PL

TL;DR: 本文介绍了一种称为“Prompt Decorators”的声明式、可组合语法，用于通过简洁的控制标记（如+++Reasoning、+++Tone）管理大型语言模型（LLM）的行为，而不改变任务内容。该方法提高了提示设计的可重用性和可解释性。


<details>
  <summary>Details</summary>
Motivation: 传统提示工程依赖于冗长的自然语言指令，限制了可重现性、模块化和可解释性。本文旨在通过Prompt Decorators实现对LLM行为的更一致控制。

Method: Prompt Decorators是一种声明式语法，通过控制标记（如+++Reasoning）修改行为维度（如推理风格或语气）。框架定义了20个核心装饰器和处理流水线。

Result: 该方法展示了改进的推理透明度、减少的提示复杂度以及跨领域统一的模型行为。

Conclusion: Prompt Decorators为可扩展AI系统的互操作性、行为一致性和声明式接口开发提供了新的可能性。

Abstract: Large Language Models (LLMs) are central to reasoning, writing, and
decision-support workflows, yet users lack consistent control over how they
reason and express outputs. Conventional prompt engineering relies on verbose
natural-language instructions, limiting reproducibility, modularity, and
interpretability. This paper introduces Prompt Decorators, a declarative,
composable syntax that governs LLM behavior through compact control tokens such
as +++Reasoning, +++Tone(style=formal), and +++Import(topic="Systems
Thinking"). Each decorator modifies a behavioral dimension, such as reasoning
style, structure, or tone, without changing task content. The framework
formalizes twenty core decorators organized into two functional families
(Cognitive & Generative and Expressive & Systemic), each further decomposed
into subcategories that govern reasoning, interaction, expression, and
session-control. It defines a unified syntax, scoping model, and deterministic
processing pipeline enabling predictable and auditable behavior composition. By
decoupling task intent from execution behavior, Prompt Decorators create a
reusable and interpretable interface for prompt design. Illustrative use cases
demonstrate improved reasoning transparency, reduced prompt complexity, and
standardized model behavior across domains. The paper concludes with
implications for interoperability, behavioral consistency, and the development
of declarative interfaces for scalable AI systems.

</details>


### [3] [A Specification's Realm: Characterizing the Knowledge Required for Executing a Given Algorithm Specification](https://arxiv.org/abs/2510.19853)
*Assaf Marron,David Harel*

Main category: cs.PL

TL;DR: 论文提出了一种称为“算法规范领域”的文档，用于总结执行算法规范时所需的先验知识，并讨论了其生成过程和执行忠实性的评估。


<details>
  <summary>Details</summary>
Motivation: 算法规范在自然语言或伪代码中的描述需要足够清晰和明确，以便机械执行。本文旨在定义执行代理（人或机器）在独立执行算法规范时应具备的先验知识。

Method: 提出了“算法规范领域”的概念，总结了规范语言语法、语义、领域知识、实体关系、因果关系规则以及操作指令等内容，并指出其生成过程可以部分自动化。

Result: 通过系统分析，生成了算法规范的领域文档，为算法的多样化系统实现和形式化验证提供了方法论支持。

Conclusion: 论文揭示了算法规范领域的价值，并探讨了执行忠实性的评估问题，为算法规范的实现和验证提供了新的视角。

Abstract: An algorithm specification in natural language or pseudocode is expected to
be clear and explicit enough to enable mechanical execution. In this position
paper we contribute an initial characterization of the knowledge that an
executing agent, human or machine, should possess in order to be able to carry
out the instructions of a given algorithm specification as a stand-alone
entity, independent of any system implementation. We argue that, for that
algorithm specification, such prerequisite knowledge, whether unique or shared
with other specifications, can be summarized in a document of practical size.
We term this document the realm of the algorithm specification. The generation
of such a realm is itself a systematic analytical process, significant parts of
which can be automated with the help of large language models and the reuse of
existing documents. The algorithm-specification's realm would consist of
specification language syntax and semantics, domain knowledge restricted to the
referenced entities, inter-entity relationships, relevant underlying
cause-and-effect rules, and detailed instructions and means for carrying out
certain operations. Such characterization of the realm can contribute to
methodological implementation of the algorithm specification in diverse systems
and to its formalization for mechanical verification. The paper also touches
upon the question of assessing execution faithfulness, which is distinct from
correctness: in the absence of a reference interpretation of natural language
or pseudocode specification with a given vocabulary, how can we determine if an
observed agent's execution indeed complies with the input specification.

</details>


### [4] [Deconstructed Proto-Quipper: A Rational Reconstruction](https://arxiv.org/abs/2510.20018)
*Ryan Kavanagh,Chuta Sano,Brigitte Pientka*

Main category: cs.PL

TL;DR: Proto-Quipper-A是一个静态电路生成的Proto-Quipper语言重构，使用线性$λ$-演算简化量子电路描述，并通过标准逻辑关系证明其规范化。


<details>
  <summary>Details</summary>
Motivation: Proto-Quipper语言因其复杂的操作语义和依赖于集合论操作而难以使用标准编程语言技术进行推理和机械化。Proto-Quipper-A旨在提供一个更简单且易于推理的基础。

Method: 引入Proto-Quipper-A，采用线性$λ$-演算描述量子电路，并结合线性/非线性功能语言重构Proto-Quipper的电路编程抽象。

Result: Proto-Quipper-A具有简单的按值调用归约语义，并证明了其规范化特性，避免了现有线性逻辑关系的复杂性。

Conclusion: Proto-Quipper-A通过重构和简化操作语义，成功提供了一个易于推理和机械化的基础，适用于Proto-Quipper语言。

Abstract: The Proto-Quipper family of programming languages aims to provide a formal
foundation for the Quipper quantum programming language. Unfortunately,
Proto-Quipper languages have complex operational semantics: they are inherently
effectful, and they rely on set-theoretic operations and fresh name generation
to manipulate quantum circuits. This makes them difficult to reason about using
standard programming language techniques and, ultimately, to mechanize. We
introduce Proto-Quipper-A, a rational reconstruction of Proto-Quipper languages
for static circuit generation. It uses a linear $\lambda$-calculus to describe
quantum circuits with normal forms that closely correspond to box-and-wire
circuit diagrams. Adjoint-logical foundations integrate this circuit language
with a linear/non-linear functional language and let us reconstruct
Proto-Quipper's circuit programming abstractions using more primitive
adjoint-logical operations. Proto-Quipper-A enjoys a simple call-by-value
reduction semantics, and to illustrate its tractability as a foundation for
Proto-Quipper languages, we show that it is normalizing. We show how to use
standard logical relations to prove normalization of linear and substructural
systems, thereby avoiding the inherent complexity of existing linear logical
relations.

</details>


### [5] [Deciding not to Decide: Sound and Complete Effect Inference in the Presence of Higher-Rank Polymorphism](https://arxiv.org/abs/2510.20532)
*Patrycja Balik,Szymon Jędras,Piotr Polesiuk*

Main category: cs.PL

TL;DR: 本文提出了一种用于类型和效应系统的效应推断算法，支持子类型、高阶多态和直观的类集效应语义，并通过将效应约束转化为命题逻辑公式来解决作用域问题。


<details>
  <summary>Details</summary>
Motivation: 尽管传统类型系统已发展出丰富的推理算法并被广泛采用，但类型和效应系统因其复杂性和现有算法在表达能力、直观性和可判定性之间的妥协而未能普及。

Method: 通过将高阶多态中的作用域问题转化为命题逻辑公式，延迟效应约束的求解，实现了一种支持子类型和高阶多态的效应推断算法。

Result: 算法在Rocq证明助手中形式化验证了其相对于声明式类型和效应系统的声音性和完备性，并成功应用于实际编程语言。

Conclusion: 该研究通过创新的约束求解方法，提高了类型和效应系统的可用性，为编程语言的实践提供了新工具。

Abstract: Type-and-effect systems help the programmer to organize data and
computational effects in a program. While for traditional type systems
expressive variants with sophisticated inference algorithms have been developed
and widely used in programming languages, type-and-effect systems did not yet
gain widespread adoption. One reason for this is that type-and-effect systems
are more complex and the existing inference algorithms make compromises between
expressiveness, intuitiveness, and decidability. In this work, we present an
effect inference algorithm for a type-and-effect system with subtyping,
expressive higher-rank polymorphism, and intuitive set-like semantics of
effects. In order to deal with scoping issues of higher-rank polymorphism, we
delay solving of effect constraints by transforming them into formulae of
propositional logic. We prove soundness and completeness of our algorithm with
respect to a declarative type-and-effect system. All the presented results have
been formalized in the Rocq proof assistant, and the algorithm has been
successfully implemented in a realistic programming language.

</details>


### [6] [Compiling the Mimosa programming language to RTOS tasks](https://arxiv.org/abs/2510.20547)
*Nikolaus Huber,Susanne Graf,Philipp Rümmer,Wang Yi*

Main category: cs.PL

TL;DR: 本文介绍了一种针对Mimosa编程语言的编译方案，该方案基于MIMOS计算模型，将嵌入式系统软件描述为一系列通过FIFO队列通信的时间触发进程，并展示了如何将其协调层映射到实时操作系统原语。


<details>
  <summary>Details</summary>
Motivation: Mimosa编程语言需要一种编译方案，以支持嵌入式系统软件的开发，特别是针对时间触发进程和FIFO队列通信的优化。

Method: 该论文采用了Lustre编译方案的改进版本，以适应Mimosa的语义，并展示了如何将协调层映射到实时操作系统的原语。

Result: 研究结果表明，该方法能够有效支持Mimosa程序的编译，并实现协调层与实时操作系统原语的映射。

Conclusion: 本文提出的编译方案为Mimosa编程语言的嵌入式系统开发提供了一种高效且可行的解决方案。

Abstract: This paper introduces a compilation scheme for programs written in the Mimosa
programming language, which builds upon the MIMOS model of computation. Mimosa
describes embedded systems software as a collection of time-triggered processes
which communicate through FIFO queues. We formally describe an adaptation of
the Lustre compilation scheme to the semantics of Mimosa and show how the
coordination layer can be mapped to real-time operating system primitives.

</details>


### [7] [SafeFFI: Efficient Sanitization at the Boundary Between Safe and Unsafe Code in Rust and Mixed-Language Applications](https://arxiv.org/abs/2510.20688)
*Oliver Braunsdorf,Tim Lange,Konrad Hohentanner,Julian Horsch,Johannes Kinder*

Main category: cs.PL

TL;DR: SafeFFI是一种优化Rust二进制文件中内存安全检测的系统，通过将检测集中在不安全与安全代码的边界，大幅减少了不必要的检查，同时保持正确性。


<details>
  <summary>Details</summary>
Motivation: Rust与C/C++库的不安全交互可能导致内存安全问题，而现有检查工具会对所有内存访问进行不必要的检查，增加了性能开销。

Method: SafeFFI通过避免昂贵的全程序分析，专注于不安全与安全代码边界的检测，减少了编译时的开销（2.64倍，而非8.83倍）。

Result: SafeFFI在流行Rust库和已知漏洞代码上表现出色，减少了高达98%的检查，同时捕捉了所有的时空内存安全问题。

Conclusion: SafeFFI在性能与安全性方面优于现有技术，为Rust程序提供了高效的内存安全检查解决方案。

Abstract: Unsafe Rust code is necessary for interoperability with C/C++ libraries and
implementing low-level data structures, but it can cause memory safety
violations in otherwise memory-safe Rust programs. Sanitizers can catch such
memory errors at runtime, but introduce many unnecessary checks even for memory
accesses guaranteed safe by the Rust type system. We introduce SafeFFI, a
system for optimizing memory safety instrumentation in Rust binaries such that
checks occur at the boundary between unsafe and safe code, handing over the
enforcement of memory safety from the sanitizer to the Rust type system. Unlike
previous approaches, our design avoids expensive whole-program analysis and
adds much less compile-time overhead (2.64x compared to over 8.83x). On a
collection of popular Rust crates and known vulnerable Rust code, SafeFFI
achieves superior performance compared to state-of-the-art systems, reducing
sanitizer checks by up to 98%, while maintaining correctness and flagging all
spatial and temporal memory safety violations.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [8] [Optimized Distortion in Linear Social Choice](https://arxiv.org/abs/2510.20020)
*Luise Ge,Gregory Kehne,Yevgeniy Vorobeychik*

Main category: cs.GT

TL;DR: 本研究首次探讨了线性效用函数的失真问题，分析了确定性和随机性投票规则在候选嵌入维度上的失真界限，并提出了一种多项式时间实例最优算法。


<details>
  <summary>Details</summary>
Motivation: 社会选择理论在投票排名基础上的候选选择可能导致次优结果，而失真衡量了这种次优性。本研究旨在分析线性效用函数下的失真问题。

Method: 研究了确定性和随机性投票规则在线性效用函数下的失真，提出了多项式时间实例最优算法，并在推荐系统和意见调查中进行了实证评估。

Result: 失真界限仅依赖于候选嵌入的维度，而与候选人或选民的数量无关。实证评估表明，实例最优算法优于标准规则。

Conclusion: 本研究为线性效用函数下的投票规则提供了理论界限和实用算法，展示了在现实场景中的应用潜力。

Abstract: Social choice theory offers a wealth of approaches for selecting a candidate
on behalf of voters based on their reported preference rankings over options.
When voters have underlying utilities for these options, however, using
preference rankings may lead to suboptimal outcomes vis-\`a-vis utilitarian
social welfare. Distortion is a measure of this suboptimality, and provides a
worst-case approach for developing and analyzing voting rules when utilities
have minimal structure. However in many settings, such as common paradigms for
value alignment, alternatives admit a vector representation, and it is natural
to suppose that utilities are parametric functions thereof. We undertake the
first study of distortion for linear utility functions. Specifically, we
investigate the distortion of linear social choice for deterministic and
randomized voting rules. We obtain bounds that depend only on the dimension of
the candidate embedding, and are independent of the numbers of candidates or
voters. Additionally, we introduce poly-time instance-optimal algorithms for
minimizing distortion given a collection of candidates and votes. We
empirically evaluate these in two real-world domains: recommendation systems
using collaborative filtering embeddings, and opinion surveys utilizing
language model embeddings, benchmarking several standard rules against our
instance-optimal algorithms.

</details>


### [9] [Strategic Costs of Perceived Bias in Fair Selection](https://arxiv.org/abs/2510.20606)
*L. Elisa Celis,Lingxiao Huang,Milind Sohoni,Nisheeth K. Vishnoi*

Main category: cs.GT

TL;DR: 该论文通过博弈论模型分析了社会经济群体之间在绩效评价系统中的不平等现象，揭示了感知驱动的偏见如何影响努力选择和结果差距。


<details>
  <summary>Details</summary>
Motivation: 探讨绩效评价系统中存在的种族、性别和阶级差距，试图通过模型揭示这些不平等的根源。

Method: 开发了一个博弈论模型，分析了不同社会经济群体在感知后选择价值上的差异如何影响个体的努力选择。

Result: 研究发现感知驱动的偏见会导致群体间的努力差异，从而在不公平的选择过程中加剧不平等。

Conclusion: 论文表明技术社会环境通过影响个体激励机制在绩效评价系统中维持不平等，并提出了一种优化框架以减少差距。

Abstract: Meritocratic systems, from admissions to hiring, aim to impartially reward
skill and effort. Yet persistent disparities across race, gender, and class
challenge this ideal. Some attribute these gaps to structural inequality;
others to individual choice. We develop a game-theoretic model in which
candidates from different socioeconomic groups differ in their perceived
post-selection value--shaped by social context and, increasingly, by AI-powered
tools offering personalized career or salary guidance. Each candidate
strategically chooses effort, balancing its cost against expected reward;
effort translates into observable merit, and selection is based solely on
merit. We characterize the unique Nash equilibrium in the large-agent limit and
derive explicit formulas showing how valuation disparities and institutional
selectivity jointly determine effort, representation, social welfare, and
utility. We further propose a cost-sensitive optimization framework that
quantifies how modifying selectivity or perceived value can reduce disparities
without compromising institutional goals. Our analysis reveals a
perception-driven bias: when perceptions of post-selection value differ across
groups, these differences translate into rational differences in effort,
propagating disparities backward through otherwise "fair" selection processes.
While the model is static, it captures one stage of a broader feedback cycle
linking perceptions, incentives, and outcome--bridging rational-choice and
structural explanations of inequality by showing how techno-social environments
shape individual incentives in meritocratic systems.

</details>
