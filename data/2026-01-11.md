<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 4]
- [cs.PL](#cs.PL) [Total: 3]
- [cs.GT](#cs.GT) [Total: 1]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [In-SRAM Radiant Foam Rendering on a Graph Processor](https://arxiv.org/abs/2601.04382)
*Zulkhuu Tuya,Ignacio Alzugaray,Nicholas Fry,Andrew J. Davison*

Main category: cs.GR

TL;DR: 论文提出了一种在Graphcore Mk2 IPU多核加速器上实现的全SRAM分布式渲染器，通过分片场景和分层路由覆盖，实现了高效的体绘制渲染。


<details>
  <summary>Details</summary>
Motivation: 新兴的多核加速器采用分散的小型SRAM和显式通信，破坏了传统体绘制技术依赖的大规模统一场景访问假设，因此需要开发新的渲染方法。

Method: 采用Radiant Foam Voronoi单元体表示法，将场景分片分配到多核加速器的各个瓦片上，并通过分层路由覆盖实现高效的射线追踪和通信。

Result: 在Mip-NeRF 360场景中，系统实现了接近交互式的吞吐率（约1 fps，640×480分辨率），图像和深度质量接近原始GPU实现，同时所有场景数据和射线状态保持在片内SRAM中。

Conclusion: 研究不仅验证了可行性，还分析了路由、内存和调度瓶颈，为未来分布式内存加速器更好地支持不规则、数据密集的渲染工作负载提供了指导。

Abstract: Many emerging many-core accelerators replace a single large device memory with hundreds to thousands of lightweight cores, each owning only a small local SRAM and exchanging data via explicit on-chip communication. This organization offers high aggregate bandwidth, but it breaks a key assumption behind many volumetric rendering techniques: that rays can randomly access a large, unified scene representation. Rendering efficiently on such hardware therefore requires distributing both data and computation, keeping ray traversal mostly local, and structuring communication into predictable routes.
  We present a fully in-SRAM, distributed renderer for the \emph{Radiant Foam} Voronoi-cell volumetric representation on the Graphcore Mk2 IPU, a many-core accelerator with tile-local SRAM and explicit inter-tile communication. Our system shards the scene across tiles and forwards rays between shards through a hierarchical routing overlay, enabling ray marching entirely from on-chip SRAM with predictable communication. On Mip-NeRF~360 scenes, the system attains near-interactive throughput (\(\approx\)1\,fps at \mbox{$640\times480$}) with image and depth quality close to the original GPU-based Radiant Foam implementation, while keeping all scene data and ray state in on-chip SRAM. Beyond demonstrating feasibility, we analyze routing, memory, and scheduling bottlenecks that inform how future distributed-memory accelerators can better support irregular, data-movement-heavy rendering workloads.

</details>


### [2] [Differential Locally Injective Grid Deformation and Optimization](https://arxiv.org/abs/2601.04494)
*Julian Knodt,Seung-Hwan Baek*

Main category: cs.GR

TL;DR: 该论文提出了一种无反转的网格变形方法，通过优化微分权重来自适应压缩空间，并利用顶点着色将密集线性系统分解为多个独立的顶点集以实现并行优化。


<details>
  <summary>Details</summary>
Motivation: 均匀网格无法动态分配分辨率以适应细节变化，而现有的间接网格适应性方法（如四面体网格或局部细分网格）在无反转变形方面存在困难。本研究旨在开发一种无反转的网格变形方法以解决这一问题。

Method: 该方法通过优化微分权重和顶点着色技术，将密集输入线性系统分解为多个独立的顶点集，实现并行优化。此外，该方法还扩展到优化具有凸边界的UV网格。

Result: 实验表明，微分表示比更新外部顶点坐标提供了更平滑的优化流形。通过独立优化顶点集中的顶点，可以轻松进行局部单射性检查。该方法在等值面提取、图像压缩和网格参数化等应用中表现出广泛的适用性和高效性。

Conclusion: 该方法为网格变形提供了一种新颖且高效的解决方案，适用于多种应用场景。通过优化微分权重和并行处理顶点集，显著提升了网格变形的适应性和计算效率。

Abstract: Grids are a general representation for capturing regularly-spaced information, but since they are uniform in space, they cannot dynamically allocate resolution to regions with varying levels of detail. There has been some exploration of indirect grid adaptivity by replacing uniform grids with tetrahedral meshes or locally subdivided grids, as inversion-free deformation of grids is difficult. This work develops an inversion-free grid deformation method that optimizes differential weight to adaptively compress space. The method is the first to optimize grid vertices as differential elements using vertex-colorings, decomposing a dense input linear system into many independent sets of vertices which can be optimized concurrently. This method is then also extended to optimize UV meshes with convex boundaries. Experimentally, this differential representation leads to a smoother optimization manifold than updating extrinsic vertex coordinates. By optimizing each sets of vertices in a coloring separately, local injectivity checks are straightforward since the valid region for each vertex is fixed. This enables the use of optimizers such as Adam, as each vertex can be optimized independently of other vertices. We demonstrate the generality and efficacy of this approach through applications in isosurface extraction for inverse rendering, image compaction, and mesh parameterization.

</details>


### [3] [LooseRoPE: Content-aware Attention Manipulation for Semantic Harmonization](https://arxiv.org/abs/2601.05127)
*Etai Sella,Yoav Baron,Hadar Averbuch-Elor,Daniel Cohen-Or,Or Patashnik*

Main category: cs.GR

TL;DR: LooseRoPE通过调制旋转位置编码（RoPE）来实现图像编辑，用户在无需文本提示的情况下直接裁剪和粘贴对象，同时平衡对象的保留与新环境的协调。


<details>
  <summary>Details</summary>
Motivation: 现有基于扩散的图像编辑方法通常依赖于文本或高级指令，控制较粗；本文旨在实现无需提示的直接编辑，用户可通过裁剪和粘贴对象精确控制，但需解决对象身份保留与环境协调的挑战。

Method: 通过观察扩散模型中注意力图的作用，提出了LooseRoPE方法，调制RoPE以放松位置约束，动态控制注意力视野，从而在对象保留和环境协调间实现平衡。

Result: LooseRoPE提供了一个灵活直观的图像编辑框架，无需文本描述或复杂输入即可实现无缝的合成效果。

Conclusion: LooseRoPE通过松弛RoPE的方法，实现了对象身份保留与环境协调的平衡，为图像编辑提供了新的解决方案。

Abstract: Recent diffusion-based image editing methods commonly rely on text or high-level instructions to guide the generation process, offering intuitive but coarse control. In contrast, we focus on explicit, prompt-free editing, where the user directly specifies the modification by cropping and pasting an object or sub-object into a chosen location within an image. This operation affords precise spatial and visual control, yet it introduces a fundamental challenge: preserving the identity of the pasted object while harmonizing it with its new context. We observe that attention maps in diffusion-based editing models inherently govern whether image regions are preserved or adapted for coherence. Building on this insight, we introduce LooseRoPE, a saliency-guided modulation of rotational positional encoding (RoPE) that loosens the positional constraints to continuously control the attention field of view. By relaxing RoPE in this manner, our method smoothly steers the model's focus between faithful preservation of the input image and coherent harmonization of the inserted object, enabling a balanced trade-off between identity retention and contextual blending. Our approach provides a flexible and intuitive framework for image editing, achieving seamless compositional results without textual descriptions or complex user input.

</details>


### [4] [GenAI-DrawIO-Creator: A Framework for Automated Diagram Generation](https://arxiv.org/abs/2601.05162)
*Jinze Yu,Dayuan Jiang*

Main category: cs.GR

TL;DR: GenAI-DrawIO-Creator利用大型语言模型（LLMs）自动化生成和修改draw.io格式的图表，显著提高效率。


<details>
  <summary>Details</summary>
Motivation: 图表的创建和修改通常耗时耗力，需要一种自动化工具来简化这一过程。

Method: 结合Claude 3.7模型，通过高级系统设计、专门提示工程和错误检查，生成结构化XML格式的图表。

Result: 原型系统能够从自然语言或代码生成准确的图表（如网络架构和流程图），同时显著减少创建时间。

Conclusion: Claude 3.7在处理结构化视觉推理任务方面表现出色，为未来AI辅助图表应用奠定了基础。

Abstract: Diagrams are crucial for communicating complex information, yet creating and modifying them remains a labor-intensive task. We present GenAI-DrawIO-Creator, a novel framework that leverages Large Language Models (LLMs) to automate diagram generation and manipulation in the structured XML format used by draw.io. Our system integrates Claude 3.7 to reason about structured visual data and produce valid diagram representations. Key contributions include a high-level system design enabling real-time diagram updates, specialized prompt engineering and error-checking to ensure well-formed XML outputs. We demonstrate a working prototype capable of generating accurate diagrams (such as network architectures and flowcharts) from natural language or code, and even replicating diagrams from images. Simulated evaluations show that our approach significantly reduces diagram creation time and produces outputs with high structural fidelity. Our results highlight the promise of Claude 3.7 in handling structured visual reasoning tasks and lay the groundwork for future research in AI-assisted diagramming applications.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [5] [Scalable Floating-Point Satisfiability via Staged Optimization](https://arxiv.org/abs/2601.04492)
*Yuanzhuo Zhang,Zhoulai Fu,Binoy Ravindran*

Main category: cs.PL

TL;DR: StageSAT是一种结合SMT求解与数值优化的新方法，通过三阶段逐步提升精度的方式解决浮点可满足性问题，显著提高了性能和正确性。


<details>
  <summary>Details</summary>
Motivation: 现有的浮点可满足性求解方法在性能和准确性上存在不足，StageSAT旨在通过结合SMT求解和数值优化，提供一种更高效且可靠的方法。

Method: StageSAT将浮点公式重构为三个阶段的一系列优化问题，使用快速投影辅助下降目标引导搜索，逐步提升精度至位级别。通过正交投影引入部分单调下降性质，避免优化过程停滞。

Result: StageSAT在广泛的基准测试中表现优异，解决了比竞争求解器更多的公式，召回率高达99.4%，且未产生虚假模型。速度比传统求解器快5至10倍。

Conclusion: StageSAT通过分阶段优化显著提升了浮点可满足性求解的性能和正确性，证明了其在复杂算术问题中的高效性和可靠性。

Abstract: This work introduces StageSAT, a new approach to solving floating-point satisfiability that bridges SMT solving with numerical optimization. StageSAT reframes a floating-point formula as a series of optimization problems in three stages of increasing precision. It begins with a fast, projection-aided descent objective to guide the search toward a feasible region, proceeding to bit-level accuracy with ULP$^2$ optimization and a final $n$-ULP lattice refinement.
  By construction, the final stage uses a representing function that is zero if and only if a candidate satisfies all constraints. Thus, when optimization drives the objective to zero, the resulting assignment is a valid solution, providing a built-in guarantee of soundness.
  To improve search, StageSAT introduces a partial monotone descent property on linear constraints via orthogonal projection, preventing the optimizer from stalling on flat or misleading landscapes. Critically, this solver requires no heavy bit-level reasoning or specialized abstractions; it treats complex arithmetic as a black-box, using runtime evaluations to navigate the input space.
  We implement StageSAT and evaluate it on extensive benchmarks, including SMT-COMP'25 suites and difficult cases from prior work. StageSAT proved more scalable and accurate than state-of-the-art optimization-based alternatives. It solved strictly more formulas than any competing solver under the same time budget, finding most satisfiable instances without producing spurious models. This amounts to 99.4% recall on satisfiable cases with 0% false SAT, exceeding the reliability of prior optimization-based solvers. StageSAT also delivered significant speedups (often 5--10$\times$) over traditional bit-precise SMT and numeric solvers. These results demonstrate that staged optimization significantly improves performance and correctness of floating-point satisfiability solving.

</details>


### [6] [Lenses for Partially-Specified States (Extended Version)](https://arxiv.org/abs/2601.04573)
*Kazutaka Matsuda,Minh Nguyen,Meng Wang*

Main category: cs.PL

TL;DR: 本文提出了一种部分状态透镜的方法，用于在双向转换中精确表示用户的更新意图，并在多视图共享源时提供清晰的合并语义。


<details>
  <summary>Details</summary>
Motivation: 在多视图共享源的双向转换过程中，一个视图的更新可能会影响其他视图，尤其是在多个视图同时更改时，很难维护一致性并保留用户的更新意图。

Method: 本文引入了部分状态透镜的概念，允许部分指定源和视图状态，以精确表示用户的更新意图，并提供了部分指定的有序语义，用于合并多视图的意图。

Result: 通过形式化部分状态透镜及其支持的组合推理和更新保留的优良性质，作者展示了该方法在实践中的实用性。

Conclusion: 部分状态透镜为解决多视图共享源时的更新意图表示和合并问题提供了一种有效的方法，同时支持组合推理和更新保留。

Abstract: A bidirectional transformation is a pair of transformations satisfying certain well-behavedness properties: one maps source data into view data, and the other translates changes on the view back to the source. However, when multiple views share a source, an update on one view may affect the others, making it hard to maintain correspondence while preserving the user's update, especially when multiple views are changed at once. Ensuring these properties within a compositional framework is even more challenging. In this paper, we propose partial-state lenses, which allow source and view states to be partially specified to precisely represent the user's update intentions. These intentions are partially ordered, providing clear semantics for merging intentions of updates coming from multiple views and a refined notion of update preservation compatible with this merging. We formalize partial-state lenses, together with partial-specifiedness-aware well-behavedness that supports compositional reasoning and ensures update preservation. In addition, we demonstrate the utility of the proposed system through examples.

</details>


### [7] [The Squirrel Parser: A Linear-Time PEG Packrat Parser Capable of Left Recursion and Optimal Error Recovery](https://arxiv.org/abs/2601.05012)
*Luke A. D. Hutchison*

Main category: cs.PL

TL;DR: 松鼠解析器是一种PEG打包解析器，直接处理所有形式的左递归，并提供最优错误恢复，同时即使在存在任意数量错误的情况下也能保持输入长度的线性时间复杂性。


<details>
  <summary>Details</summary>
Motivation: 传统的递归下降解析器处理左递归需要语法重写或复杂的算法扩展，这增加了实现的复杂性和维护成本。松鼠解析器旨在直接从第一原理推导最小算法来解决这一问题。

Method: 通过基于位置的状态跟踪和O(1)-per-LR-cycle的递归框架间通信实现循环检测，通过迭代扩展进行定点搜索。错误恢复方面，定义了四条公理和十二个约束条件，使用约束满足机制搜索所有可能性。

Result: 开发出一种最优且稳健的错误恢复策略，既能确保性能的完美线性，又能提供直观的行为表现。

Conclusion: 松鼠解析器不仅解决了传统方法中的复杂性问题，还提供了一种高效且直观的左递归处理和错误恢复方案。

Abstract: We present the squirrel parser, a PEG packrat parser that directly handles all forms of left recursion with optimal error recovery, while maintaining linear time complexity in the length of the input even in the presence of an arbitrary number of errors. Traditional approaches to handling left recursion in a recursive descent parser require grammar rewriting or complex algorithmic extensions. We derive a minimal algorithm from first principles: cycle detection via per-position state tracking and $O(1)$-per-LR-cycle communication from descendant to ancestor recursion frames, and fixed-point search via iterative expansion. For error recovery, we derived a set of four axioms and twelve constraints that must be imposed upon an optimal error recovery design to ensure completeness, correctness, optimality of performance, and intuitiveness of behavior. We utilized a constraint satisfaction mechanism to search the space of all possibilities, arriving at a provably optimal and robust error recovery strategy that maintains perfect performance linearity.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [8] [Mechanism Design for Federated Learning with Non-Monotonic Network Effects](https://arxiv.org/abs/2601.04648)
*Xiang Li,Bing Luo,Jianwei Huang,Yuan Luo*

Main category: cs.GT

TL;DR: 本文提出了一种用于联邦学习的激励机制设计，考虑了网络效应和特定应用的模型性能需求，通过MoTS框架和SWAN机制显著提升了社会福利。


<details>
  <summary>Details</summary>
Motivation: 现有的联邦学习激励机制忽略了网络效应用户参与的多样化和模型性能需求，导致激励和社会福利不理想或不适用。

Method: 开发理论模型量化网络效应对参与者异质性的影响，提出MoTS框架和SWAN机制，利用模型交易和客户支付激励策略行为。

Result: 实验结果表明，SWAN机制在硬件原型上表现优于现有机制，社会福利提升352.42%，额外激励成本降低93.07%。

Conclusion: SWAN机制有效解决了联邦学习中的网络效应和模型性能需求问题，显著提升了社会福利和激励效率。

Abstract: Mechanism design is pivotal to federated learning (FL) for maximizing social welfare by coordinating self-interested clients. Existing mechanisms, however, often overlook the network effects of client participation and the diverse model performance requirements (i.e., generalization error) across applications, leading to suboptimal incentives and social welfare, or even inapplicability in real deployments. To address this gap, we explore incentive mechanism design for FL with network effects and application-specific requirements of model performance. We develop a theoretical model to quantify the impact of network effects on heterogeneous client participation, revealing the non-monotonic nature of such effects. Based on these insights, we propose a Model Trading and Sharing (MoTS) framework, which enables clients to obtain FL models through either participation or purchase. To further address clients' strategic behaviors, we design a Social Welfare maximization with Application-aware and Network effects (SWAN) mechanism, exploiting model customer payments for incentivization. Experimental results on a hardware prototype demonstrate that our SWAN mechanism outperforms existing FL mechanisms, improving social welfare by up to $352.42\%$ and reducing extra incentive costs by $93.07\%$.

</details>
