<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 2]
- [cs.PL](#cs.PL) [Total: 1]
- [cs.GT](#cs.GT) [Total: 1]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [Anisotropic Green Coordinates](https://arxiv.org/abs/2512.20386)
*Dong Xiao,Renjie Chen,Bailin Deng*

Main category: cs.GR

TL;DR: 该论文提出了一种基于各向异性拉普拉斯方程的格林坐标方法，用于增强笼式变形和变分形状变形的灵活性。


<details>
  <summary>Details</summary>
Motivation: 自然界和工程系统中普遍存在各向异性特性，本研究旨在通过引入各向异性格林坐标，为空间变形提供更灵活的解决方案。

Method: 基于各向异性拉普拉斯方程，推导边界积分公式并离散化，得到各向异性格林坐标，并结合局部-全局优化框架实现变分形状变形。

Result: 实验结果表明，各向异性格林坐标能够提供多样化的变形选项，增强了艺术家的操作灵活性，并为空间变形提供了新视角。

Conclusion: 各向异性格林坐标方法在笼式变形和变分形状变形中展现出多功能性，为空间变形研究提供了新的理论和实用工具。

Abstract: We live in a world filled with anisotropy, a ubiquitous characteristic of both natural and engineered systems. In this study, we concentrate on space deformation and introduce anisotropic Green coordinates, which provide versatile effects for cage-based and variational deformations in both two and three dimensions. The anisotropic Green coordinates are derived from the anisotropic Laplacian equation $\nabla\cdot(\mathbf{A}\nabla u)=0$, where $\mathbf{A}$ is a symmetric positive definite matrix. This equation belongs to the class of constant-coefficient second-order elliptic equations, exhibiting properties analogous to the Laplacian equation but incorporating the matrix $\mathbf{A}$ to characterize anisotropic behavior. Based on this equation, we establish the boundary integral formulation, which is subsequently discretized to derive anisotropic Green coordinates defined on the vertices and normals of oriented simplicial cages. The deformation satisfies basic properties such as linear reproduction and translation invariance, and has closed-form expressions for both 2D and 3D scenarios. We also offer intuitive geometric interpretations of this method. Furthermore, our approach computes the gradient and Hessian of the deformation coordinates and employs the local-global optimization framework to facilitate variational shape deformation, enabling flexible shape manipulation while achieving as-rigid-as-possible shape deformation. Experimental results demonstrate that anisotropic Green coordinates offer versatile and diverse deformation options, providing artists with enhanced flexibility and introducing a novel perspective on spatial deformation.

</details>


### [2] [LLM-Based Authoring of Agent-Based Narratives through Scene Descriptions](https://arxiv.org/abs/2512.20550)
*Vinayak Regmi,Christos Mousas*

Main category: cs.GR

TL;DR: 本文提出了一种基于大型语言模型（LLMs）的程序化生成代理叙事系统，支持用户快速生成虚拟代理活动。


<details>
  <summary>Details</summary>
Motivation: 旨在通过LLMs将高级场景描述转化为可执行的代理行为，简化代理叙事的生成过程。

Method: 用户通过拖放代理和对象构建场景，场景结构被序列化为自然语言提示并发送给LLM，解析返回的结构化字符串以触发代理行为。

Result: 评估了四种轻量级LLM的性能，结果显示LLMs能可靠地将场景描述转化为代理行为。

Conclusion: 该系统证实了LLMs在程序化代理叙事生成中的高效性和适用性。

Abstract: This paper presents a system for procedurally generating agent-based narratives using large language models (LLMs). Users could drag and drop multiple agents and objects into a scene, with each entity automatically assigned semantic metadata describing its identity, role, and potential interactions. The scene structure is then serialized into a natural language prompt and sent to an LLM, which returns a structured string describing a sequence of actions and interactions among agents and objects. The returned string encodes who performed which actions, when, and how. A custom parser interprets this string and triggers coordinated agent behaviors, animations, and interaction modules. The system supports agent-based scenes, dynamic object manipulation, and diverse interaction types. Designed for ease of use and rapid iteration, the system enables the generation of virtual agent activity suitable for prototyping agent narratives. The performance of the developed system was evaluated using four popular lightweight LLMs. Each model's process and response time were measured under multiple complexity scenarios. The collected data were analyzed to compare consistency across the examined scenarios and to highlight the relative efficiency and suitability of each model for procedural agent-based narratives generation. The results demonstrate that LLMs can reliably translate high-level scene descriptions into executable agent-based behaviors.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [3] [Error Localization, Certificates, and Hints for Probabilistic Program Verification via Slicing (Extended Version)](https://arxiv.org/abs/2512.20214)
*Philipp Schröer,Darion Haase,Joost-Pieter Katoen*

Main category: cs.PL

TL;DR: 本文提出了一种在概率程序演绎验证中生成有效用户诊断的方法，基于HeyVL语言定义切片概念，用于错误报告、证明简化和保留成功验证结果，并通过实现工具Brutus验证了其有效性。


<details>
  <summary>Details</summary>
Motivation: 概率程序的演绎验证需要有效的用户诊断工具，以帮助定位错误、简化证明过程并保留已验证的结果。现有方法在这些方面存在不足，因此本文提出新的诊断方法。

Method: 基于HeyVL语言，本文定义了三种切片概念：错误报告、证明简化和保留验证结果。通过工具Brutus实现这些切片算法，包括基于二分搜索的错误定位和多种切片验证算法。

Result: Brutus工具在多种基准测试中表现出色，能够生成小型且信息丰富的切片，验证了所提方法的正确性和实用性。

Conclusion: 本文提出的切片方法及其实现Brutus在概率程序验证中提供了有效的用户诊断工具，显著提升了错误定位和证明简化的能力。

Abstract: This paper focuses on effective user diagnostics generated during the deductive verification of probabilistic programs. Our key principle is based on providing slices for (1) error reporting, (2) proof simplification, and (3) preserving successful verification results. By formally defining these different notions on HeyVL, an existing quantitative intermediate verification language (IVL), our concepts (and implementation) can be used to obtain diagnostics for a range of probabilistic programming languages. Slicing for error reporting is a novel notion of error localization for quantitative assertions. We demonstrate slicing-based diagnostics on a variety of proof rules such as quantitative versions of the specification statement and invariant-based loop rules, and formally prove the correctness of specialized error messages and verification hints.
  We implemented our user diagnostics into the deductive verifier Caesar. Our novel implementation -- called \emph{Brutus} -- can search for slices which do or do not verify, corresponding to each of the three diagnostic notions. For error reporting (1), it exploits a binary search-based algorithm that minimizes error-witnessing slices. To solve for slices that verify (2 and 3), we empirically compare different algorithms based on unsatisfiable cores, minimal unsatisfiable subset enumeration, and a direct SMT encoding of the slicing problem. Our empirical evaluation of Brutus on existing and new benchmarks shows that we can find slices that are both small and informative.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [4] [Maximizing the Egalitarian Welfare in Friends and Enemies Games](https://arxiv.org/abs/2512.20261)
*Edith Elkind,Michele Flammini,Giovanna Varricchio*

Main category: cs.GT

TL;DR: 研究了在朋友与敌人游戏中最大化平等福利的复杂性，分析了两种经典场景（$ackslashackslash mathsf{FA}$和$ackslashackslash mathsf{EA}$）的计算难度和近似算法。


<details>
  <summary>Details</summary>
Motivation: 探讨在朋友与敌人游戏中实现公平分配的计算复杂性，尤其是在两种不同偏好（朋友优先或敌人优先）场景下的挑战。

Method: 针对$ackslashackslash mathsf{FA}$和$ackslashackslash mathsf{EA}$两种场景，分别提出了NP难问题的证明和多项式时间近似算法。

Result: $ackslashackslash mathsf{EA}$场景下目标难近似于$O(n^{1-ε})$，提出了$(n-1)$-近似算法；$ackslashackslash mathsf{FA}$场景下证明了NP难并提供了近似比为$2-Θ(ackslashackslash frac{1}{n})$的算法。

Conclusion: 在特定情况下可通过多项式时间算法找到最优解，但一般问题的计算复杂度较高，需依赖近似算法。

Abstract: We consider the complexity of maximizing egalitarian welfare in Friends and Enemies Games -- a subclass of hedonic games in which every agent partitions other agents into friends and enemies. We investigate two classic scenarios proposed in the literature, namely, Friends Appreciation ($\mathsf{FA}$) and Enemies Aversion ($\mathsf{EA}$): in the former, each agent primarily cares about the number of friends in her coalition, breaking ties based on the number of enemies, while in the latter, the opposite is true. For $\mathsf{EA}$, we show that our objective is hard to approximate within $O(n^{1-ε})$, for any fixed $ε>0$, and provide a polynomial-time $(n-1)$-approximation. For $\mathsf{FA}$, we obtain an NP-hardness result and a polynomial-time approximation algorithm. Our algorithm achieves a ratio of $2-Θ(\frac{1}{n})$ when every agent has at least two friends; however, if some agent has at most one friend, its approximation ratio deteriorates to $n/2$. We recover the $2-Θ(\frac{1}{n})$ approximation ratio for two important variants: when randomization is allowed and when the friendship relationship is symmetric. Additionally, for both $\mathsf{EA}$ and $\mathsf{FA}$ we identify special cases where the optimal egalitarian partition can be computed in polynomial time.

</details>
