{"id": "2511.15819", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2511.15819", "abs": "https://arxiv.org/abs/2511.15819", "authors": ["Bohdan Liesnikov", "David Binder", "Tim Süberkrüb"], "title": "Filling the Gaps of Polarity: Implementing Dependent Data and Codata Types with Implicit Arguments", "comment": null, "summary": "The expression problem describes a fundamental tradeoff between two types of extensibility: extending a type with new operations, such as by pattern matching on an algebraic data type in functional programming, and extending a type with new constructors, such as by adding a new object implementing an interface in object-oriented programming. Most dependently typed languages have good support for the former style through inductive types, but support for the latter style through coinductive types is usually much poorer. Polarity is a language that treats both kinds of types symmetrically and allows the developer to switch between type representations.However, it currently lacks several features expected of a state-of-the-art dependently typed language, such as implicit arguments. The central aim of this paper is to provide an algorithmic type system and inference algorithm for implicit arguments that respect the core symmetry of the language. Our work provides two key contributions: a complete algorithmic description of the type system backing Polarity, and a comprehensive description of a unification algorithm that covers arbitrary inductive and coinductive types. We give rules for reduction semantics, conversion checking, and a unification algorithm for pattern-matching, which are essential for a usable implementation. A work-in-progress implementation of the algorithms in this paper is available at https://polarity-lang.github.io/. We expect that the comprehensive account of the unification algorithm and our design decisions can serve as a blueprint for other dependently typed languages that support inductive and coinductive types symmetrically."}
{"id": "2511.15820", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2511.15820", "abs": "https://arxiv.org/abs/2511.15820", "authors": ["Ashton Wiersdorf", "Ben Greenman"], "title": "Chorex: Restartable, Language-Integrated Choreographies", "comment": null, "summary": "We built Chorex, a language that brings choreographic programming to Elixir as a path toward robust distributed applications. Chorex is unique among choreographic languages because it tolerates failure among actors: when an actor crashes, Chorex spawns a new process, restores state using a checkpoint, and updates the network configuration for all actors. Chorex also proves that full-featured choreographies can be implemented via metaprogramming, and that doing so achieves tight integration with the host language. For example, mismatches between choreography requirements and an actor implementation are reported statically and in terms of source code rather than macro-expanded code. This paper illustrates Chorex on several examples, ranging from a higher-order bookseller to a secure remote password protocol, details its implementation, and measures the overhead of checkpointing. We conjecture that Chorex's projection strategy, which outputs sets of stateless functions, is a viable approach for other languages to support restartable actors."}
{"id": "2511.15821", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2511.15821", "abs": "https://arxiv.org/abs/2511.15821", "authors": ["Fumika Mochizuki", "Tetsuro Yamazaki", "Shigeru Chiba"], "title": "BlueScript: A Disaggregated Virtual Machine for Microcontrollers", "comment": null, "summary": "Virtual machines (VMs) are highly beneficial for microcontroller development. \nIn particular, interactive programming environments greatly facilitate iterative development processes, \nand higher execution speeds expand the range of applications that can be developed. \nHowever, due to their limited memory size, microcontroller VMs provide a limited set of features. \nWidely used VMs for microcontrollers often lack interactive responsiveness and/or high execution speed. \nWhile researchers have investigated offloading certain VM components to other machines,the types of components that can be offloaded are still restricted. \nIn this paper, we propose a disaggregated VM that offloads as many components as possible to a host machine. \nThis makes it possible to exploit the abundant memory of the host machine and its powerful processing capability to provide rich features through the VM. \nAs an instance of a disaggregated VM, we design and implement a BlueScript VM. \nThe BlueScript VM is a virtual machine for microcontrollers that provides an interactive development environment. \nWe offload most of the components of the BlueScript VM to a host machine. \nTo reduce communication overhead between the host machine and the microcontroller,  \nwe employed a data structure called a shadow machine on the host machine, \nwhich mirrors the execution state of the microcontroller. \nThrough our experiments, we confirmed that offloading components does not seriously compromise their expected benefits.  \nWe assess that an offloaded incremental compiler results in faster execution speed than MicroPython and Espruino,  \nwhile keeping interactivity comparable with MicroPython.  \nIn addition, our experiments observe that the offloaded dynamic compiler improves VM performance. \nThrough this investigation, we demonstrate the feasibility of providing rich features even on VMs for memory-limited microcontrollers."}
{"id": "2511.16080", "categories": ["cs.PL", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.16080", "abs": "https://arxiv.org/abs/2511.16080", "authors": ["Sungbin Moon", "Jiho Park", "Suyoung Hwang", "Donghyun Koh", "Seunghyun Moon", "Minhyeong Lee"], "title": "Operon: Incremental Construction of Ragged Data via Named Dimensions", "comment": null, "summary": "Modern data processing workflows frequently encounter ragged data: collections with variable-length elements that arise naturally in domains like natural language processing, scientific measurements, and autonomous AI agents. Existing workflow engines lack native support for tracking the shapes and dependencies inherent to ragged data, forcing users to manage complex indexing and dependency bookkeeping manually. We present Operon, a Rust-based workflow engine that addresses these challenges through a novel formalism of named dimensions with explicit dependency relations. Operon provides a domain-specific language where users declare pipelines with dimension annotations that are statically verified for correctness, while the runtime system dynamically schedules tasks as data shapes are incrementally discovered during execution. We formalize the mathematical foundation for reasoning about partial shapes and prove that Operon's incremental construction algorithm guarantees deterministic and confluent execution in parallel settings. The system's explicit modeling of partially-known states enables robust persistence and recovery mechanisms, while its per-task multi-queue architecture achieves efficient parallelism across heterogeneous task types. Empirical evaluation demonstrates that Operon outperforms an existing workflow engine with 14.94x baseline overhead reduction while maintaining near-linear end-to-end output rates as workloads scale, making it particularly suitable for large-scale data generation pipelines in machine learning applications."}
{"id": "2511.15908", "categories": ["cs.GR"], "pdf": "https://arxiv.org/pdf/2511.15908", "abs": "https://arxiv.org/abs/2511.15908", "authors": ["William Baumgartner", "Gizem Kayar-Ceylan"], "title": "SPHaptics: A Real-Time Bidirectional Haptic Interaction Framework for Coupled Rigid-Soft Body and Lagrangian Fluid Simulation in Virtual Environments", "comment": "9 pages, 9 figures", "summary": "Haptic feedback enhances immersion in virtual environments by allowing users to physically interact with simulated objects. Supporting accurate force responses in multiphysics systems is challenging because physically based simulation of fluid, rigid, and deformable materials is computationally demanding, especially when interaction must occur in real time. We present a unified framework for real-time, bidirectional haptic interaction with rigid bodies, deformable objects, and Lagrangian fluids in virtual reality (VR). Our approach integrates Smoothed Particle Hydrodynamics (SPH) with two-way force coupling and feedback smoothing to maintain stability and produce physically meaningful tactile responses. This enables users to manipulate objects immersed in fluid and feel reaction forces consistent with fluid-structure behavior. We demonstrate the capabilities of our framework through interactive VR scenarios involving fluid stirring, soft tissue manipulation, and rigid-body interaction. The proposed system advances haptic-enabled multiphysics simulation by unifying fluid, soft-body, and rigid-body dynamics into a single platform suitable for immersive educational applications."}
{"id": "2511.15727", "categories": ["cs.GT"], "pdf": "https://arxiv.org/pdf/2511.15727", "abs": "https://arxiv.org/abs/2511.15727", "authors": ["Endre Csóka"], "title": "Prior-free Collusion-proof Dynamic Mechanisms", "comment": null, "summary": "For a general class of dynamic stochastic multi-player problems, Csóka, Liu, Rodivilov, and Teytelboym (2024) proposed prior-dependent mechanisms. The Guaranteed Utility Mechanism with transfers (TU-GUM) implements efficiency in a Guaranteed Utility Equilibrium (GUE). Its transfer-free variant (NTU-GUM) implements approximate efficiency in ε-GUE. In this paper, we define prior-free versions of both TU-GUM and NTU-GUM. As a special case, we believe that the new prior-free NTU-GUM implements a 1.283-approximation to Pareto efficiency for the repeated single good allocation problem in Fikioris, Banerjee, and Tardos (2024)."}
{"id": "2511.16249", "categories": ["cs.GR"], "pdf": "https://arxiv.org/pdf/2511.16249", "abs": "https://arxiv.org/abs/2511.16249", "authors": ["Zihao Liu", "Zunnan Xu", "Shi Shu", "Jun Zhou", "Ruicheng Zhang", "Zhenchao Tang", "Xiu Li"], "title": "Controllable Layer Decomposition for Reversible Multi-Layer Image Generation", "comment": "19 pages, 14 figures", "summary": "This work presents Controllable Layer Decomposition (CLD), a method for achieving fine-grained and controllable multi-layer separation of raster images. In practical workflows, designers typically generate and edit each RGBA layer independently before compositing them into a final raster image. However, this process is irreversible: once composited, layer-level editing is no longer possible. Existing methods commonly rely on image matting and inpainting, but remain limited in controllability and segmentation precision. To address these challenges, we propose two key modules: LayerDecompose-DiT (LD-DiT), which decouples image elements into distinct layers and enables fine-grained control; and Multi-Layer Conditional Adapter (MLCA), which injects target image information into multi-layer tokens to achieve precise conditional generation. To enable a comprehensive evaluation, we build a new benchmark and introduce tailored evaluation metrics. Experimental results show that CLD consistently outperforms existing methods in both decomposition quality and controllability. Furthermore, the separated layers produced by CLD can be directly manipulated in commonly used design tools such as PowerPoint, highlighting its practical value and applicability in real-world creative workflows."}
{"id": "2511.16517", "categories": ["cs.GT"], "pdf": "https://arxiv.org/pdf/2511.16517", "abs": "https://arxiv.org/abs/2511.16517", "authors": ["Holger I. Meinhardt"], "title": "Polynomial-Time Algorithms for Computing the Nucleolus: An Assessment", "comment": "32 pages, 1 figure, 1 table", "summary": "Recently, Maggiorano et al. (2025) claimed that they have developed a strongly polynomial-time combinatorial algorithm for the nucleolus in convex games that is based on the reduced game approach and submodular function minimization method. Thereby, avoiding the ellipsoid method with its negative side effects in numerical computation completely. However, we shall argue that this is a fallacy based on an incorrect application of the Davis/Maschler reduced game property (RGP). Ignoring the fact that despite the pre-nucleolus, other solutions like the core, pre-kernel, and semi-reactive pre-bargaining set possess this property as well. This causes a severe selection issue, leading to the failure to compute the nucleolus of convex games using the reduced games approach. In order to assess this finding in its context, the ellipsoid method of Faigle et al. (2001) and the Fenchel-Moreau conjugation-based approach from convex analysis of Meinhardt (2013) to compute a pre-kernel element were resumed. In the latter case, it was exploited that for TU games with a single-valued pre-kernel, both solution concepts coincide. Implying that one has computed the pre-nucleolus if one has found the sole pre-kernel element of the game. Though it is a specialized and highly optimized algorithm for the pre-kernel, it assures runtime complexity of O(n^3) for computing the pre-nucleolus whenever the pre-kernel is a single point, which indicates a polynomial-time algorithm for this class of games."}
