<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 4]
- [cs.PL](#cs.PL) [Total: 3]
- [cs.GT](#cs.GT) [Total: 1]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [In-SRAM Radiant Foam Rendering on a Graph Processor](https://arxiv.org/abs/2601.04382)
*Zulkhuu Tuya,Ignacio Alzugaray,Nicholas Fry,Andrew J. Davison*

Main category: cs.GR

TL;DR: 本文提出了一种完全在SRAM中运行的分布式渲染器，适用于Graphcore Mk2 IPU等许多核加速器，通过分层路由覆盖实现高效的射线追踪，接近交互式速度。


<details>
  <summary>Details</summary>
Motivation: 许多新兴的多核加速器采用轻量级核心和小型本地SRAM的设计，打破了大容量统一场景表示的关键假设，需要高效的数据和计算分布方法。

Method: 通过在Graphcore Mk2 IPU上实现Radiant Foam Voronoi-cell的分布式渲染器，将场景分片并通过分层路由覆盖转发射线。

Result: 系统在Mip-NeRF~360场景中实现了接近交互式的速度（约1 fps，640×480分辨率），图像和深度质量接近GPU实现，且所有数据保持在片上SRAM中。

Conclusion: 研究表明了在分布式内存加速器上实现高效渲染的可行性，并分析了未来硬件设计中需要优化的瓶颈。

Abstract: Many emerging many-core accelerators replace a single large device memory with hundreds to thousands of lightweight cores, each owning only a small local SRAM and exchanging data via explicit on-chip communication. This organization offers high aggregate bandwidth, but it breaks a key assumption behind many volumetric rendering techniques: that rays can randomly access a large, unified scene representation. Rendering efficiently on such hardware therefore requires distributing both data and computation, keeping ray traversal mostly local, and structuring communication into predictable routes.
  We present a fully in-SRAM, distributed renderer for the \emph{Radiant Foam} Voronoi-cell volumetric representation on the Graphcore Mk2 IPU, a many-core accelerator with tile-local SRAM and explicit inter-tile communication. Our system shards the scene across tiles and forwards rays between shards through a hierarchical routing overlay, enabling ray marching entirely from on-chip SRAM with predictable communication. On Mip-NeRF~360 scenes, the system attains near-interactive throughput (\(\approx\)1\,fps at \mbox{$640\times480$}) with image and depth quality close to the original GPU-based Radiant Foam implementation, while keeping all scene data and ray state in on-chip SRAM. Beyond demonstrating feasibility, we analyze routing, memory, and scheduling bottlenecks that inform how future distributed-memory accelerators can better support irregular, data-movement-heavy rendering workloads.

</details>


### [2] [Differential Locally Injective Grid Deformation and Optimization](https://arxiv.org/abs/2601.04494)
*Julian Knodt,Seung-Hwan Baek*

Main category: cs.GR

TL;DR: 本文提出了一种无反转的网格变形方法，通过优化微分权重自适应压缩空间，首次将网格顶点作为微分元素进行优化，提高了优化的并行性。


<details>
  <summary>Details</summary>
Motivation: 传统的均匀网格无法动态分配分辨率到细节变化的区域，而现有的间接网格适应性方法（如四面体网格或局部细分网格）又难以避免网格反转问题。

Method: 该方法通过顶点着色将密集的输入线性系统分解为多个独立的顶点集，可以并行优化。同时，该方法还扩展到优化具有凸边界的UV网格。

Result: 实验表明，这种微分表示比更新外显顶点坐标具有更平滑的优化流形，并且由于每个顶点的有效区域固定，局部单射性检查变得简单。

Conclusion: 该方法在逆渲染的等值面提取、图像压缩和网格参数化等应用中展示了其通用性和高效性。

Abstract: Grids are a general representation for capturing regularly-spaced information, but since they are uniform in space, they cannot dynamically allocate resolution to regions with varying levels of detail. There has been some exploration of indirect grid adaptivity by replacing uniform grids with tetrahedral meshes or locally subdivided grids, as inversion-free deformation of grids is difficult. This work develops an inversion-free grid deformation method that optimizes differential weight to adaptively compress space. The method is the first to optimize grid vertices as differential elements using vertex-colorings, decomposing a dense input linear system into many independent sets of vertices which can be optimized concurrently. This method is then also extended to optimize UV meshes with convex boundaries. Experimentally, this differential representation leads to a smoother optimization manifold than updating extrinsic vertex coordinates. By optimizing each sets of vertices in a coloring separately, local injectivity checks are straightforward since the valid region for each vertex is fixed. This enables the use of optimizers such as Adam, as each vertex can be optimized independently of other vertices. We demonstrate the generality and efficacy of this approach through applications in isosurface extraction for inverse rendering, image compaction, and mesh parameterization.

</details>


### [3] [LooseRoPE: Content-aware Attention Manipulation for Semantic Harmonization](https://arxiv.org/abs/2601.05127)
*Etai Sella,Yoav Baron,Hadar Averbuch-Elor,Daniel Cohen-Or,Or Patashnik*

Main category: cs.GR

TL;DR: 论文提出了一种名为LooseRoPE的扩散模型编辑方法，通过在旋转位置编码（RoPE）中加入显著性引导的调制，实现对图像编辑中精确空间和视觉控制的平衡。


<details>
  <summary>Details</summary>
Motivation: 当前的基于扩散的图像编辑方法通常依赖文本或高级指令，虽然直观但控制粒度较粗。论文关注于无需提示的直接编辑，用户通过裁剪和粘贴对象来指定修改，但这种操作需要解决对象身份保留与新上下文协调的挑战。

Method: 论文观察到扩散模型中注意力图决定了图像区域的保留或适应。基于此，提出了LooseRoPE方法，通过调制RoPE来放松位置约束，从而连续控制注意力视野。

Result: LooseRoPE能够平滑地在输入图像的身份保留与插入对象的上下文协调之间实现平衡，无需文本描述或复杂用户输入即可实现无缝编辑效果。

Conclusion: 该方法提供了一个灵活直观的图像编辑框架，能够在保留对象身份的同时实现与上下文的自然融合。

Abstract: Recent diffusion-based image editing methods commonly rely on text or high-level instructions to guide the generation process, offering intuitive but coarse control. In contrast, we focus on explicit, prompt-free editing, where the user directly specifies the modification by cropping and pasting an object or sub-object into a chosen location within an image. This operation affords precise spatial and visual control, yet it introduces a fundamental challenge: preserving the identity of the pasted object while harmonizing it with its new context. We observe that attention maps in diffusion-based editing models inherently govern whether image regions are preserved or adapted for coherence. Building on this insight, we introduce LooseRoPE, a saliency-guided modulation of rotational positional encoding (RoPE) that loosens the positional constraints to continuously control the attention field of view. By relaxing RoPE in this manner, our method smoothly steers the model's focus between faithful preservation of the input image and coherent harmonization of the inserted object, enabling a balanced trade-off between identity retention and contextual blending. Our approach provides a flexible and intuitive framework for image editing, achieving seamless compositional results without textual descriptions or complex user input.

</details>


### [4] [GenAI-DrawIO-Creator: A Framework for Automated Diagram Generation](https://arxiv.org/abs/2601.05162)
*Jinze Yu,Dayuan Jiang*

Main category: cs.GR

TL;DR: GenAI-DrawIO-Creator是一个利用大型语言模型（LLMs）自动生成和操作draw.io结构化XML格式图表的框架，显著减少了创建图表的时间并提高了输出的结构保真度。


<details>
  <summary>Details</summary>
Motivation: 图表在传达复杂信息方面至关重要，但创建和修改图表仍然是一项劳动密集型任务。

Method: 该系统集成了Claude 3.7，通过专门设计的提示工程和错误检查，生成结构良好的XML输出，并支持实时图表更新。

Result: 原型能够从自然语言或代码生成准确的图表（如网络架构和流程图），甚至可以从图像复制图表，模拟评估显示该方法显著减少了图表创建时间。

Conclusion: GenAI-DrawIO-Creator证明了Claude 3.7在处理结构化视觉推理任务方面的潜力，并为未来AI辅助图表应用研究奠定了基础。

Abstract: Diagrams are crucial for communicating complex information, yet creating and modifying them remains a labor-intensive task. We present GenAI-DrawIO-Creator, a novel framework that leverages Large Language Models (LLMs) to automate diagram generation and manipulation in the structured XML format used by draw.io. Our system integrates Claude 3.7 to reason about structured visual data and produce valid diagram representations. Key contributions include a high-level system design enabling real-time diagram updates, specialized prompt engineering and error-checking to ensure well-formed XML outputs. We demonstrate a working prototype capable of generating accurate diagrams (such as network architectures and flowcharts) from natural language or code, and even replicating diagrams from images. Simulated evaluations show that our approach significantly reduces diagram creation time and produces outputs with high structural fidelity. Our results highlight the promise of Claude 3.7 in handling structured visual reasoning tasks and lay the groundwork for future research in AI-assisted diagramming applications.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [5] [Scalable Floating-Point Satisfiability via Staged Optimization](https://arxiv.org/abs/2601.04492)
*Yuanzhuo Zhang,Zhoulai Fu,Binoy Ravindran*

Main category: cs.PL

TL;DR: StageSAT是一种结合SMT求解和数值优化的新方法，通过三阶段逐步提高精度的优化策略，显著提升了浮点可满足性求解的性能和准确性。


<details>
  <summary>Details</summary>
Motivation: 现有的浮点可满足性求解方法在精度和性能之间存在权衡，StageSAT旨在通过阶段性优化策略解决这一问题。

Method: StageSAT将浮点公式重构为三阶段的优化问题，包括快速投影辅助下降、ULP$^2$优化和最终的$n$-ULP格子细化，利用黑盒计算导航输入空间。

Result: StageSAT在SMT-COMP'25等基准测试中表现优异，召回率达99.4%，零误报，且速度比传统方法快5--10倍。

Conclusion: 阶段性优化显著提升了浮点可满足性求解的性能和可靠性，StageSAT优于现有优化和传统SMT求解器。

Abstract: This work introduces StageSAT, a new approach to solving floating-point satisfiability that bridges SMT solving with numerical optimization. StageSAT reframes a floating-point formula as a series of optimization problems in three stages of increasing precision. It begins with a fast, projection-aided descent objective to guide the search toward a feasible region, proceeding to bit-level accuracy with ULP$^2$ optimization and a final $n$-ULP lattice refinement.
  By construction, the final stage uses a representing function that is zero if and only if a candidate satisfies all constraints. Thus, when optimization drives the objective to zero, the resulting assignment is a valid solution, providing a built-in guarantee of soundness.
  To improve search, StageSAT introduces a partial monotone descent property on linear constraints via orthogonal projection, preventing the optimizer from stalling on flat or misleading landscapes. Critically, this solver requires no heavy bit-level reasoning or specialized abstractions; it treats complex arithmetic as a black-box, using runtime evaluations to navigate the input space.
  We implement StageSAT and evaluate it on extensive benchmarks, including SMT-COMP'25 suites and difficult cases from prior work. StageSAT proved more scalable and accurate than state-of-the-art optimization-based alternatives. It solved strictly more formulas than any competing solver under the same time budget, finding most satisfiable instances without producing spurious models. This amounts to 99.4% recall on satisfiable cases with 0% false SAT, exceeding the reliability of prior optimization-based solvers. StageSAT also delivered significant speedups (often 5--10$\times$) over traditional bit-precise SMT and numeric solvers. These results demonstrate that staged optimization significantly improves performance and correctness of floating-point satisfiability solving.

</details>


### [6] [Lenses for Partially-Specified States (Extended Version)](https://arxiv.org/abs/2601.04573)
*Kazutaka Matsuda,Minh Nguyen,Meng Wang*

Main category: cs.PL

TL;DR: 该论文提出了部分状态镜头（partial-state lenses），用于在多视图共享源数据时处理更新冲突和合并，明确用户更新意图并提供可组合的语义。


<details>
  <summary>Details</summary>
Motivation: 多视图共享源数据时，一个视图的更新可能影响其他视图，导致难以维护对应关系并保留用户的更新意图，尤其是在多视图同时变化的情况下。

Method: 论文提出了部分状态镜头，允许部分指定源和视图状态以精确表示用户的更新意图，并通过偏序提供清晰的语义来合并多视图的更新意图。

Result: 论文形式化了部分状态镜头，提出了支持组合推理和确保更新保留的部分指定行为良好性，并通过示例展示了该系统的实用性。

Conclusion: 部分状态镜头为多视图共享源数据时的更新冲突提供了明确的解决方案，并通过形式化和示例验证了其有效性和实用性。

Abstract: A bidirectional transformation is a pair of transformations satisfying certain well-behavedness properties: one maps source data into view data, and the other translates changes on the view back to the source. However, when multiple views share a source, an update on one view may affect the others, making it hard to maintain correspondence while preserving the user's update, especially when multiple views are changed at once. Ensuring these properties within a compositional framework is even more challenging. In this paper, we propose partial-state lenses, which allow source and view states to be partially specified to precisely represent the user's update intentions. These intentions are partially ordered, providing clear semantics for merging intentions of updates coming from multiple views and a refined notion of update preservation compatible with this merging. We formalize partial-state lenses, together with partial-specifiedness-aware well-behavedness that supports compositional reasoning and ensures update preservation. In addition, we demonstrate the utility of the proposed system through examples.

</details>


### [7] [The Squirrel Parser: A Linear-Time PEG Packrat Parser Capable of Left Recursion and Optimal Error Recovery](https://arxiv.org/abs/2601.05012)
*Luke A. D. Hutchison*

Main category: cs.PL

TL;DR: 松鼠解析器是一种PEG记忆解析器，能够直接处理所有形式的左递归，并在输入长度上保持线性时间复杂度，即使在存在任意数量错误的情况下。


<details>
  <summary>Details</summary>
Motivation: 传统方法在处理递归下降解析器中的左递归时需要语法重写或复杂的算法扩展，因此需要一种更高效且直接的方法。

Method: 通过基于位置的周期检测和O(1)-per-LR-cycle的递归框架通信，以及通过迭代扩展进行的固定点搜索，提出了最小算法。同时，为错误恢复设计了四公理和十二约束条件。

Result: 提出了一种可证明最优且鲁棒的错误恢复策略，确保了性能线性和直觉行为的完整性、正确性及最优性。

Conclusion: 松鼠解析器提供了一种高效且直接处理左递归和错误恢复的方法，优于传统方法。

Abstract: We present the squirrel parser, a PEG packrat parser that directly handles all forms of left recursion with optimal error recovery, while maintaining linear time complexity in the length of the input even in the presence of an arbitrary number of errors. Traditional approaches to handling left recursion in a recursive descent parser require grammar rewriting or complex algorithmic extensions. We derive a minimal algorithm from first principles: cycle detection via per-position state tracking and $O(1)$-per-LR-cycle communication from descendant to ancestor recursion frames, and fixed-point search via iterative expansion. For error recovery, we derived a set of four axioms and twelve constraints that must be imposed upon an optimal error recovery design to ensure completeness, correctness, optimality of performance, and intuitiveness of behavior. We utilized a constraint satisfaction mechanism to search the space of all possibilities, arriving at a provably optimal and robust error recovery strategy that maintains perfect performance linearity.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [8] [Mechanism Design for Federated Learning with Non-Monotonic Network Effects](https://arxiv.org/abs/2601.04648)
*Xiang Li,Bing Luo,Jianwei Huang,Yuan Luo*

Main category: cs.GT

TL;DR: 该论文提出了一种针对联邦学习的激励机制设计，考虑了网络效应和应用特定需求，通过MoTS框架和SWAN机制显著提升了社会福利。


<details>
  <summary>Details</summary>
Motivation: 现有联邦学习机制忽略了客户参与的网络效应和不同应用的模型性能需求，导致激励和社会福利不足。论文旨在弥补这一缺陷。

Method: 论文开发了一个理论模型量化网络效应对异构客户参与的影响，并提出了MoTS框架和SWAN机制，利用模型交易和支付行为进行激励。

Result: 在硬件原型上的实验表明，SWAN机制比现有机制提升了社会福利高达352.42%，并减少了93.07%的额外激励成本。

Conclusion: 论文通过结合网络效应和应用特定需求的激励机制设计，显著提升了联邦学习的社会福利和效率。

Abstract: Mechanism design is pivotal to federated learning (FL) for maximizing social welfare by coordinating self-interested clients. Existing mechanisms, however, often overlook the network effects of client participation and the diverse model performance requirements (i.e., generalization error) across applications, leading to suboptimal incentives and social welfare, or even inapplicability in real deployments. To address this gap, we explore incentive mechanism design for FL with network effects and application-specific requirements of model performance. We develop a theoretical model to quantify the impact of network effects on heterogeneous client participation, revealing the non-monotonic nature of such effects. Based on these insights, we propose a Model Trading and Sharing (MoTS) framework, which enables clients to obtain FL models through either participation or purchase. To further address clients' strategic behaviors, we design a Social Welfare maximization with Application-aware and Network effects (SWAN) mechanism, exploiting model customer payments for incentivization. Experimental results on a hardware prototype demonstrate that our SWAN mechanism outperforms existing FL mechanisms, improving social welfare by up to $352.42\%$ and reducing extra incentive costs by $93.07\%$.

</details>
