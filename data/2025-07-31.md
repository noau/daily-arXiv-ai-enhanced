<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.GT](#cs.GT) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [A Compute-Matched Re-Evaluation of TroVE on MATH](https://arxiv.org/abs/2507.22069)
*Tobias Sesterhenn,Ian Berlot-Attwell,Janis Zenkner,Christian Bartelt*

Main category: cs.PL

TL;DR: 重新评估TroVE在MATH基准上的表现，发现其优势主要源于更高的计算预算，而非工具箱机制本身。


<details>
  <summary>Details</summary>
Motivation: 近期研究质疑TroVE在MATH基准上的性能提升是否真实，因此重新评估其表现，并分析其工具箱机制的实际作用。

Method: 通过重新实现TroVE的选择机制，并在计算预算匹配的情况下比较TroVE与PRIMITIVE的性能差异。

Result: TroVE的性能提升主要源于更高的计算预算，工具箱机制的实际贡献仅为1%，修正选择机制后TroVE的准确率提高了3%。

Conclusion: TroVE的工具箱机制在MATH基准上并未带来显著优势，其性能提升更多依赖于计算预算。

Abstract: Reusing established theorems and formulas is central to mathematical problem
solving, serving as essential building blocks for tackling increasingly complex
challenges. Recent work, TroVE, argues that code-generating Large Language
Models (LLMs) can benefit similarly on the MATH benchmark by inducing and
reusing higher-level toolboxes. By allocating computational budget across an
ensemble of three modes -- directly generating code, creating tools, and
reusing tools -- TroVE claims to outperform a PRIMITIVE baseline that only
performs direct generation. However, recent analysis (Berlot-Attwell et al.,
2024) casts doubt on these gains, noting that the tools created are often
trivial or rarely reused, suggesting that improvements may stem from
self-consistency or self-correction. In this work, we re-evaluate TroVE on
MATH, analyze the impact of each of its modes, and show that its benefit does
not come from these mechanisms, but simply from a higher computational budget
spent for TroVE compared to PRIMITIVE. To this end, we also perform a small
correction in the original implementation of TroVE's selection mechanism,
boosting TroVE's performance on MATH by 3\% in accuracy. After matching for
compute, the benefit of TroVE reduces to a marginal improvement of 1\%,
suggesting that this toolbox approach does not provide a significant benefit on
MATH.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [2] [Reducing the complexity of computing the values of a Nash equilibrium](https://arxiv.org/abs/2507.22819)
*Debtoru Chatterjee,Girish Tiwari,Niladri Chatterjee*

Main category: cs.GT

TL;DR: 本文提出了一种算法，用于计算Colonel Blotto游戏中的纳什均衡值，避免了传统方法的复杂性和可扩展性问题。该算法无需计算双方玩家的纳什策略，并能应用于所有双人零和游戏。


<details>
  <summary>Details</summary>
Motivation: 传统的Colonel Blotto游戏纳什均衡计算存在复杂性和可扩展性问题，尤其是由于其PPAD完备性。本文旨在提出一种更高效的算法来解决这些问题。

Method: 提出了一种新的算法，无需计算双方玩家的纳什策略即可得到纳什均衡值。该算法不依赖于Tarski、Kakutani和Brouwer的固定点定理，降低了复杂性。

Result: 该算法不仅适用于Colonel Blotto游戏，还能扩展到所有双人零和游戏。理论分析表明，其在效率上优于线性规划求解器和随机概率分配方法。

Conclusion: 本文的算法成功降低了计算纳什均衡的复杂性，为双人零和游戏提供了更高效的解决方案，具有广泛的应用潜力。

Abstract: The Colonel Blotto game, formulated by Emile Borel, involves players
allocating limited resources to multiple battlefields simultaneously, with the
winner being the one who allocates more resources to each battlefield.
Computation of the Nash equilibrium, including of two person, zero sum, mixed
strategy Colonel Blotto games have encountered issues of scalability and
complexity owing to their PPAD completeness. This paper proposes an algorithm
that computes the same value as the Nash equilibrium but cannot be
characterized by the Fixed point Theorems of Tarski, Kakutani and Brouwer. The
reduced complexity of the proposed algorithm is based on dispensing with the
need for computing both players Nash strategies in Colonel Blotto games. The
same algorithm can, therefore, be extended to all two person, zero sum games to
compute the value of the Nash equilibrium. The theoretical superiority of the
proposed algorithm over both LP solvers and another method that computes the
same value of the game as its Nash equilibrium by a random assignment of
probabilities to the active strategy set of the defending player, is also
proposed.

</details>
