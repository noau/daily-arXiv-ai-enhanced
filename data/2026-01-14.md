<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 1]
- [cs.PL](#cs.PL) [Total: 1]
- [cs.GT](#cs.GT) [Total: 3]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [Statistical Blendshape Calculation and Analysis for Graphics Applications](https://arxiv.org/abs/2601.08234)
*Shuxian Li,Tianyue Wang,Chris Twombly*

Main category: cs.GR

TL;DR: 本文开发了一种基于标准网络摄像头的低功耗VR应用的高精度混合形状预测系统，实现了实时性能和低计算资源依赖。


<details>
  <summary>Details</summary>
Motivation: 随着虚拟化和AI的发展，实时面部虚拟动画在娱乐、办公、商业等领域广泛应用。混合形状因其相对简单和易于解释成为行业常见解决方案。

Method: 通过仿射变换和分割提取混合形状特征向量，进一步通过变换和回归分析建立预测模型，并使用后处理技术（如平滑滤波和非线性变换）提高响应稳定性。

Result: 实验表明，系统精度与ARKit 6相当，具有低传感器/硬件要求和实时响应，提供了一致、准确且流畅的视觉体验。

Conclusion: 开发的系统在低功耗VR应用中实现了高精度和实时性的混合形状预测，适用于多种实际场景。

Abstract: With the development of virtualization and AI, real-time facial avatar animation is widely used in entertainment, office, business and other fields. Against this background, blendshapes have become a common industry animation solution because of their relative simplicity and ease of interpretation. Aiming for real-time performance and low computing resource dependence, we independently developed an accurate blendshape prediction system for low-power VR applications using a standard webcam. First, blendshape feature vectors are extracted through affine transformation and segmentation. Through further transformation and regression analysis, we were able to identify models for most blendshapes with significant predictive power. Post-processing was used to further improve response stability, including smoothing filtering and nonlinear transformations to minimize error. Experiments showed the system achieved accuracy similar to ARKit 6. Our model has low sensor/hardware requirements and realtime response with a consistent, accurate and smooth visual experience.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [2] [Formalization and Implementation of Safe Destination Passing in Pure Functional Programming Settings](https://arxiv.org/abs/2601.08529)
*Thomas Bagrel*

Main category: cs.PL

TL;DR: 论文提出了一个基于目标传递风格的核心λ-演算{λ_d}，并通过模态类型系统确保其安全性。该演算在纯函数式编程中具有新的应用潜力。


<details>
  <summary>Details</summary>
Motivation: 目标传递风格编程允许通过传递目标来控制内存管理，但在纯函数式编程中的应用尚未充分探索。论文旨在填补这一空白。

Method: 开发了一个基于目标传递的核心λ-演算{λ_d}，结合线性类型和年龄系统以确保安全性，并在Haskell中实现了原型。

Result: 原型实现表明，目标传递风格在遍历或映射大型数据结构（如列表或数据树）时具有潜力。

Conclusion: 目标传递风格编程在纯函数式语言中可行，尽管实现时需要权衡灵活性和用户复杂度。

Abstract: Destination-passing style programming introduces destinations, which represent the address of a write-once memory cell. These destinations can be passed as function parameters, allowing the caller to control memory management: the callee simply fills the cell instead of allocating space for a return value. While typically used in systems programming, destination passing also has applications in pure functional programming, where it enables programs that were previously unexpressible using usual immutable data structures.
  In this thesis, we develop a core λ-calculus with destinations, {λ_d}. Our new calculus is more expressive than similar existing systems, with destination passing designed to be as flexible as possible. This is achieved through a modal type system combining linear types with a system of ages to manage scopes, in order to make destination-passing safe. Type safety of our core calculus was proved formally with the Coq proof assistant.
  Then, we see how this core calculus can be adapted into an existing pure functional language, Haskell, whose type system is less powerful than our custom theoretical one. Retaining safety comes at the cost of removing some flexibility in the handling of destinations. We later refine the implementation to recover much of this flexibility, at the cost of increased user complexity.
  The prototype implementation in Haskell shows encouraging results for adopting destination-passing style programming when traversing or mapping over large data structures such as lists or data trees.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [3] [Robust Stable Matchings: Dealing with Changes in Preferences](https://arxiv.org/abs/2601.07959)
*Rohith Reddy Gangam,Tung Mai,Nitya Raju,Vijay V. Vazirani*

Main category: cs.GT

TL;DR: 研究稳定匹配在多实例偏好变化下的稳健性，分析不同偏好扰动模型下的结构性质和计算行为。


<details>
  <summary>Details</summary>
Motivation: 探讨匹配市场中偏好可能演变、误报或不明确的情况下，稳定匹配的稳健性需求。

Method: 使用Gale-Shapley模型，分析三种偏好变化层次下的稳健稳定匹配，包括结构性质、计算效率和几何特性。

Result: 为每种偏好变化层次提供了稳健稳定匹配的结构特征和计算边界，揭示了可处理与不可处理案例的精确分界。

Conclusion: 系统性研究了稳健稳定匹配的结构和计算性质，为偏好变化的匹配市场提供了理论支持和算法工具。

Abstract: We study stable matchings that are robust to preference changes in the two-sided stable matching setting of Gale and Shapley [GS62]. Given two instances $A$ and $B$ on the same set of agents, a matching is said to be robust if it is stable under both instances. This notion captures desirable robustness properties in matching markets where preferences may evolve, be misreported, or be subject to uncertainty. While the classical theory of stable matchings reveals rich lattice, algorithmic, and polyhedral structure for a single instance, it is unclear which of these properties persist when stability is required across multiple instances. Our work initiates a systematic study of the structural and computational behavior of robust stable matchings under increasingly general models of preference changes.
  We analyze robustness under a hierarchy of perturbation models:
  1. a single upward shift in one agent's preference list,
  2. an arbitrary permutation change by a single agent, and
  3. arbitrary preference changes by multiple agents on both sides.
  For each regime, we characterize when:
  1. the set of robust stable matchings forms a sublattice,
  2. the lattice of robust stable matchings admits a succinct Birkhoff partial order enabling efficient enumeration,
  3. worker-optimal and firm-optimal robust stable matchings can be computed efficiently, and
  4. the robust stable matching polytope is integral (by studying its LP formulation).
  We provide explicit counterexamples demonstrating where these structural and geometric properties break down, and complement these results with XP-time algorithms running in $O(n^k)$ time, parameterized by $k$, the number of agents whose preferences change. Our results precisely delineate the boundary between tractable and intractable cases for robust stable matchings.

</details>


### [4] [How Hard Is It to Rig a Tournament When Few Players Can Beat or Be Beaten by the Favorite?](https://arxiv.org/abs/2601.08530)
*Zhonghao Wang,Junqiang Peng,Yuxi Liu,Mingyu Xiao*

Main category: cs.GT

TL;DR: 该论文研究了淘汰赛中如何通过调整赛程确保特定选手获胜的问题，展示了在选手的入度或出度较小的情况下，问题可以通过固定参数算法高效解决。


<details>
  <summary>Details</summary>
Motivation: 研究淘汰赛中的赛程安排问题，特别是如何通过参数化方法高效解决特定选手获胜的问题，以扩展对\textsc{Tournament Fixing}问题的理解。

Method: 引入了两个新的结构参数（选手的入度和出度），并证明了在这些参数较小的情况下，问题可以通过固定参数算法（FPT）高效解决。

Result: 论文展示了在选手的入度或出度较小时，\textsc{Tournament Fixing}问题是固定参数可解的，且在入度参数化的情况下算法尤为复杂。

Conclusion: 研究结果为淘汰赛赛程安排问题提供了新的视角，显著拓宽了对\textsc{Tournament Fixing}问题的参数化算法理解。

Abstract: In knockout tournaments, players compete in successive rounds, with losers eliminated and winners advancing until a single champion remains. Given a tournament digraph $D$, which encodes the outcomes of all possible matches, and a designated player $v^* \in V(D)$, the \textsc{Tournament Fixing} problem (TFP) asks whether the tournament can be scheduled in a way that guarantees $v^*$ emerges as the winner. TFP is known to be NP-hard, but is fixed-parameter tractable (FPT) when parameterized by structural measures such as the feedback arc set (fas) or feedback vertex set (fvs) number of the tournament digraph. In this paper, we introduce and study two new structural parameters: the number of players who can defeat $v^*$ (i.e., the in-degree of $v^*$, denoted by $k$) and the number of players that $v^*$ can defeat (i.e., the out-degree of $v^*$, denoted by $\ell$).
  A natural question is that: can TFP be efficiently solved when $k$ or $\ell$ is small? We answer this question affirmatively by showing that TFP is FPT when parameterized by either the in-degree or out-degree of $v^*$. Our algorithm for the in-degree parameterization is particularly involved and technically intricate. Notably, the in-degree $k$ can remain small even when other structural parameters, such as fas or fvs, are large. Hence, our results offer a new perspective and significantly broaden the parameterized algorithmic understanding of the \textsc{Tournament Fixing} problem.

</details>


### [5] [Cities at Play: Improving Equilibria in Urban Neighbourhood Games](https://arxiv.org/abs/2601.08642)
*Martin Gairing,Adrian Vetta,Zhanzhan Zhao*

Main category: cs.GT

TL;DR: 本研究探讨城市如何通过战略投资改善社会福利，提出一种基于博弈论的模型，揭示小规模干预如何有效协调个体与社会目标。


<details>
  <summary>Details</summary>
Motivation: 城市投资如何在个体战略行为影响下改善社会福利是一个复杂问题，传统方法可能导致类似Braess悖论的不良结果。

Method: 采用博弈论版本的Schelling有限邻域模型，个体基于局部人口的凹非单调效用函数选择邻域。

Result: 研究发现，以不超过0.81ε²·opt的成本调整效用，可保证每个纳什均衡的社会福利至少达到ε·opt。

Conclusion: 目标明确的干预能将负面结果转化为超正面回报，为战略城市规划和分散集体行为提供新见解。

Abstract: How should cities invest to improve social welfare when individuals respond strategically to local conditions? We model this question using a game-theoretic version of Schelling's bounded neighbourhood model, where agents choose neighbourhoods based on concave, non-monotonic utility functions reflecting local population. While naive improvements may worsen outcomes - analogous to Braess' paradox - we show that carefully designed, small-scale investments can reliably align individual incentives with societal goals. Specifically, modifying utilities at a total cost of at most $0.81 ε^2 \cdot \texttt{opt}$ guarantees that every resulting Nash equilibrium achieves a social welfare of at least $ε\cdot \texttt{opt}$, where $\texttt{opt}$ is the optimum social welfare. Our results formalise how targeted interventions can transform supra-negative outcomes into supra-positive returns, offering new insights into strategic urban planning and decentralised collective behaviour.

</details>
