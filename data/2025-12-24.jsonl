{"id": "2512.20261", "categories": ["cs.GT"], "pdf": "https://arxiv.org/pdf/2512.20261", "abs": "https://arxiv.org/abs/2512.20261", "authors": ["Edith Elkind", "Michele Flammini", "Giovanna Varricchio"], "title": "Maximizing the Egalitarian Welfare in Friends and Enemies Games", "comment": "Accepted paper at AAMAS'26", "summary": "We consider the complexity of maximizing egalitarian welfare in Friends and Enemies Games -- a subclass of hedonic games in which every agent partitions other agents into friends and enemies. We investigate two classic scenarios proposed in the literature, namely, Friends Appreciation ($\\mathsf{FA}$) and Enemies Aversion ($\\mathsf{EA}$): in the former, each agent primarily cares about the number of friends in her coalition, breaking ties based on the number of enemies, while in the latter, the opposite is true. For $\\mathsf{EA}$, we show that our objective is hard to approximate within $O(n^{1-ε})$, for any fixed $ε>0$, and provide a polynomial-time $(n-1)$-approximation. For $\\mathsf{FA}$, we obtain an NP-hardness result and a polynomial-time approximation algorithm. Our algorithm achieves a ratio of $2-Θ(\\frac{1}{n})$ when every agent has at least two friends; however, if some agent has at most one friend, its approximation ratio deteriorates to $n/2$. We recover the $2-Θ(\\frac{1}{n})$ approximation ratio for two important variants: when randomization is allowed and when the friendship relationship is symmetric. Additionally, for both $\\mathsf{EA}$ and $\\mathsf{FA}$ we identify special cases where the optimal egalitarian partition can be computed in polynomial time."}
{"id": "2512.20214", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2512.20214", "abs": "https://arxiv.org/abs/2512.20214", "authors": ["Philipp Schröer", "Darion Haase", "Joost-Pieter Katoen"], "title": "Error Localization, Certificates, and Hints for Probabilistic Program Verification via Slicing (Extended Version)", "comment": null, "summary": "This paper focuses on effective user diagnostics generated during the deductive verification of probabilistic programs. Our key principle is based on providing slices for (1) error reporting, (2) proof simplification, and (3) preserving successful verification results. By formally defining these different notions on HeyVL, an existing quantitative intermediate verification language (IVL), our concepts (and implementation) can be used to obtain diagnostics for a range of probabilistic programming languages. Slicing for error reporting is a novel notion of error localization for quantitative assertions. We demonstrate slicing-based diagnostics on a variety of proof rules such as quantitative versions of the specification statement and invariant-based loop rules, and formally prove the correctness of specialized error messages and verification hints.\n  We implemented our user diagnostics into the deductive verifier Caesar. Our novel implementation -- called \\emph{Brutus} -- can search for slices which do or do not verify, corresponding to each of the three diagnostic notions. For error reporting (1), it exploits a binary search-based algorithm that minimizes error-witnessing slices. To solve for slices that verify (2 and 3), we empirically compare different algorithms based on unsatisfiable cores, minimal unsatisfiable subset enumeration, and a direct SMT encoding of the slicing problem. Our empirical evaluation of Brutus on existing and new benchmarks shows that we can find slices that are both small and informative."}
{"id": "2512.20386", "categories": ["cs.GR"], "pdf": "https://arxiv.org/pdf/2512.20386", "abs": "https://arxiv.org/abs/2512.20386", "authors": ["Dong Xiao", "Renjie Chen", "Bailin Deng"], "title": "Anisotropic Green Coordinates", "comment": null, "summary": "We live in a world filled with anisotropy, a ubiquitous characteristic of both natural and engineered systems. In this study, we concentrate on space deformation and introduce anisotropic Green coordinates, which provide versatile effects for cage-based and variational deformations in both two and three dimensions. The anisotropic Green coordinates are derived from the anisotropic Laplacian equation $\\nabla\\cdot(\\mathbf{A}\\nabla u)=0$, where $\\mathbf{A}$ is a symmetric positive definite matrix. This equation belongs to the class of constant-coefficient second-order elliptic equations, exhibiting properties analogous to the Laplacian equation but incorporating the matrix $\\mathbf{A}$ to characterize anisotropic behavior. Based on this equation, we establish the boundary integral formulation, which is subsequently discretized to derive anisotropic Green coordinates defined on the vertices and normals of oriented simplicial cages. The deformation satisfies basic properties such as linear reproduction and translation invariance, and has closed-form expressions for both 2D and 3D scenarios. We also offer intuitive geometric interpretations of this method. Furthermore, our approach computes the gradient and Hessian of the deformation coordinates and employs the local-global optimization framework to facilitate variational shape deformation, enabling flexible shape manipulation while achieving as-rigid-as-possible shape deformation. Experimental results demonstrate that anisotropic Green coordinates offer versatile and diverse deformation options, providing artists with enhanced flexibility and introducing a novel perspective on spatial deformation."}
{"id": "2512.20550", "categories": ["cs.GR"], "pdf": "https://arxiv.org/pdf/2512.20550", "abs": "https://arxiv.org/abs/2512.20550", "authors": ["Vinayak Regmi", "Christos Mousas"], "title": "LLM-Based Authoring of Agent-Based Narratives through Scene Descriptions", "comment": null, "summary": "This paper presents a system for procedurally generating agent-based narratives using large language models (LLMs). Users could drag and drop multiple agents and objects into a scene, with each entity automatically assigned semantic metadata describing its identity, role, and potential interactions. The scene structure is then serialized into a natural language prompt and sent to an LLM, which returns a structured string describing a sequence of actions and interactions among agents and objects. The returned string encodes who performed which actions, when, and how. A custom parser interprets this string and triggers coordinated agent behaviors, animations, and interaction modules. The system supports agent-based scenes, dynamic object manipulation, and diverse interaction types. Designed for ease of use and rapid iteration, the system enables the generation of virtual agent activity suitable for prototyping agent narratives. The performance of the developed system was evaluated using four popular lightweight LLMs. Each model's process and response time were measured under multiple complexity scenarios. The collected data were analyzed to compare consistency across the examined scenarios and to highlight the relative efficiency and suitability of each model for procedural agent-based narratives generation. The results demonstrate that LLMs can reliably translate high-level scene descriptions into executable agent-based behaviors."}
