{"id": "2508.14194", "categories": ["cs.GT"], "pdf": "https://arxiv.org/pdf/2508.14194", "abs": "https://arxiv.org/abs/2508.14194", "authors": ["Jing Leng", "Sanjukta Roy"], "title": "Algorithms for Stable Roommate with Externalities", "comment": "Accepted to ECAI 2025", "summary": "In the roommate matching model, given a set of 2n agents and n rooms, we find\nan assignment of a pair of agents to a room. Although the roommate matching\nproblem is well studied, the study of the model when agents have preference\nover both rooms and roommates was recently initiated by Chan et al. [11]. We\nstudy two types of stable roommate assignments, namely, 4-person stable (4PS)\nand 2-person stable (2PS) in conjunction with efficiency and\nstrategy-proofness. We design a simple serial dictatorship based algorithm for\nfinding a 4PS assignment that is Pareto optimal and strategy-proof. However,\nthe serial dictatorship algorithm is far from being 2PS. Next, we study top\ntrading cycle (TTC) based algorithms. We show that variations of TTC cannot be\nstrategy-proof or PO. Finally, as Chan et al. (2016) showed that deciding the\nexistence of 2PS assignment is NP-complete, we identify preference structures\nwhere a 2PS assignment can be found in polynomial time."}
{"id": "2508.14196", "categories": ["cs.GT", "cs.DS", "econ.TH"], "pdf": "https://arxiv.org/pdf/2508.14196", "abs": "https://arxiv.org/abs/2508.14196", "authors": ["Yiling Chen", "Tao Lin", "Wei Tang", "Jamie Tucker-Foltz"], "title": "Explainable Information Design", "comment": "32 pages, 5 figures", "summary": "The optimal signaling schemes in information design (Bayesian persuasion)\nproblems often involve non-explainable randomization or disconnected partitions\nof state space, which are too intricate to be audited or communicated. We\npropose explainable information design in the context of information design\nwith a continuous state space, restricting the information designer to use\n$K$-partitional signaling schemes defined by deterministic and monotone\npartitions of the state space, where a unique signal is sent for all states in\neach part. We first prove that the price of explainability (PoE) -- the ratio\nbetween the performances of the optimal explainable signaling scheme and\nunrestricted signaling scheme -- is exactly $1/2$ in the worst case, meaning\nthat partitional signaling schemes are never worse than arbitrary signaling\nschemes by a factor of 2.\n  We then study the complexity of computing optimal explainable signaling\nschemes. We show that the exact optimization problem is NP-hard in general. But\nfor Lipschitz utility functions, an $\\varepsilon$-approximately optimal\nexplainable signaling scheme can be computed in polynomial time. And for\npiecewise constant utility functions, we provide an efficient algorithm to find\nan explainable signaling scheme that provides a $1/2$ approximation to the\noptimal unrestricted signaling scheme, which matches the worst-case PoE bound.\n  A technical tool we develop is a conversion from any optimal signaling scheme\n(which satisfies a bi-pooling property) to a partitional signaling scheme that\nachieves $1/2$ fraction of the expected utility of the former. We use this tool\nin the proofs of both our PoE result and algorithmic result."}
{"id": "2508.14439", "categories": ["cs.GT", "cs.DS", "91B12 (Primary) 91B14 (Secondary)", "F.2.2; G.2.1; G.2.3; J.4"], "pdf": "https://arxiv.org/pdf/2508.14439", "abs": "https://arxiv.org/abs/2508.14439", "authors": ["Paula BÃ¶hm", "Robert Bredereck", "Till Fluschnik"], "title": "Properties of Egalitarian Sequences of Committees: Theory and Experiments", "comment": "A short version was published in the proceedings of ECAI '25", "summary": "We study the task of electing egalitarian sequences of $\\tau$ committees\ngiven a set of agents with additive utilities for candidates available on each\nof $\\tau$ levels. We introduce several rules for electing an egalitarian\ncommittee sequence as well as properties for such rules. We settle the\ncomputational complexity of finding a winning sequence for our rules and\nclassify them against our properties. Additionally, we transform sequential\nelection data from existing election data from the literature. Using this data\nset, we compare our rules empirically and test them experimentally against our\nproperties."}
{"id": "2508.14705", "categories": ["cs.GT", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.14705", "abs": "https://arxiv.org/abs/2508.14705", "authors": ["Phurinut Srisawad", "Juergen Branke", "Long Tran-Thanh"], "title": "Learning in Repeated Multi-Objective Stackelberg Games with Payoff Manipulation", "comment": "Extended version of the paper accepted at the 28th European\n  Conference on Artificial Intelligence (ECAI 2025); Paper ID: M2635", "summary": "We study payoff manipulation in repeated multi-objective Stackelberg games,\nwhere a leader may strategically influence a follower's deterministic best\nresponse, e.g., by offering a share of their own payoff. We assume that the\nfollower's utility function, representing preferences over multiple objectives,\nis unknown but linear, and its weight parameter must be inferred through\ninteraction. This introduces a sequential decision-making challenge for the\nleader, who must balance preference elicitation with immediate utility\nmaximisation. We formalise this problem and propose manipulation policies based\non expected utility (EU) and long-term expected utility (longEU), which guide\nthe leader in selecting actions and offering incentives that trade off\nshort-term gains with long-term impact. We prove that under infinite repeated\ninteractions, longEU converges to the optimal manipulation. Empirical results\nacross benchmark environments demonstrate that our approach improves cumulative\nleader utility while promoting mutually beneficial outcomes, all without\nrequiring explicit negotiation or prior knowledge of the follower's utility\nfunction."}
{"id": "2508.14394", "categories": ["cs.PL", "cs.SE", "D.3; D.2.5; G.3"], "pdf": "https://arxiv.org/pdf/2508.14394", "abs": "https://arxiv.org/abs/2508.14394", "authors": ["Ryan Tjoa", "Poorva Garg", "Harrison Goldstein", "Todd Millstein", "Benjamin Pierce", "Guy Van den Broeck"], "title": "Tuning Random Generators: Property-Based Testing as Probabilistic Programming", "comment": "Extended version of OOPSLA '25 paper", "summary": "Property-based testing validates software against an executable specification\nby evaluating it on randomly generated inputs. The standard way that PBT users\ngenerate test inputs is via generators that describe how to sample test inputs\nthrough random choices. To achieve a good distribution over test inputs, users\nmust tune their generators, i.e., decide on the weights of these individual\nrandom choices. Unfortunately, it is very difficult to understand how to choose\nindividual generator weights in order to achieve a desired distribution, so\ntoday this process is tedious and limits the distributions that can be\npractically achieved.\n  In this paper, we develop techniques for the automatic and offline tuning of\ngenerators. Given a generator with undetermined symbolic weights and an\nobjective function, our approach automatically learns values for these weights\nthat optimize for the objective. We describe useful objective functions that\nallow users to (1) target desired distributions and (2) improve the diversity\nand validity of their test cases. We have implemented our approach in a novel\ndiscrete probabilistic programming system, Loaded Dice, that supports\ndifferentiation and parameter learning, and use it as a language for\ngenerators. We empirically demonstrate that our approach is effective at\noptimizing generator distributions according to the specified objective\nfunctions. We also perform a thorough evaluation on PBT benchmarks,\ndemonstrating that, when automatically tuned for diversity and validity, the\ngenerators exhibit a 3.1-7.4x speedup in bug finding."}
{"id": "2508.14411", "categories": ["cs.GR", "cs.CV"], "pdf": "https://arxiv.org/pdf/2508.14411", "abs": "https://arxiv.org/abs/2508.14411", "authors": ["Seokjun Choi", "Hoon-Gyu Chung", "Yujin Jeon", "Giljoo Nam", "Seung-Hwan Baek"], "title": "A Real-world Display Inverse Rendering Dataset", "comment": null, "summary": "Inverse rendering aims to reconstruct geometry and reflectance from captured\nimages. Display-camera imaging systems offer unique advantages for this task:\neach pixel can easily function as a programmable point light source, and the\npolarized light emitted by LCD displays facilitates diffuse-specular\nseparation. Despite these benefits, there is currently no public real-world\ndataset captured using display-camera systems, unlike other setups such as\nlight stages. This absence hinders the development and evaluation of\ndisplay-based inverse rendering methods. In this paper, we introduce the first\nreal-world dataset for display-based inverse rendering. To achieve this, we\nconstruct and calibrate an imaging system comprising an LCD display and stereo\npolarization cameras. We then capture a diverse set of objects with diverse\ngeometry and reflectance under one-light-at-a-time (OLAT) display patterns. We\nalso provide high-quality ground-truth geometry. Our dataset enables the\nsynthesis of captured images under arbitrary display patterns and different\nnoise levels. Using this dataset, we evaluate the performance of existing\nphotometric stereo and inverse rendering methods, and provide a simple, yet\neffective baseline for display inverse rendering, outperforming\nstate-of-the-art inverse rendering methods. Code and dataset are available on\nour project page at https://michaelcsj.github.io/DIR/"}
{"id": "2508.14614", "categories": ["cs.PL", "D.3.0; D.3.1"], "pdf": "https://arxiv.org/pdf/2508.14614", "abs": "https://arxiv.org/abs/2508.14614", "authors": ["Ashish Mishra", "Suresh Jagannathan"], "title": "Close is Good Enough: Component-Based Synthesis Modulo Logical Similarity", "comment": null, "summary": "Component-based synthesis (CBS) aims to generate loop-free programs from a\nset of libraries whose methods are annotated with specifications and whose\noutput must satisfy a set of logical constraints, expressed as a query. The\neffectiveness of a CBS algorithm critically depends on the severity of the\nconstraints imposed by the query. The more exact these constraints are, the\nsparser the space of feasible solutions. This maxim also applies when we enrich\nthe expressiveness of the specifications affixed to library methods. In both\ncases, the search must now contend with constraints that may only hold over a\nsmall number of the possible execution paths that can be enumerated by a CBS\nprocedure.\n  In this paper, we address this challenge by equipping CBS search with the\nability to reason about logical similarities among the paths it explores. Our\nsetting considers library methods equipped with refinement-type specifications\nthat enrich ordinary base types with a set of rich logical qualifiers to\nconstrain the set of values accepted by that type. We perform a search over a\ntree automata variant called Qualified Tree Automata that intelligently records\ninformation about enumerated terms, leveraging subtyping constraints over the\nrefinement types associated with these terms to enable reasoning about\nsimilarity among candidate solutions as search proceeds, thereby avoiding\nexploration of semantically similar paths.\n  We present an implementation of this idea in a tool called \\name, and provide\na comprehensive evaluation that demonstrates \\name's ability to synthesize\nsolutions to complex CBS queries that go well-beyond the capabilities of the\nexisting state-of-the-art."}
{"id": "2508.14879", "categories": ["cs.GR", "cs.CV"], "pdf": "https://arxiv.org/pdf/2508.14879", "abs": "https://arxiv.org/abs/2508.14879", "authors": ["Bingquan Dai", "Li Ray Luo", "Qihong Tang", "Jie Wang", "Xinyu Lian", "Hao Xu", "Minghan Qin", "Xudong Xu", "Bo Dai", "Haoqian Wang", "Zhaoyang Lyu", "Jiangmiao Pang"], "title": "MeshCoder: LLM-Powered Structured Mesh Code Generation from Point Clouds", "comment": null, "summary": "Reconstructing 3D objects into editable programs is pivotal for applications\nlike reverse engineering and shape editing. However, existing methods often\nrely on limited domain-specific languages (DSLs) and small-scale datasets,\nrestricting their ability to model complex geometries and structures. To\naddress these challenges, we introduce MeshCoder, a novel framework that\nreconstructs complex 3D objects from point clouds into editable Blender Python\nscripts. We develop a comprehensive set of expressive Blender Python APIs\ncapable of synthesizing intricate geometries. Leveraging these APIs, we\nconstruct a large-scale paired object-code dataset, where the code for each\nobject is decomposed into distinct semantic parts. Subsequently, we train a\nmultimodal large language model (LLM) that translates 3D point cloud into\nexecutable Blender Python scripts. Our approach not only achieves superior\nperformance in shape-to-code reconstruction tasks but also facilitates\nintuitive geometric and topological editing through convenient code\nmodifications. Furthermore, our code-based representation enhances the\nreasoning capabilities of LLMs in 3D shape understanding tasks. Together, these\ncontributions establish MeshCoder as a powerful and flexible solution for\nprogrammatic 3D shape reconstruction and understanding."}
{"id": "2508.14892", "categories": ["cs.GR", "cs.CV"], "pdf": "https://arxiv.org/pdf/2508.14892", "abs": "https://arxiv.org/abs/2508.14892", "authors": ["Jia Lu", "Taoran Yi", "Jiemin Fang", "Chen Yang", "Chuiyun Wu", "Wei Shen", "Wenyu Liu", "Qi Tian", "Xinggang Wang"], "title": "Snap-Snap: Taking Two Images to Reconstruct 3D Human Gaussians in Milliseconds", "comment": "Project page: https://hustvl.github.io/Snap-Snap/", "summary": "Reconstructing 3D human bodies from sparse views has been an appealing topic,\nwhich is crucial to broader the related applications. In this paper, we propose\na quite challenging but valuable task to reconstruct the human body from only\ntwo images, i.e., the front and back view, which can largely lower the barrier\nfor users to create their own 3D digital humans. The main challenges lie in the\ndifficulty of building 3D consistency and recovering missing information from\nthe highly sparse input. We redesign a geometry reconstruction model based on\nfoundation reconstruction models to predict consistent point clouds even input\nimages have scarce overlaps with extensive human data training. Furthermore, an\nenhancement algorithm is applied to supplement the missing color information,\nand then the complete human point clouds with colors can be obtained, which are\ndirectly transformed into 3D Gaussians for better rendering quality.\nExperiments show that our method can reconstruct the entire human in 190 ms on\na single NVIDIA RTX 4090, with two images at a resolution of 1024x1024,\ndemonstrating state-of-the-art performance on the THuman2.0 and cross-domain\ndatasets. Additionally, our method can complete human reconstruction even with\nimages captured by low-cost mobile devices, reducing the requirements for data\ncollection. Demos and code are available at\nhttps://hustvl.github.io/Snap-Snap/."}
