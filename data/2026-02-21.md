<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 2]
- [cs.PL](#cs.PL) [Total: 3]
- [cs.GT](#cs.GT) [Total: 5]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [Fuse3D: Generating 3D Assets Controlled by Multi-Image Fusion](https://arxiv.org/abs/2602.17040)
*Xuancheng Jin,Rengan Xie,Wenting Zheng,Rui Wang,Hujun Bao,Yuchi Huo*

Main category: cs.GR

TL;DR: Fuse3D是一种新的3D生成方法，能够通过多张条件图像独立控制3D资产的不同区域，实现从全局到局部细节的无缝融合。


<details>
  <summary>Details</summary>
Motivation: 现有的3D生成方法仅能处理单一控制目标，无法利用多张图像独立控制3D资产的不同区域，限制了其应用灵活性。

Method: Fuse3D提出了多条件融合模块、基于语义线索的2D/3D区域自动对齐方法，以及局部注意力增强策略，以解决控制冲突并增强局部特征。

Result: 实验表明，Fuse3D能够灵活融合多个2D图像区域，生成高质量的3D资产。

Conclusion: Fuse3D是首个能够从多张条件图像可控生成3D资产的方法，展现了灵活性和高质量生成能力。

Abstract: Recently, generating 3D assets with the control of condition images has achieved impressive quality. However, existing 3D generation methods are limited to handling a single control objective and lack the ability to utilize multiple images to independently control different regions of a 3D asset, which hinders their flexibility in applications. We propose Fuse3D, a novel method that enables generating 3D assets under the control of multiple images, allowing for the seamless fusion of multi-level regional controls from global views to intricate local details. First, we introduce a Multi-Condition Fusion Module to integrate the visual features from multiple image regions. Then, we propose a method to automatically align user-selected 2D image regions with their associated 3D regions based on semantic cues. Finally, to resolve control conflicts and enhance local control features from multi-condition images, we introduce a Local Attention Enhancement Strategy that flexibly balances region-specific feature fusion. Overall, we introduce the first method capable of controllable 3D asset generation from multiple condition images. The experimental results indicate that Fuse3D can flexibly fuse multiple 2D image regions into coherent 3D structures, resulting in high-quality 3D assets. Code and data for this paper are at https://jinnmnm.github.io/Fuse3d.github.io/.

</details>


### [2] [InstantRetouch: Personalized Image Retouching without Test-time Fine-tuning Using an Asymmetric Auto-Encoder](https://arxiv.org/abs/2602.17044)
*Temesgen Muruts Weldengus,Binnan Liu,Fei Kou,Youwei Lyu,Jinwei Chen,Qingnan Fan,Changqing Zou*

Main category: cs.GR

TL;DR: InstantRetouch是一种无需微调即可个性化图像修饰的通用框架，通过非对称自编码器和检索增强修饰实现内容感知的风格迁移。


<details>
  <summary>Details</summary>
Motivation: 现有个性化图像修饰方法通常需要用户特定的微调或泛化能力不足，因此提出InstantRetouch以解决这些问题。

Method: 使用非对称自编码器将修饰风格编码为内容解耦的潜在表示，并结合检索增强修饰（RAR）自适应地应用风格。

Result: InstantRetouch在单参考、多参考和混合风格设置中实现了卓越的内容感知个性化修饰，并可泛化到照片级真实风格迁移。

Conclusion: InstantRetouch框架无需微调即可高效地适应个性化修饰风格，适用于多样化场景并展现出强大的通用性。

Abstract: Personalized image retouching aims to adapt retouching style of individual users from reference examples, but existing methods often require user-specific fine-tuning or fail to generalize effectively. To address these challenges, we introduce $\textbf{InstantRetouch}$, a general framework for personalized image retouching that instantly adapts to user retouching styles without any test-time fine-tuning. It employs an $\textit{asymmetric auto-encoder}$ to encode the retouching style from paired examples into a content disentangled latent representation that enables faithful transfer of the retouching style to new images. To adaptively apply the encoded retouching style to new images, we further propose $\textit{retrieval-augmented retouching}$ (RAR), which retrieves and aggregates style latents from reference pairs most similar in content to the query image. With these components, $\textbf{InstantRetouch}$ enables superior and generic content-aware retouching personalization across diverse scenarios, including single-reference, multi-reference, and mixed-style setups, while also generalizing out of the box to photorealistic style transfer.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [3] [Haskell meets Evariste](https://arxiv.org/abs/2602.16809)
*Paulo R. Pereira,Jose N. Oliveira*

Main category: cs.PL

TL;DR: 本文探讨了如何通过一种称为“easy-hard-split”的策略来提高软件库文档的清晰度和设计质量。


<details>
  <summary>Details</summary>
Motivation: 计算机编程作为一门基础技能在多学科中至关重要，但编程本身容易出错，且代码重用对提高生产力非常关键。然而，软件库的文档质量往往不尽如人意，这促使了本文的研究。

Method: 本文选择了Hackage仓库中的一些Haskell函数作为案例研究，并将它们的描述与其他语言中的类似函数进行比较。通过使用一种称为“easy-hard-split”的策略，探讨了如何在功能编程中提升文档的清晰度和设计质量。

Result: 研究表明，“easy-hard-split”策略能够显著提升软件库文档的清晰度和设计质量，并且这种策略可以广泛应用于功能编程中的程序分析和合成。

Conclusion: 本文提出并验证了“easy-hard-split”策略在提升软件库文档质量方面的有效性，展示了其在功能编程中的通用性和实用性。

Abstract: Since its birth as a new scientific body of knowledge in the late 1950s, computer programming has become a fundamental skill needed in many other disciplines. However, programming is not easy, it is prone to errors and code re-use is key for productivity. This calls for high-quality documentation in software libraries, which is quite often not the case. Taking a few Haskell functions available from the Hackage repository as case-studies, and comparing their descriptions with similar functions in other languages, this paper shows how clarity and good conceptual design can be achieved by following a so-called easy-hard-split formal strategy that is quite general and productive, even if used informally. This strategy is easy to use in functional programming and can be applied to both program analysis and synthesis.

</details>


### [4] [A Reversible Semantics for Janus](https://arxiv.org/abs/2602.16913)
*Ivan Lanese,Germán Vidal*

Main category: cs.PL

TL;DR: Janus是一种典型的可逆编程语言，但其小步语义在执行过程中会丢失信息，因而不是可逆的。本文提出了一种新的小步语义，解决了这一问题，同时保持了与原语义的等价性。


<details>
  <summary>Details</summary>
Motivation: Janus语言的可逆性是其核心特性，但其小步语义在执行过程中丢失信息，无法满足可逆性的关键特性（如Loop Lemma），这限制了其在小步语义环境中的应用。

Method: 作者提出了一种新的小步语义设计，基于‘程序计数器’的概念，解决了高抽象级别编程语言中小步语义的可逆性问题。

Result: 新设计的小步语义不仅满足了可逆性的关键特性（如Loop Lemma），同时还保持了与原语义的等价性。

Conclusion: 本文成功地解决了Janus语言小步语义的可逆性问题，为在小步语义环境中实现高抽象级别的可逆编程语言提供了可行的方案。

Abstract: Janus is a paradigmatic example of reversible programming language. Indeed, Janus programs can be executed backwards as well as forwards. However, its small-step semantics (useful, e.g., for debugging or as a basis for extensions with concurrency primitives) is not reversible, since it loses information while computing forwards. E.g., it does not satisfy the Loop Lemma, stating that any reduction has an inverse, a main property of reversibility in process calculi, where small-step semantics is commonly used. We present here a novel small-step semantics which is actually reversible, while remaining equivalent to the previous one. It involves the non-trivial challenge of defining a semantics based on a "program counter" for a high-level programming language.

</details>


### [5] [Mason: Type- and Name-Guided Program Synthesis](https://arxiv.org/abs/2602.16981)
*Jasper Geer,Fox Huston,Jeffrey S. Foster*

Main category: cs.PL

TL;DR: 论文介绍了Mason工具，用于从部分代码片段合成面向对象程序，并自动插入设计模式。核心是一种新颖的类型和名称引导合成技术，通过枚举求解器生成类型约束，并结合局部回溯和非局部回溯启发式方法优化合成效果。


<details>
  <summary>Details</summary>
Motivation: 面向对象程序中设计模式的实现通常需要大量重复的样板代码，这不仅繁琐还分散了程序员对核心逻辑的注意力。因此，需要一种工具来自动化这一过程，提高开发效率。

Method: Mason采用类型和名称引导的合成技术，通过枚举求解器遍历部分程序生成类型约束，并利用程序转换解决约束问题。还引入了非局部回溯启发式方法和模式语言来优化合成过程。

Result: Mason在测试套件中表现良好，尤其是在满足约束条件较少的候选程序情况下。其扩展功能显著提升了在复杂情况下的性能。

Conclusion: Mason在利用设计模式合成多类面向对象程序方面迈出了重要一步，为自动化编程工具的发展提供了新的可能性。

Abstract: Object-oriented programs tend to be written using many common coding idioms, such as those captured by design patterns. While design patterns are useful, implementing them is often tedious and repetitive, requiring boilerplate code that distracts the programmer from more essential details. In this paper, we introduce Mason, a tool that synthesizes object-oriented programs from partial program pieces, and we apply it to automatically insert design patterns into programs. At the core of Mason is a novel technique we call type- and name-guided synthesis, in which an enumerative solver traverses a partial program to generate typing constraints; discharges constraints via program transformations guided by the names of constrained types and members; and backtracks when a constraint is violated or a candidate program fails unit tests. We also introduce two extensions to Mason: a non-local backtracking heuristic that uses execution traces, and a language of patterns that impose syntactic restrictions on missing names. We evaluate Mason on a suite of benchmarks to which Mason must add various well-known design patterns implemented as a library of program pieces. We find that Mason performs well when very few candidate programs satisfy its typing constraints and that our extensions can improve Mason's performance significantly when this is not the case. We believe that Mason takes an important step forward in synthesizing multi-class object-oriented programs using design patterns.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [6] [Bloc Voting on Single Peaked Preferences](https://arxiv.org/abs/2602.16734)
*Ariel Calver,Serena Pallan,Alice,Park,Jennifer Wilson*

Main category: cs.GT

TL;DR: 分析了在选民偏好为单峰的情况下，Bloc投票产生的获胜联盟。研究了候选人和获胜者数量较少时的条件，并评估了获胜联盟满足多赢家投票方法中Condorcet准则扩展的情况。


<details>
  <summary>Details</summary>
Motivation: 研究Bloc投票中选民偏好为单峰时形成的获胜联盟，探讨其特性以及与Condorcet准则扩展的关系。

Method: 采用理论分析和Monte Carlo模拟方法，研究小规模候选人和获胜者数量时的联盟条件，并评估获胜联盟在多赢家投票中的表现。

Result: 确定了获胜联盟中候选人相邻的条件，分析了获胜联盟满足Condorcet准则扩展的情况，并通过模拟研究了不同选民行为假设下这些联盟的出现频率。

Conclusion: 研究表明，在单峰偏好下，Bloc投票产生的获胜联盟在某些条件下具有一致性，并能满足多赢家投票中的Condorcet准则扩展。

Abstract: We analyze the winning coalitions that arise under Bloc voting when voters preferences are single-peaked. For small numbers of candidates and numbers of winners, we determine conditions under which candidates in winning coalitions are adjacent. We also analyze the results of pairwise contests between winning and losing candidates and assess when the winning coalitions satisfy several proposed extensions of the Condorcet criterion to multiwinner voting methods. Finally, we use Monte Carlo simulations to investigate how frequently these coalitions arise under different assumptions about voter behavior.

</details>


### [7] [Signaling in Data Markets via Free Samples](https://arxiv.org/abs/2602.16919)
*Nivasini Ananthakrishnan,Alireza Fallah,Michael I. Jordan*

Main category: cs.GT

TL;DR: 论文研究了数据买家从多个卖家购买样本以估计未知参数的场景，提出了一个包含免费试用阶段和拍卖阶段的多阶段博弈模型。


<details>
  <summary>Details</summary>
Motivation: 探讨如何在数据买卖中设计激励机制，以便买家能够通过免费试用和拍卖机制获取高质量的数据样本。

Method: 采用多阶段博弈模型，包括免费试用阶段（卖家通过提供免费样本传递数据质量信号）和拍卖阶段（买家基于更新后的信念选择卖家并购买样本）。

Result: 研究发现，在竞争足够强的情况下（卖家数量多），存在唯一的均衡，卖家会提供最大允许数量的免费样本。

Conclusion: 研究表明，免费试用机制在竞争激烈的市场中能有效促进数据质量的信号传递，从而优化数据采购过程。

Abstract: We study a setting in which a data buyer seeks to estimate an unknown parameter by purchasing samples from one of K data sellers. Each seller has privately known data quality (e.g., high vs. low variance) and a private per-sample cost. We consider a multi-stage game in which the first stage is a free-trial stage in which the sellers have the option of signaling data quality by offering a few samples of data for free. Buyers update their beliefs based on the sample variance of the free data and then run a procurement auction to buy data in a second stage. For the auction stage, we characterize an approximately optimal Bayesian incentive compatible mechanism: the buyer selects a single seller by minimizing a belief-adjusted virtual cost and chooses the purchased sample size as a function of posterior quality and virtual cost. For the free-trial stage, we characterize the equilibrium, taking the above mechanism as the continuation game. Free trials may fail to emerge: for some parameters, all sellers reveal zero samples. However, under sufficiently strong competition (large K), there is an equilibrium in which sellers reveal the maximum allowable number of samples; in fact, it is the unique equilibrium.

</details>


### [8] [Discovering Multiagent Learning Algorithms with Large Language Models](https://arxiv.org/abs/2602.16928)
*Zun Li,John Schultz,Daniel Hennes,Marc Lanctot*

Main category: cs.GT

TL;DR: 本文提出了一种名为AlphaEvolve的进化编码代理，利用大型语言模型自动发现多智能体学习算法的新变体。在两种不同的博弈学习范式中，该方法成功发现了两种新算法：VAD-CFR和SHOR-PSRO，这些算法在性能上超越了现有基线。


<details>
  <summary>Details</summary>
Motivation: 传统的多智能体强化学习算法（如CFR和PSRO）在设计高效变体时依赖于人工迭代优化，这不仅耗时且可能受限于人类直觉。本文旨在通过自动化方式探索庞大的算法设计空间，以减少人为干预并提高算法性能。

Method: 提出了一种名为AlphaEvolve的进化编码代理，利用大型语言模型自动生成和优化多智能体学习算法。具体应用于迭代遗憾最小化和基于群体的训练算法两种范式，发现了VAD-CFR和SHOR-PSRO两种新算法。

Result: VAD-CFR通过引入波动敏感的折扣机制和强制乐观一致性等方法，表现优于现有的Discounted Predictive CFR+。SHOR-PSRO通过混合乐观遗憾匹配和温度控制的纯策略分布，实现了从群体多样性到均衡求解的自动过渡，收敛性能优于静态元求解器。

Conclusion: AlphaEvolve展示了自动化发现多智能体学习算法的潜力，成功生成了性能超越人工设计基线的新算法，为未来算法设计提供了新的方向。

Abstract: Much of the advancement of Multi-Agent Reinforcement Learning (MARL) in imperfect-information games has historically depended on manual iterative refinement of baselines. While foundational families like Counterfactual Regret Minimization (CFR) and Policy Space Response Oracles (PSRO) rest on solid theoretical ground, the design of their most effective variants often relies on human intuition to navigate a vast algorithmic design space. In this work, we propose the use of AlphaEvolve, an evolutionary coding agent powered by large language models, to automatically discover new multiagent learning algorithms. We demonstrate the generality of this framework by evolving novel variants for two distinct paradigms of game-theoretic learning. First, in the domain of iterative regret minimization, we evolve the logic governing regret accumulation and policy derivation, discovering a new algorithm, Volatility-Adaptive Discounted (VAD-)CFR. VAD-CFR employs novel, non-intuitive mechanisms-including volatility-sensitive discounting, consistency-enforced optimism, and a hard warm-start policy accumulation schedule-to outperform state-of-the-art baselines like Discounted Predictive CFR+. Second, in the regime of population based training algorithms, we evolve training-time and evaluation-time meta strategy solvers for PSRO, discovering a new variant, Smoothed Hybrid Optimistic Regret (SHOR-)PSRO. SHOR-PSRO introduces a hybrid meta-solver that linearly blends Optimistic Regret Matching with a smoothed, temperature-controlled distribution over best pure strategies. By dynamically annealing this blending factor and diversity bonuses during training, the algorithm automates the transition from population diversity to rigorous equilibrium finding, yielding superior empirical convergence compared to standard static meta-solvers.

</details>


### [9] [Learning to Recommend in Unknown Games](https://arxiv.org/abs/2602.16998)
*Arwa Alanqary,Zakaria Baba,Manxi Wu,Alexandre M. Bayen*

Main category: cs.GT

TL;DR: 该论文研究了在多智能体游戏环境中的偏好学习，通过观察智能体对推荐行为的反馈（最佳响应或概率响应），分析了不同反馈模型对智能体效用函数可学习性的影响，并提出了在线算法以减少后悔。


<details>
  <summary>Details</summary>
Motivation: 研究动机在于理解在多智能体环境中，推荐系统如何通过智能体的行为反馈学习其效用函数，从而为战略交互环境中的AI推荐系统奠定理论基础。

Method: 论文提出了两种行为反馈模型（最佳响应和概率响应），并研究了每种模型下智能体效用函数的可学习性。此外，设计了一种基于智能体偏离推荐行为的后悔概念的在线算法。

Result: 结果表明，概率响应反馈下游戏的效用函数可在对数样本复杂度下学习，而最佳响应反馈只能识别更大的效用函数集合。论文还提供了对这一集合的完整几何描述，并展示了在线算法在两种反馈模型下均能实现较低的后悔值。

Conclusion: 论文为战略多智能体环境中的AI推荐系统提供了理论基础，展示了不同行为反馈模型对效用函数学习的影响，并通过在线算法验证了其有效性。

Abstract: We study preference learning through recommendations in multi-agent game settings, where a moderator repeatedly interacts with agents whose utility functions are unknown. In each round, the moderator issues action recommendations and observes whether agents follow or deviate from them. We consider two canonical behavioral feedback models-best response and quantal response-and study how the information revealed by each model affects the learnability of agents' utilities. We show that under quantal-response feedback the game is learnable, up to a positive affine equivalence class, with logarithmic sample complexity in the desired precision, whereas best-response feedback can only identify a larger set of agents' utilities. We give a complete geometric characterization of this set. Moreover, we introduce a regret notion based on agents' incentives to deviate from recommendations and design an online algorithm with low regret under both feedback models, with bounds scaling linearly in the game dimension and logarithmically in time. Our results lay a theoretical foundation for AI recommendation systems in strategic multi-agent environments, where recommendation compliances are shaped by strategic interaction.

</details>


### [10] [Prophet Inequality with Conservative Prediction](https://arxiv.org/abs/2602.17358)
*Johannes Brüstle,Ilan Reuven Cohen,Stefano Leonardi*

Main category: cs.GT

TL;DR: 本文研究了增强先知不等式模型的方法，通过引入对最大实现值的保守预测，提出了一个不依赖预测参数α的阈值策略，同时证明了在不牺牲α=0时的性能下限的情况下，无法在α=1时超越3/4的竞争比。


<details>
  <summary>Details</summary>
Motivation: 传统先知不等式模型仅依赖分布知识，本文旨在通过引入预测信息，提升模型在预测准确时的性能（一致性），同时在不准确时保持理论保证（鲁棒性）。

Method: 提出了一种不依赖预测参数α的阈值策略，并针对已知α的情况设计了另一种策略，其竞争比为$rac{1}{2-α}$。

Result: 不依赖α的策略在α=0和α=1时分别达到1/2和3/4的竞争比，且证明无法同时在α=1时超越3/4并在α=0时保持1/2。已知α的策略则达到紧致的$rac{1}{2-α}$竞争比。

Conclusion: 本文通过引入预测信息，成功平衡了一致性和鲁棒性，提出并验证了两种策略的竞争比，为增强先知不等式模型提供了理论基础。

Abstract: Prophet inequalities compare online stopping strategies against an omniscient "prophet" using distributional knowledge. In this work, we augment this model with a conservative prediction of the maximum realized value. We quantify the quality of this prediction using a parameter $α\in [0,1]$, ranging from inaccurate to perfect. Our goal is to improve performance when predictions are accurate (consistency) while maintaining theoretical guarantees when they are not (robustness). We propose a threshold-based strategy oblivious to $α$ (i.e., with $α$ unknown to the algorithm) that matches the classic competitive ratio of $1/2$ at $α=0$ and improves smoothly to $3/4$ at $α=1$. We further prove that simultaneously achieving better than $3/4$ at $α=1$ while maintaining $1/2$ at $α=0$ is impossible. Finally, when $α$ is known in advance, we present a strategy achieving a tight competitive ratio of $\frac{1}{2-α}$.

</details>
