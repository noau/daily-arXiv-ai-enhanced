{"id": "2601.03319", "categories": ["cs.GR", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.03319", "abs": "https://arxiv.org/abs/2601.03319", "authors": ["Eldad Matmon", "Amit Bracha", "Noam Rotstein", "Ron Kimmel"], "title": "CaricatureGS: Exaggerating 3D Gaussian Splatting Faces With Gaussian Curvature", "comment": null, "summary": "A photorealistic and controllable 3D caricaturization framework for faces is introduced. We start with an intrinsic Gaussian curvature-based surface exaggeration technique, which, when coupled with texture, tends to produce over-smoothed renders. To address this, we resort to 3D Gaussian Splatting (3DGS), which has recently been shown to produce realistic free-viewpoint avatars. Given a multiview sequence, we extract a FLAME mesh, solve a curvature-weighted Poisson equation, and obtain its exaggerated form. However, directly deforming the Gaussians yields poor results, necessitating the synthesis of pseudo-ground-truth caricature images by warping each frame to its exaggerated 2D representation using local affine transformations. We then devise a training scheme that alternates real and synthesized supervision, enabling a single Gaussian collection to represent both natural and exaggerated avatars. This scheme improves fidelity, supports local edits, and allows continuous control over the intensity of the caricature. In order to achieve real-time deformations, an efficient interpolation between the original and exaggerated surfaces is introduced. We further analyze and show that it has a bounded deviation from closed-form solutions. In both quantitative and qualitative evaluations, our results outperform prior work, delivering photorealistic, geometry-controlled caricature avatars."}
{"id": "2601.03381", "categories": ["cs.GT", "cs.LO"], "pdf": "https://arxiv.org/pdf/2601.03381", "abs": "https://arxiv.org/abs/2601.03381", "authors": ["Laurent Doyen", "Shibashis Guha"], "title": "Algorithm and Strategy Construction for Sure-Almost-Sure Stochastic Parity Games", "comment": "Extended version of STACS 2026 paper", "summary": "We consider turn-based stochastic two-player games with a combination of a parity condition that must hold surely, that is in all possible outcomes, and of a parity condition that must hold almost-surely, that is with probability 1. The problem of deciding the existence of a winning strategy in such games is central in the framework of synthesis beyond worst-case where a hard requirement that must hold surely is combined with a softer requirement. Recent works showed that the problem is coNP-complete, and infinite-memory strategies are necessary in general, even in one-player games (i.e., Markov decision processes). However, memoryless strategies are sufficient for the opponent player. Despite these comprehensive results, the known algorithmic solution enumerates all memoryless strategies of the opponent, which is exponential in all cases, and does not construct a winning strategy when one exists.\n  We present a recursive algorithm, based on a characterisation of the winning region, that gives a deeper insight into the problem. In particular, we show how to construct a winning strategy to achieve the combination of sure and almost-sure parity, and we derive new complexity and memory bounds for special classes of the problem, defined by fixing the index of either of the two parity conditions."}
{"id": "2601.03708", "categories": ["cs.PL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.03708", "abs": "https://arxiv.org/abs/2601.03708", "authors": ["Qingyun Zou", "Jiahao Cui", "Nuo Chen", "Bingsheng He", "Weng-Fai Wong"], "title": "MHRC-Bench: A Multilingual Hardware Repository-Level Code Completion benchmark", "comment": null, "summary": "Large language models (LLMs) have achieved strong performance on code completion tasks in general-purpose programming languages. However, existing repository-level code completion benchmarks focus almost exclusively on software code and largely overlook hardware description languages. In this work, we present \\textbf{MHRC-Bench}, consisting of \\textbf{MHRC-Bench-Train} and \\textbf{MHRC-Bench-Eval}, the first benchmark designed for multilingual hardware code completion at the repository level. Our benchmark targets completion tasks and covers three major hardware design coding styles. Each completion target is annotated with code-structure-level and hardware-oriented semantic labels derived from concrete syntax tree analysis. We conduct a comprehensive evaluation of models on MHRC-Bench-Eval. Comprehensive evaluation results and analysis demonstrate the effectiveness of MHRC-Bench."}
{"id": "2601.03438", "categories": ["cs.GT"], "pdf": "https://arxiv.org/pdf/2601.03438", "abs": "https://arxiv.org/abs/2601.03438", "authors": ["Vladimir Davidiuk", "Yuriy Dementiev", "Artur Ignatiev", "Danil Sagunov"], "title": "EFX and PO Allocation Exists for Two Types of Goods", "comment": "Accepted at AAAI 2026", "summary": "We study the problem of fairly and efficiently allocating indivisible goods among agents with additive valuations. We focus on envy-freeness up to any good (EFX) -- an important fairness notion in fair division of indivisible goods. A central open question in this field is whether EFX allocations always exist for any number of agents. While prior work has established EFX existence for settings with at most three distinct valuations (Prakash HV et al. 2025) and for two types of goods (Gorantla, Marwaha, and Velusamy 2023), the general case remains unresolved.\n  In this paper, we extend the existent knowledge by proving that EFX allocations satisfying Pareto optimality (PO) always exist and can be computed in quasiliniear time when there are two types of goods, given that the valuations are positive. This result strengthens the existing work of (Gorantla, Marwaha, and Velusamy 2023), which only guarantees the existence of EFX allocations without ensuring Pareto optimality. Our findings demonstrate a fairly simple and efficient algorithm constructing an EFX+PO allocation."}
{"id": "2601.03768", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.03768", "abs": "https://arxiv.org/abs/2601.03768", "authors": ["Yichen Xu", "Martin Odersky"], "title": "Agentic Proof Automation: A Case Study", "comment": null, "summary": "Proof engineering is notoriously labor-intensive: proofs that are straightforward on paper often require lengthy scripts in theorem provers. Recent advances in large language models (LLMs) create new opportunities for proof automation: modern LLMs not only generate proof scripts, but also support agentic behavior, exploring codebases and iteratively refining their outputs against prover feedback. These advances enable an emerging scheme where LLM-based agents undertake most proof engineering under human guidance. Humans provide mathematical insight (definitions, theorems, proof strategies); agents handle the mechanical work of proof development. We call this scheme agentic proof automation. We present this scheme through a case study: mechanizing the semantic type soundness of a sophisticated formal system, System Capless, in Lean 4, comprising over 14,000 lines of code. Using off-the-shelf LLM agents with a single lightweight proof-checking tool, the agents completed 189 proof engineering tasks with an 87% success rate, only 16% requiring human intervention. The case study demonstrates that agents are capable proof engineers that substantially boost productivity, though they fall short in creative reasoning and still require human guidance in certain cases. We release an interactive explorer where readers can examine all agent interactions; the mechanization is open-sourced for experiments and extensions."}
{"id": "2601.03853", "categories": ["cs.GT", "cs.LG", "econ.TH"], "pdf": "https://arxiv.org/pdf/2601.03853", "abs": "https://arxiv.org/abs/2601.03853", "authors": ["Junyao Zhao"], "title": "From No-Regret to Strategically Robust Learning in Repeated Auctions", "comment": null, "summary": "In Bayesian single-item auctions, a monotone bidding strategy--one that prescribes a higher bid for a higher value type--can be equivalently represented as a partition of the quantile space into consecutive intervals corresponding to increasing bids. Kumar et al. (2024) prove that agile online gradient descent (OGD), when used to update a monotone bidding strategy through its quantile representation, is strategically robust in repeated first-price auctions: when all bidders employ agile OGD in this way, the auctioneer's average revenue per round is at most the revenue of Myerson's optimal auction, regardless of how she adjusts the reserve price over time.\n  In this work, we show that this strategic robustness guarantee is not unique to agile OGD or to the first-price auction: any no-regret learning algorithm, when fed gradient feedback with respect to the quantile representation, is strategically robust, even if the auction format changes every round, provided the format satisfies allocation monotonicity and voluntary participation. In particular, the multiplicative weights update (MWU) algorithm simultaneously achieves the optimal regret guarantee and the best-known strategic robustness guarantee. At a technical level, our results are established via a simple relation that bridges Myerson's auction theory and standard no-regret learning theory. This showcases the potential of translating standard regret guarantees into strategic robustness guarantees for specific games, without explicitly minimizing any form of swap regret."}
{"id": "2601.03836", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2601.03836", "abs": "https://arxiv.org/abs/2601.03836", "authors": ["Ivan Perez", "Angel Herranz"], "title": "Logic Programming with Extensible Types", "comment": "In Proceedings ICLP 2025, arXiv:2601.00047", "summary": "Logic programming languages present clear advantages in terms of declarativeness and conciseness. However, the ideas of logic programming have been met with resistance in other programming communities, and have not generally been adopted by other paradigms and languages. This paper proposes a novel way to incorporate logic programming in an existing codebase in a typed functional programming language. Our approach integrates with the host language without sacrificing static typing, and leverages strengths of typed functional programming such as polymorphism and higher-order. We do so by combining three ideas. First, we use the extensible types technique to allow values of the host language to contain logic variables. Second, we implement a unification algorithm that works for any data structure that supports certain operations.Third, we introduce a domain-specific language to define and query predicates. We demonstrate our proposal via a series of examples, and provide aids to make the notation convenient for users, showing that the proposed approach is not just technically possible but also practical. Our ideas have been implemented in the language Haskell with very good results."}
{"id": "2601.03854", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2601.03854", "abs": "https://arxiv.org/abs/2601.03854", "authors": ["Ziyi Yang", "George PÃ®rlea", "Ilya Sergey"], "title": "Inductive First-Order Formula Synthesis by ASP: A Case Study in Invariant Inference", "comment": "In Proceedings ICLP 2025, arXiv:2601.00047", "summary": "We present a framework for synthesising formulas in first-order logic (FOL) from examples, which unifies and advances state-of-the-art approaches for inference of transition system invariants. To do so, we study and categorise the existing methodologies, encoding techniques in their formula synthesis via answer set programming (ASP). Based on the derived categorisation, we propose orthogonal slices, a new technique for formula enumeration that partitions the search space into manageable chunks, enabling two approaches for incremental candidate pruning. Using a combination of existing techniques for first-order (FO) invariant synthesis and the orthogonal slices implemented in our framework FORCE, we significantly accelerate a state-of-the-art algorithm for distributed system invariant inference. We also show that our approach facilitates composition of different invariant inference frameworks, allowing for novel optimisations."}
{"id": "2601.03897", "categories": ["cs.PL", "cs.DS"], "pdf": "https://arxiv.org/pdf/2601.03897", "abs": "https://arxiv.org/abs/2601.03897", "authors": ["Ziad Ismaili Alaoui", "Detlef Plump"], "title": "Implementing Binary Search Trees in GP 2 (Extended Abstract)", "comment": "In Proceedings GCM 2025, arXiv:2601.03249", "summary": "We present an approach to implement binary search trees in the rule-based graph programming language GP 2. Our implementation uses GP 2's rooted graph transformation rules to be fast and supports insertion, deletion and query operations. We argue that the worst-case runtime for each of the operations is O(n) for a tree with n nodes. In addition, we expect that, on average, the operations run in time O(log(n)). Hence the implementation would match the time complexity of binary search trees implementations in imperative languages."}
{"id": "2601.04085", "categories": ["cs.PL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.04085", "abs": "https://arxiv.org/abs/2601.04085", "authors": ["Jingwen Xu", "Yiyang Lu", "Changze Lv", "Zisu Huang", "Zhengkang Guo", "Zhengyuan Wang", "Muzhao Tian", "Xuanjing Huang", "Xiaoqing Zheng"], "title": "CSSG: Measuring Code Similarity with Semantic Graphs", "comment": null, "summary": "Existing code similarity metrics, such as BLEU, CodeBLEU, and TSED, largely rely on surface-level string overlap or abstract syntax tree structures, and often fail to capture deeper semantic relationships between programs.We propose CSSG (Code Similarity using Semantic Graphs), a novel metric that leverages program dependence graphs to explicitly model control dependencies and variable interactions, providing a semantics-aware representation of code.Experiments on the CodeContests+ dataset show that CSSG consistently outperforms existing metrics in distinguishing more similar code from less similar code under both monolingual and cross-lingual settings, demonstrating that dependency-aware graph representations offer a more effective alternative to surface-level or syntax-based similarity measures."}
