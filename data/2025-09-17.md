<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 1]
- [cs.PL](#cs.PL) [Total: 6]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [Temporally Smooth Mesh Extraction for Procedural Scenes with Long-Range Camera Trajectories using Spacetime Octrees](https://arxiv.org/abs/2509.13306)
*Zeyu Ma,Adam Finkelstein,Jia Deng*

Main category: cs.GR

TL;DR: 提出了一种基于时空二叉树结构的4D网格提取方法，用于在无界场景中为长距离摄像机轨迹生成临时一致的网格，以解决现有方法中的视觉不一致问题。


<details>
  <summary>Details</summary>
Motivation: 在无界场景中，长距离摄像机轨迹（如飞越森林）需要一个灵活且紧凑的3D场景表示方法。静态网格可能过大，而独立网格提取可能导致视觉跳跃。因此，需要一种临时一致的方法来提取网格。

Method: 提出了一种4D网格提取方法，使用一种称为二叉八叉树的时空树结构，以在无界场景中生成临时一致的网格。

Result: 实验表明，与现有基线方法相比，该方法在相似成本下提供了更优的视觉一致性。

Conclusion: 该方法为长距离摄像机轨迹提供了一种高效的网格提取解决方案，有效解决了视觉跳跃问题，并展示了优越的视觉一致性。

Abstract: The procedural occupancy function is a flexible and compact representation
for creating 3D scenes. For rasterization and other tasks, it is often
necessary to extract a mesh that represents the shape. Unbounded scenes with
long-range camera trajectories, such as flying through a forest, pose a unique
challenge for mesh extraction. A single static mesh representing all the
geometric detail necessary for the full camera path can be prohibitively large.
Therefore, independent meshes can be extracted for different camera views, but
this approach may lead to popping artifacts during transitions. We propose a
temporally coherent method for extracting meshes suitable for long-range camera
trajectories in unbounded scenes represented by an occupancy function. The key
idea is to perform 4D mesh extraction using a new spacetime tree structure
called a binary-octree. Experiments show that, compared to existing baseline
methods, our method offers superior visual consistency at a comparable cost.
The code and the supplementary video for this paper are available at
https://github.com/princeton-vl/BinocMesher.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [2] [Converting IEC 61131-3 LD into SFC Using Large Language Model: Dataset and Testing](https://arxiv.org/abs/2509.12593)
*Yimin Zhang,Mario de Sousa*

Main category: cs.PL

TL;DR: 研究探讨了利用大型语言模型（LLM）将梯形图（LD）转换为顺序功能图（SFC）的可行性，通过构建符合IEC 61131-3标准的数据集，实验表明微调后的LLM模型准确率最高可达91%。


<details>
  <summary>Details</summary>
Motivation: 在PLC编程领域，LD到SFC的转换因缺乏领域特定知识和状态爆炸问题而具有挑战性，AI尤其是LLM的发展为此提供了新思路，但数据驱动的应用因缺乏合适数据集而受限。

Method: 构建了符合IEC 61131-3标准的LD与SFC配对的文本数据集，并在此基础上探索了基于LLM的自动化转换方法，进行了初步实验。

Result: 实验显示，微调后的LLM模型在某些数据集上的准确率最高达91%，最低为79%，表明LLM可以有效地支持LD-SFC的转换。

Conclusion: 研究结果证明了基于LLM的LD-SFC转换的可行性和未来潜力，为这一领域的自动化提供了新的方向。

Abstract: In the domain of Programmable Logic Controller (PLC) programming, converting
a Ladder Diagram (LD) into a Sequential Function Chart (SFC) is an inherently
challenging problem, primarily due to the lack of domain-specific knowledge and
the issue of state explosion in existing algorithms. However, the rapid
development of Artificial Intelligence (AI) - especially Large Language Model
(LLM) - offers a promising new approach.
  Despite this potential, data-driven approaches in this field have been
hindered by a lack of suitable datasets. To address this gap, we constructed
several datasets consisting of paired textual representations of SFC and LD
programs that conform to the IEC 61131-3 standard.
  Based on these datasets, we explored the feasibility of automating the LD-SFC
conversion using LLM. Our preliminary experiments show that a fine-tuned LLM
model achieves up to 91% accuracy on certain dataset, with the lowest observed
accuracy being 79%, suggesting that with proper training and representation,
LLMs can effectively support LD-SFC conversion. These early results highlight
the viability and future potential of this approach.

</details>


### [3] [Efficient Compilation of Algorithms into Compact Linear Programs](https://arxiv.org/abs/2509.13006)
*Shermin Khosravi,David Bremner*

Main category: cs.PL

TL;DR: 论文提出了一种新的方法，通过层次线性流水线技术分解嵌套程序结构，显著减小线性规划（LP）的规模，同时在两个基准问题上展示了高达25倍的LP规模缩减和求解器性能提升。


<details>
  <summary>Details</summary>
Motivation: 现有的LP编译器虽然能将多项式时间、多项式空间的算法转化为多项式规模的LP，但生成的LP规模过大，导致现有LP求解器面临挑战。论文旨在为P类问题建立最小规模的紧凑LP公式。

Method: 论文引入了层次线性流水线技术，将嵌套程序结构分解为同步区域，局部化每个区域的LP约束和变量，从而在不丧失一般性的情况下显著减小LP规模。

Result: 在两个基准问题上（makespan问题和加权最小生成树问题），论文方法实现了高达25倍的LP规模缩减，并在商业和非商业LP求解器上显著提升了性能。

Conclusion: 论文提出的方法不仅显著减小了LP规模，还提升了求解器性能，为实现紧凑整数规划（CIP）的系统生成提供了新的途径。

Abstract: Linear Programming (LP) is widely applied in industry and is a key component
of various other mathematical problem-solving techniques. Recent work
introduced an LP compiler translating polynomial-time, polynomial-space
algorithms into polynomial-size LPs using intuitive high-level programming
languages, offering a promising alternative to manually specifying each set of
constraints through Algebraic Modeling Languages (AMLs). However, the resulting
LPs, while polynomial in size, are often extremely large, posing challenges for
existing LP solvers. In this paper, we propose a novel approach for generating
substantially smaller LPs from algorithms. Our goal is to establish
minimum-size compact LP formulations for problems in P having natural
formulations with exponential extension complexities. Our broader vision is to
enable the systematic generation of Compact Integer Programming (CIP)
formulations for problems with exponential-size IPs having polynomial-time
separation oracles. To this end, we introduce a hierarchical linear pipelining
technique that decomposes nested program structures into synchronized regions
with well-defined execution transitions -- functions of compile-time
parameters. This decomposition allows us to localize LP constraints and
variables within each region, significantly reducing LP size without the loss
of generality, ensuring the resulting LP remains valid for all inputs of size
$n$. We demonstrate the effectiveness of our method on two benchmark problems
-- the makespan problem, which has exponential extension complexity, and the
weighted minimum spanning tree problem -- both of which have exponential-size
natural LPs. Our results show up to a $25$-fold reduction in LP size and
substantial improvements in solver performance across both commercial and
non-commercial LP solvers.

</details>


### [4] [Pleasant Imperative Program Proofs with GallinaC](https://arxiv.org/abs/2509.13019)
*Frédéric Fort,David Nowak,Vlad Rusu*

Main category: cs.PL

TL;DR: GallinaC是一种在Rocq证明助手的Gallina语言中浅嵌入的图灵完备命令式语言，旨在简化数学正确性证明。


<details>
  <summary>Details</summary>
Motivation: 由于当前命令式编程语言的语义过于宽松，导致正确性证明繁琐且易错，设计一种既支持命令式编程又便于数学证明的语言变得必要。

Method: GallinaC采用了在Gallina语言中的浅嵌入方法，引入了一个通用的无界while循环，并利用Rocq证明助手机器验证程序和证明。

Result: 初步实现展示了GallinaC的可行性，如成功验证了一个未知大小链表的反转算法的正确性，并正在进行与Cminor语言的前向模拟研究。

Conclusion: GallinaC为命令式编程语言的数学正确性证明提供了新思路，尽管仍在开发中，但已有初步成果证明了其潜力。

Abstract: Even with the increase of popularity of functional programming, imperative
programming remains a key programming paradigm, especially for programs
operating at lower levels of abstraction. When such software offers key
components of a Trusted Computing Base (TCB), e.g. an operating system kernel,
it becomes desirable to provide mathematical correctness proofs.
  However, current real-world imperative programming languages possess
"expressive", i.e. overly permissive, semantics. Thus, producing correctness
proofs of such programs becomes tedious and error-prone, requiring to take care
of numerous "administrative" details. Ideally, a proof-oriented imperative
language should feature well-behaved semantics while allowing imperative
idioms.
  To obtain a high-degree of confidence in the correctness of such a language,
its tools should be developed inside a proof-assistant such that program proofs
are machine checked.
  We present GallinaC, a shallow embedding of a Turing-complete imperative
language directly inside the functional programming language of the Rocq proof
assistant, Gallina. In particular, it features a truly generic and unbounded
while loop. Having a functional core means proofs about GallinaC programs may
use the same tactics as proofs about pure functional ones.
  Work on GallinaC is still under progress, but we present first promising
results. A prototype implementation has shown the viability of GallinaC with
the correctness proof of a list reversal procedure for linked-lists of unknown
size. We currently focus on the forward simulation between the GallinaC
intermediate representation (IR) and Cminor, the entry language of the CompCert
back-end.

</details>


### [5] [Navigating the Python Type Jungle](https://arxiv.org/abs/2509.13022)
*Andrei Nacu,Dorel Lucanu*

Main category: cs.PL

TL;DR: 本文提出了一种形式化方法来整合Python分散的类型系统规范，并为其提供了理论基础。


<details>
  <summary>Details</summary>
Motivation: Python的类型系统在实践中发展得强大但理论分散，缺乏统一的规范，这促使作者对其进行形式化处理。

Method: 作者利用类型理论中的概念，为Python的类型系统建立了一个形式化基础。

Result: 研究证明了Python的类型系统可以用优雅的理论描述，为未来的类型推断工具开发奠定了基础。

Conclusion: 这项工作是未来开发类型推断工具的重要第一步，为Python类型系统的理论整合提供了解决方案。

Abstract: Python's typing system has evolved pragmatically into a powerful but
theoretically fragmented system, with scattered specifications. This paper
proposes a formalization to address this fragmentation. The central
contribution is a formal foundation that uses concepts from type theory to
demonstrate that Python's type system can be elegantly described. This work
aims to serve as a crucial first step toward the future development of type
inference tools.

</details>


### [6] [Try-Mopsa: Relational Static Analysis in Your Pocket](https://arxiv.org/abs/2509.13128)
*Raphaël Monat*

Main category: cs.PL

TL;DR: Try-Mopsa是一个基于JavaScript的简化版Mopsa静态分析平台，旨在降低学习静态分析的难度。


<details>
  <summary>Details</summary>
Motivation: 静态分析器的复杂性和安装难度阻碍了其普及和学习，Try-Mopsa希望通过简化和易用性解决这一问题。

Method: 研究将Mopsa静态分析平台简化并编译成JavaScript，使其能在浏览器中作为客户端应用运行，支持桌面和移动设备。

Result: Try-Mopsa保留了Mopsa的核心功能，包括关系数值域的支持，并提供了响应式界面。

Conclusion: Try-Mopsa是一个便利的平台，适合用于教学和入门目的。

Abstract: Static analyzers are complex pieces of software with large dependencies. They
can be difficult to install, which hinders adoption and creates barriers for
students learning static analysis. This work introduces Try-Mopsa: a
scaled-down version of the Mopsa static analysis platform, compiled into
JavaScript to run purely as a client-side application in web browsers.
Try-Mopsa provides a responsive interface that works on both desktop and mobile
devices. Try-Mopsa features all the core components of Mopsa. In particular, it
supports relational numerical domains. We present the interface, changes and
adaptations required to have a pure JavaScript version of Mopsa. We envision
Try-Mopsa as a convenient platform for onboarding or teaching purposes.

</details>


### [7] [Rebound: Efficient, Expressive, and Well-Scoped Binding](https://arxiv.org/abs/2509.13261)
*Noé De Santo,Stephanie Weirich*

Main category: cs.PL

TL;DR: Rebound库支持Haskell中的范围限定词项表示，并自动化绑定结构相关操作的定义，如替换和α等价等。


<details>
  <summary>Details</summary>
Motivation: 设计Rebound库的动机是为用户提供一种方法来确保在使用de Bruijn索引时正确维护复杂的不变性。

Method: Rebound库的核心设计是使用静态跟踪范围的一类环境，将变量映射到新范围中的表达式，从而优化替换应用并提供对这些数据结构的显式访问。

Result: Rebound库通过实现多种语言特性（如依赖类型编程语言pi-forall的类型检查器）展现了其表达能力，并在性能测试中优于其他竞争库。

Conclusion: Rebound库不仅提供了表达能力和性能优势，还为处理绑定结构的操作提供了可靠的支持。

Abstract: We introduce the Rebound library that supports well-scoped term
representations in Haskell and automates the definition of substitution,
alpha-equivalence, and other operations that work with binding structures. The
key idea of our design is the use of first-class environments that map
variables to expressions in some new scope. By statically tracking scopes,
users of this library gain confidence that they have correctly maintained the
subtle invariants that stem from using de Bruijn indices. Behind the scenes,
Rebound uses environments to optimize the application of substitutions, while
providing explicit access to these data structures when desired. We demonstrate
that this library is expressive by using it to implement a wide range of
language features with sophisticated uses of binding and several different
operations that use this abstract syntax. Our examples include pi-forall, a
tutorial implementation of a type checker for a dependently-typed programming
language. Finally, we benchmark Rebound to understand its performance
characteristics and find that it produces faster code than competing libraries.

</details>
