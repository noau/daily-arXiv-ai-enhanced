{"id": "2508.03830", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.03830", "abs": "https://arxiv.org/abs/2508.03830", "authors": ["Hanwen Guo", "Ben Greenman"], "title": "If-T: A Benchmark for Type Narrowing", "comment": null, "summary": "**Context:** The design of static type systems that can validate\ndynamically-typed programs (**gradually**) is an ongoing challenge. A key\ndifficulty is that dynamic code rarely follows datatype-driven design. Programs\ninstead use runtime tests to narrow down the proper usage of incoming data.\nType systems for dynamic languages thus need a **type narrowing** mechanism\nthat refines the type environment along individual control paths based on\ndominating tests, a form of flow-sensitive typing. In order to express\nrefinements, the type system must have some notion of sets and subsets. Since\nset-theoretic types are computationally and ergonomically complex, the need for\ntype narrowing raises design questions about how to balance precision and\nperformance. **Inquiry:** To date, the design of type narrowing systems has\nbeen driven by intuition, past experience, and examples from users in various\nlanguage communities. There is no standard that captures desirable and\nundesirable behaviors. Prior formalizations of narrowing are also significantly\nmore complex than a standard type system, and it is unclear how the extra\ncomplexity pays off in terms of concrete examples. This paper addresses the\nproblems through If-T, a language-agnostic **design benchmark** for type\nnarrowing that characterizes the abilities of implementations using simple\nprograms that draw attention to fundamental questions. Unlike a traditional\nperformance-focused benchmark, If-T measures a narrowing system's ability to\nvalidate correct code and reject incorrect code. Unlike a test suite, systems\nare not required to fully conform to If-T. Deviations are acceptable provided\nthey are justified by well-reasoned design considerations, such as compile-time\nperformance. **Approach:** If-T is guided by the literature on type narrowing,\nthe documentation of gradual languages such as TypeScript, and experiments with\ntypechecker implementations. We have identified a set of core technical\ndimensions for type narrowing. For each dimension, the benchmark contains a set\nof topics and (at least) two characterizing programs per topic: one that should\ntypecheck and one that should not typecheck. **Knowledge:** If-T provides a\nbaseline to measure type narrowing systems. For researchers, it provides\ncriteria to categorize future designs via its collection of positive and\nnegative examples. For language designers, the benchmark demonstrates the\npayoff of typechecker complexity in terms of concrete examples. Designers can\nuse the examples to decide whether supporting a particular example is\nworthwhile. Both the benchmark and its implementations are freely available\nonline. **Grounding:** We have implemented the benchmark for five typecheckers:\nTypeScript, Flow, Typed Racket, mypy, and Pyright. The results highlight\nimportant differences, such as the ability to track logical implications among\nprogram variables and typechecking for user-defined narrowing predicates.\n**Importance:** Type narrowing is essential for gradual type systems, but the\ntradeoffs between systems with different complexity have been unclear. If-T\nclarifies these tradeoffs by illustrating the benefits and limitations of each\nlevel of complexity. With If-T as a way to assess implementations in a fair,\ncross-language manner, future type system designs can strive for a better\nbalance among precision, annotation burden, and performance."}
{"id": "2508.03831", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.03831", "abs": "https://arxiv.org/abs/2508.03831", "authors": ["Chinmayi Prabhu Baramashetru", "Paola Giannini", "Silvia Lizeth Tapia Tarifa", "Olaf Owe"], "title": "A Type System for Data Privacy Compliance in Active Object Languages", "comment": null, "summary": "Data protection laws such as GDPR aim to give users unprecedented control\nover their personal data. Compliance with these regulations requires\nsystematically considering information flow and interactions among entities\nhandling sensitive data. Privacy-by-design principles advocate embedding data\nprotection into system architectures as a default. However, translating these\nabstract principles into concrete, explicit methods remains a significant\nchallenge. This paper addresses this gap by proposing a language-based approach\nto privacy integration, combining static and runtime techniques. By employing\ntype checking and type inference in an active object language, the framework\nenables the tracking of authorised data flows and the automatic generation of\nconstraints checked at runtime based on user consent. This ensures that\npersonal data is processed in compliance with GDPR constraints. The key\ncontribution of this work is a type system that gather the compliance checks\nand the changes to users consent and integrates data privacy compliance\nverification into system execution. The paper demonstrates the feasibility of\nthis approach through a soundness proof and several examples, illustrating how\nthe proposed language addresses common GDPR requirements, such as user consent,\npurpose limitation, and data subject rights. This work advances the state of\nthe art in privacy-aware system design by offering a systematic and automated\nmethod for integrating GDPR compliance into programming languages. This\ncapability has implications for building trustworthy systems in domains such as\nhealthcare or finance, where data privacy is crucial."}
{"id": "2508.03832", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.03832", "abs": "https://arxiv.org/abs/2508.03832", "authors": ["Andreas Pointner", "Josef Pichler", "Herbert Pr√§hofer"], "title": "Generating Inputs for Grammar Mining using Dynamic Symbolic Execution", "comment": null, "summary": "A vast number of software systems include components that parse and process\nstructured input. In addition to programming languages, which are analyzed by\ncompilers or interpreters, there are numerous components that process\nstandardized or proprietary data formats of varying complexity. Even if such\ncomponents were initially developed and tested based on a specification, such\nas a grammar, numerous modifications and adaptations over the course of\nsoftware evolution can make it impossible to precisely determine which inputs\nthey actually accept. In this situation, grammar mining can be used to\nreconstruct the specification in the form of a grammar. Established approaches\nalready produce useful results, provided that sufficient input data is\navailable to fully cover the input language. However, achieving this\ncompleteness is a major challenge. In practice, only input data recorded during\nthe operation of the software systems is available. If this data is used for\ngrammar mining, the resulting grammar reflects only the actual processed inputs\nbut not the complete grammar of the input language accepted by the software\ncomponent. As a result, edge cases or previously supported features that no\nlonger appear in the available input data are missing from the generated\ngrammar. This work addresses this challenge by introducing a novel approach for\nthe automatic generation of inputs for grammar mining. Although input\ngenerators have already been used for fuzz testing, it remains unclear whether\nthey are also suitable for grammar miners. Building on the grammar miner Mimid,\nthis work presents a fully automated approach to input generation. The approach\nleverages Dynamic Symbolic Execution (DSE) and extends it with two mechanisms\nto overcome the limitations of DSE regarding structured input parsers. First,\nthe search for new inputs is guided by an iterative expansion that starts with\na single-character input and gradually extends it. Second, input generation is\nstructured into a novel three-phase approach, which separates the generation of\ninputs for parser functions. The proposed method was evaluated against a\ndiverse set of eleven benchmark applications from the existing literature.\nResults demonstrate that the approach achieves precision and recall for\nextracted grammars close to those derived from state-of-the-art grammar miners\nsuch as Mimid. Notably, it successfully uncovers subtle features and edge cases\nin parsers that are typically missed by such grammar miners. The effectiveness\nof the method is supported by empirical evidence, showing that it can achieve\nhigh performance in various domains without requiring prior input samples. This\ncontribution is significant for researchers and practitioners in software\nengineering, offering an automated, scalable, and precise solution for grammar\nmining. By eliminating the need for manual input generation, the approach not\nonly reduces workload but also enhances the robustness and comprehensiveness of\nthe extracted grammars. Following this approach, software engineers can\nreconstruct specification from existing (legacy) parsers."}
{"id": "2508.04115", "categories": ["cs.PL", "A.1; C.1.2; D.3.1; F.3.1; F.3.2"], "pdf": "https://arxiv.org/pdf/2508.04115", "abs": "https://arxiv.org/abs/2508.04115", "authors": ["Roger C. Su", "Robert J. Colvin"], "title": "Weak Memory Model Formalisms: Introduction and Survey", "comment": null, "summary": "Memory consistency models define the order in which accesses to shared memory\nin a concurrent system may be observed to occur. Such models are a necessity\nsince program order is not a reliable indicator of execution order, due to\nmicroarchitectural features or compiler transformations. Concurrent\nprogramming, already a challenging task, is thus made even harder when weak\nmemory effects must be addressed. A rigorous specification of weak memory\nmodels is therefore essential to make this problem tractable for developers of\nsafety- and security-critical, low-level software.\n  In this paper we survey the field of formalisations of weak memory models,\nincluding their specification, their effects on execution, and tools and\ninference systems for reasoning about code. To assist the discussion we also\nprovide an introduction to two styles of formal representation found commonly\nin the literature (using a much simplified version of Intel's x86 as the\nexample): a step-by-step construction of traces of the system (operational\nsemantics); and with respect to relations between memory events (axiomatic\nsemantics). The survey covers some long-standing hardware features that lead to\nobservable weak behaviours, a description of historical developments in\npractice and in theory, an overview of computability and complexity results,\nand outlines current and future directions in the field."}
{"id": "2508.04078", "categories": ["cs.GR", "cs.CV", "cs.LG"], "pdf": "https://arxiv.org/pdf/2508.04078", "abs": "https://arxiv.org/abs/2508.04078", "authors": ["Zhan Li", "Huangying Zhan", "Changyang Li", "Qingan Yan", "Yi Xu"], "title": "RLGS: Reinforcement Learning-Based Adaptive Hyperparameter Tuning for Gaussian Splatting", "comment": "14 pages, 9 figures", "summary": "Hyperparameter tuning in 3D Gaussian Splatting (3DGS) is a labor-intensive\nand expert-driven process, often resulting in inconsistent reconstructions and\nsuboptimal results. We propose RLGS, a plug-and-play reinforcement learning\nframework for adaptive hyperparameter tuning in 3DGS through lightweight policy\nmodules, dynamically adjusting critical hyperparameters such as learning rates\nand densification thresholds. The framework is model-agnostic and seamlessly\nintegrates into existing 3DGS pipelines without architectural modifications. We\ndemonstrate its generalization ability across multiple state-of-the-art 3DGS\nvariants, including Taming-3DGS and 3DGS-MCMC, and validate its robustness\nacross diverse datasets. RLGS consistently enhances rendering quality. For\nexample, it improves Taming-3DGS by 0.7dB PSNR on the Tanks and Temple (TNT)\ndataset, under a fixed Gaussian budget, and continues to yield gains even when\nbaseline performance saturates. Our results suggest that RLGS provides an\neffective and general solution for automating hyperparameter tuning in 3DGS\ntraining, bridging a gap in applying reinforcement learning to 3DGS."}
{"id": "2508.03818", "categories": ["cs.GT", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.03818", "abs": "https://arxiv.org/abs/2508.03818", "authors": ["Toby Walsh"], "title": "Mechanism Design for Facility Location using Predictions", "comment": "To appear in Proceedings oj IJCAI 2025 workshop on Computational Fair\n  Division", "summary": "We study mechanisms for the facility location problem augmented with\npredictions of the optimal facility location. We demonstrate that an\negalitarian viewpoint which considers both the maximum distance of any agent\nfrom the facility and the minimum utility of any agent provides important new\ninsights compared to a viewpoint that just considers the maximum distance. As\nin previous studies, we consider performance in terms of consistency (worst\ncase when predictions are accurate) and robustness (worst case irrespective of\nthe accuracy of predictions). By considering how mechanisms with predictions\ncan perform poorly, we design new mechanisms that are more robust. Indeed, by\nadjusting parameters, we demonstrate how to trade robustness for consistency.\nWe go beyond the single facility problem by designing novel strategy proof\nmechanisms for locating two facilities with bounded consistency and robustness\nthat use two predictions for where to locate the two facilities."}
{"id": "2508.04326", "categories": ["cs.GR"], "pdf": "https://arxiv.org/pdf/2508.04326", "abs": "https://arxiv.org/abs/2508.04326", "authors": ["Ke Li", "Mana Masuda", "Susanne Schmidt", "Shohei Mori"], "title": "Radiance Fields in XR: A Survey on How Radiance Fields are Envisioned and Addressed for XR Research", "comment": "This work has been submitted to the IEEE TVCG journal for possible\n  publication", "summary": "The development of radiance fields (RF), such as 3D Gaussian Splatting (3DGS)\nand Neural Radiance Fields (NeRF), has revolutionized interactive\nphotorealistic view synthesis and presents enormous opportunities for XR\nresearch and applications. However, despite the exponential growth of RF\nresearch, RF-related contributions to the XR community remain sparse. To better\nunderstand this research gap, we performed a systematic survey of current RF\nliterature to analyze (i) how RF is envisioned for XR applications, (ii) how\nthey have already been implemented, and (iii) the remaining research gaps. We\ncollected 365 RF contributions related to XR from computer vision, computer\ngraphics, robotics, multimedia, human-computer interaction, and XR communities,\nseeking to answer the above research questions. Among the 365 papers, we\nperformed an analysis of 66 papers that already addressed a detailed aspect of\nRF research for XR. With this survey, we extended and positioned XR-specific RF\nresearch topics in the broader RF research field and provide a helpful resource\nfor the XR community to navigate within the rapid development of RF research."}
{"id": "2508.03824", "categories": ["cs.GT", "cs.MA"], "pdf": "https://arxiv.org/pdf/2508.03824", "abs": "https://arxiv.org/abs/2508.03824", "authors": ["Hamzah I. Khan", "Jingqi Li", "David Fridovich-Keil"], "title": "What Do Agents Think Others Would Do? Level-2 Inverse Games for Inferring Agents' Estimates of Others' Objectives", "comment": "7 pages + references + appendix", "summary": "Effectively interpreting strategic interactions among multiple agents\nrequires us to infer each agent's objective from limited information. Existing\ninverse game-theoretic approaches frame this challenge in terms of a \"level-1\"\ninference problem, in which we take the perspective of a third-party observer\nand assume that individual agents share complete knowledge of one another's\nobjectives. However, this assumption breaks down in decentralized, real-world\ndecision scenarios like urban driving and bargaining, in which agents may act\nbased on conflicting views of one another's objectives. We demonstrate the\nnecessity of inferring agents' heterogeneous estimates of each other's\nobjectives through empirical examples, and by theoretically characterizing the\nprediction error of level-1 inference on fictitious gameplay data from\nlinear-quadratic games. To address this fundamental issue, we propose a\nframework for level-2 inference to address the question: \"What does each agent\nbelieve about all agents' objectives?\" We prove that the level-2 inference\nproblem is non-convex even in benign settings like linear-quadratic games, and\nwe develop an efficient gradient-based approach for identifying local\nsolutions. Experiments on a synthetic urban driving example show that our\napproach uncovers nuanced misalignments that level-1 methods miss."}
{"id": "2508.04508", "categories": ["cs.GR", "cs.CV"], "pdf": "https://arxiv.org/pdf/2508.04508", "abs": "https://arxiv.org/abs/2508.04508", "authors": ["Haodong Zhu", "Changbai Li", "Yangyang Ren", "Zichao Feng", "Xuhui Liu", "Hanlin Chen", "Xiantong Zhen", "Baochang Zhang"], "title": "Surf3R: Rapid Surface Reconstruction from Sparse RGB Views in Seconds", "comment": null, "summary": "Current multi-view 3D reconstruction methods rely on accurate camera\ncalibration and pose estimation, requiring complex and time-intensive\npre-processing that hinders their practical deployment. To address this\nchallenge, we introduce Surf3R, an end-to-end feedforward approach that\nreconstructs 3D surfaces from sparse views without estimating camera poses and\ncompletes an entire scene in under 10 seconds. Our method employs a\nmulti-branch and multi-view decoding architecture in which multiple reference\nviews jointly guide the reconstruction process. Through the proposed\nbranch-wise processing, cross-view attention, and inter-branch fusion, the\nmodel effectively captures complementary geometric cues without requiring\ncamera calibration. Moreover, we introduce a D-Normal regularizer based on an\nexplicit 3D Gaussian representation for surface reconstruction. It couples\nsurface normals with other geometric parameters to jointly optimize the 3D\ngeometry, significantly improving 3D consistency and surface detail accuracy.\nExperimental results demonstrate that Surf3R achieves state-of-the-art\nperformance on multiple surface reconstruction metrics on ScanNet++ and Replica\ndatasets, exhibiting excellent generalization and efficiency."}
{"id": "2508.04668", "categories": ["cs.GT", "cs.CY", "econ.TH"], "pdf": "https://arxiv.org/pdf/2508.04668", "abs": "https://arxiv.org/abs/2508.04668", "authors": ["Aviv Yaish", "Nir Chemaya", "Lin William Cong", "Dahlia Malkhi"], "title": "Inequality in the Age of Pseudonymity", "comment": "38 pages, 1 figure", "summary": "Inequality measures such as the Gini coefficient are used to inform and\nmotivate policymaking, and are increasingly applied to digital platforms. We\nanalyze how measures fare in pseudonymous settings, as common to internet-based\nor blockchain-based platforms. One key challenge that arises is the ability of\nactors to create multiple fake identities under fictitious false names, also\nknown as ``Sybils.'' While some actors may do so to preserve their privacy, we\nshow that this can inadvertently distort inequality metrics. As we show, when\nusing inequality measures that satisfy literature's canonical set of desired\nproperties, the presence of Sybils in an economy implies that it is impossible\nto properly measure the economy's inequality. Then, we present several classes\nof Sybil-proof measures that satisfy relaxed versions of the aforementioned\ndesired properties, and, by fully characterizing them, we prove that the\nstructure imposed restricts their ability to assess inequality at a\nfine-grained level. In addition, we prove that popular inequality metrics,\nincluding the famous Gini coefficient, are vulnerable to Sybil manipulations,\nand examine the dynamics that result in the creation of Sybils, whether in\npseudonymous settings or traditional ones."}
{"id": "2508.04687", "categories": ["cs.GR", "cs.CV", "I.3.2; I.4.10"], "pdf": "https://arxiv.org/pdf/2508.04687", "abs": "https://arxiv.org/abs/2508.04687", "authors": ["Ye Pan", "Ruisi Zhang", "Jingying Wang", "Nengfu Chen", "Yilin Qiu", "Yu Ding", "Kenny Mitchell"], "title": "MienCap: Realtime Performance-Based Facial Animation with Live Mood Dynamics", "comment": "IEEE VR extended authors version of the article published in 2022\n  IEEE Conference on Virtual Reality and 3D User Interfaces Abstracts and\n  Workshops (VRW). This work was supported by the European Union's Horizon 2020\n  research and innovation programme under Grant 101017779", "summary": "Our purpose is to improve performance-based animation which can drive\nbelievable 3D stylized characters that are truly perceptual. By combining\ntraditional blendshape animation techniques with multiple machine learning\nmodels, we present both non-real time and real time solutions which drive\ncharacter expressions in a geometrically consistent and perceptually valid way.\nFor the non-real time system, we propose a 3D emotion transfer network makes\nuse of a 2D human image to generate a stylized 3D rig parameters. For the real\ntime system, we propose a blendshape adaption network which generates the\ncharacter rig parameter motions with geometric consistency and temporally\nstability. We demonstrate the effectiveness of our system by comparing to a\ncommercial product Faceware. Results reveal that ratings of the recognition,\nintensity, and attractiveness of expressions depicted for animated characters\nvia our systems are statistically higher than Faceware. Our results may be\nimplemented into the animation pipeline, and provide animators with a system\nfor creating the expressions they wish to use more quickly and accurately."}
