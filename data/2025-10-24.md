<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 1]
- [cs.PL](#cs.PL) [Total: 6]
- [cs.GT](#cs.GT) [Total: 2]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [Interactive Hypergraph Visual Analytics for Exploring Large and Complex Image Collections](https://arxiv.org/abs/2510.20050)
*Floris Gisolf,Zeno J. M. H. Geradts,Marcel Worring*

Main category: cs.GR

TL;DR: 提出了一种用于大规模复杂图像集合的超图构建、探索和分析的交互式视觉分析方法。


<details>
  <summary>Details</summary>
Motivation: 传统聚类和分类方法无法有效捕捉复杂图像集合中的重叠关系，特别是当缺乏标记数据或预训练模型时。

Method: 设计了可扩展的超图构建流水线，并融合了空间超图表示、交互式网格和矩阵可视化技术。

Result: 该方法支持用户动态探索和解释关系，有效处理了包含数万张图像的集合。

Conclusion: 交互式视觉分析方法帮助领域专家高效地从大规模图像集合中获取洞察。

Abstract: Analyzing large complex image collections in domains like forensics, accident
investigation, or social media analysis involves interpreting intricate,
overlapping relationships among images. Traditional clustering and
classification methods fail to adequately represent these complex
relationships, particularly when labeled data or suitable pre-trained models
are unavailable. Hypergraphs effectively capture overlapping relationships, but
to translate their complexity into information and insights for domain expert
users visualization is essential. We propose an interactive visual analytics
approach specifically designed for the construction, exploration, and analysis
of hypergraphs on large-scale complex image collections. Our core contributions
include: (1) a scalable pipeline for constructing hypergraphs directly from raw
image data, including a similarity measure to evaluate constructed hypergraphs
against a ground truth, (2) interactive visualization techniques that integrate
spatial hypergraph representations, interactive grids, and matrix
visualizations, enabling users to dynamically explore and interpret
relationships without becoming overwhelmed and disoriented, and (3) practical
insights on how domain experts can effectively use the application, based on
evaluation with real-life image collections. Our results demonstrate that our
visual analytics approach facilitates iterative exploration, enabling domain
experts to efficiently derive insights from image collections containing tens
of thousands of images.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [2] [Prompt Decorators: A Declarative and Composable Syntax for Reasoning, Formatting, and Control in LLMs](https://arxiv.org/abs/2510.19850)
*Mostapha Kalami Heris*

Main category: cs.PL

TL;DR: 该论文提出了一种名为Prompt Decorators的声明性、可组合语法，通过简洁的控制标记（如+++Reasoning）来规范大型语言模型的行为，从而改善推理透明度、降低提示复杂性并标准化模型行为。


<details>
  <summary>Details</summary>
Motivation: 大型语言模型（LLMs）在推理、写作和决策支持工作流中占据核心地位，但用户缺乏对其推理和表达输出的持续控制。现有提示设计依赖冗长的自然语言指令，限制了可重复性、模块化和可解释性。

Method: 论文引入了Prompt Decorators框架，通过定义二十个核心装饰器（分为Cognitive & Generative和Expressive & Systemic两大类），统一语法、作用域模型和确定性处理流程，将任务意图与执行行为解耦。

Result: 使用案例展示了改进的推理透明度、降低的提示复杂性以及跨领域标准化的模型行为。

Conclusion: Prompt Decorators框架为提示设计提供了可重用和可解释的接口，对互操作性、行为一致性和可扩展AI系统的声明性接口发展具有重要意义。

Abstract: Large Language Models (LLMs) are central to reasoning, writing, and
decision-support workflows, yet users lack consistent control over how they
reason and express outputs. Conventional prompt engineering relies on verbose
natural-language instructions, limiting reproducibility, modularity, and
interpretability. This paper introduces Prompt Decorators, a declarative,
composable syntax that governs LLM behavior through compact control tokens such
as +++Reasoning, +++Tone(style=formal), and +++Import(topic="Systems
Thinking"). Each decorator modifies a behavioral dimension, such as reasoning
style, structure, or tone, without changing task content. The framework
formalizes twenty core decorators organized into two functional families
(Cognitive & Generative and Expressive & Systemic), each further decomposed
into subcategories that govern reasoning, interaction, expression, and
session-control. It defines a unified syntax, scoping model, and deterministic
processing pipeline enabling predictable and auditable behavior composition. By
decoupling task intent from execution behavior, Prompt Decorators create a
reusable and interpretable interface for prompt design. Illustrative use cases
demonstrate improved reasoning transparency, reduced prompt complexity, and
standardized model behavior across domains. The paper concludes with
implications for interoperability, behavioral consistency, and the development
of declarative interfaces for scalable AI systems.

</details>


### [3] [A Specification's Realm: Characterizing the Knowledge Required for Executing a Given Algorithm Specification](https://arxiv.org/abs/2510.19853)
*Assaf Marron,David Harel*

Main category: cs.PL

TL;DR: 本文探讨了算法规范在执行前所需的先决知识，提出了“算法规范领域”的概念，并讨论了如何系统化和自动化生成这一领域，以促进算法的多样化实现和形式化验证。


<details>
  <summary>Details</summary>
Motivation: 为了解决算法规范在执行时的不明确性和依赖性，本文旨在定义一个执行代理（人或机器）所需的独立知识体，即“算法规范领域”，以实现规范的清晰性和可执行性。

Method: 本文提出了一种系统分析方法，通过总结语法语义、领域知识、实体关系、因果关系规则和操作指令等，构建算法规范的领域文档，并探讨了利用大语言模型和现有文档自动化生成的可能性。

Result: 结果表明，算法规范领域的清晰定义可以促进算法的多样化实现和形式化验证，同时提出了评估执行忠实性的问题。

Conclusion: 本文强调了算法规范领域的重要性，并展示了其在实现规范独立性和可执行性方面的潜力，同时指出了未来在自动化生成和忠实性评估方面的研究方向。

Abstract: An algorithm specification in natural language or pseudocode is expected to
be clear and explicit enough to enable mechanical execution. In this position
paper we contribute an initial characterization of the knowledge that an
executing agent, human or machine, should possess in order to be able to carry
out the instructions of a given algorithm specification as a stand-alone
entity, independent of any system implementation. We argue that, for that
algorithm specification, such prerequisite knowledge, whether unique or shared
with other specifications, can be summarized in a document of practical size.
We term this document the realm of the algorithm specification. The generation
of such a realm is itself a systematic analytical process, significant parts of
which can be automated with the help of large language models and the reuse of
existing documents. The algorithm-specification's realm would consist of
specification language syntax and semantics, domain knowledge restricted to the
referenced entities, inter-entity relationships, relevant underlying
cause-and-effect rules, and detailed instructions and means for carrying out
certain operations. Such characterization of the realm can contribute to
methodological implementation of the algorithm specification in diverse systems
and to its formalization for mechanical verification. The paper also touches
upon the question of assessing execution faithfulness, which is distinct from
correctness: in the absence of a reference interpretation of natural language
or pseudocode specification with a given vocabulary, how can we determine if an
observed agent's execution indeed complies with the input specification.

</details>


### [4] [Deconstructed Proto-Quipper: A Rational Reconstruction](https://arxiv.org/abs/2510.20018)
*Ryan Kavanagh,Chuta Sano,Brigitte Pientka*

Main category: cs.PL

TL;DR: Proto-Quipper-A是一种针对静态电路生成的Proto-Quipper语言的理性重构，旨在简化量子编程语言的操作语义和推理难度。


<details>
  <summary>Details</summary>
Motivation: Proto-Quipper语言的操作语义复杂，依赖集合论操作和新名称生成，难以用标准编程语言技术推理和机械化。Proto-Quipper-A旨在提供更简单的语义基础。

Method: Proto-Quipper-A使用线性$\lambda$-演算描述量子电路，其范式与盒线电路图紧密对应，并结合线性/非线性功能语言。通过伴随逻辑操作重构Proto-Quipper的电路编程抽象。

Result: Proto-Quipper-A具有简单的按值调用缩减语义，并通过规范化的证明展示了其作为Proto-Quipper语言基础的易处理性。

Conclusion: Proto-Quipper-A为Proto-Quipper语言提供了更简单的语义基础，并通过标准逻辑关系证明了其线性系统的规范性，避免了现有线性逻辑关系的复杂性。

Abstract: The Proto-Quipper family of programming languages aims to provide a formal
foundation for the Quipper quantum programming language. Unfortunately,
Proto-Quipper languages have complex operational semantics: they are inherently
effectful, and they rely on set-theoretic operations and fresh name generation
to manipulate quantum circuits. This makes them difficult to reason about using
standard programming language techniques and, ultimately, to mechanize. We
introduce Proto-Quipper-A, a rational reconstruction of Proto-Quipper languages
for static circuit generation. It uses a linear $\lambda$-calculus to describe
quantum circuits with normal forms that closely correspond to box-and-wire
circuit diagrams. Adjoint-logical foundations integrate this circuit language
with a linear/non-linear functional language and let us reconstruct
Proto-Quipper's circuit programming abstractions using more primitive
adjoint-logical operations. Proto-Quipper-A enjoys a simple call-by-value
reduction semantics, and to illustrate its tractability as a foundation for
Proto-Quipper languages, we show that it is normalizing. We show how to use
standard logical relations to prove normalization of linear and substructural
systems, thereby avoiding the inherent complexity of existing linear logical
relations.

</details>


### [5] [Deciding not to Decide: Sound and Complete Effect Inference in the Presence of Higher-Rank Polymorphism](https://arxiv.org/abs/2510.20532)
*Patrycja Balik,Szymon Jędras,Piotr Polesiuk*

Main category: cs.PL

TL;DR: 本文提出了一种针对类型与效应系统的效应推断算法，支持子类型化、高阶多态性和直观的类集合效应语义，并通过将效应约束转化为命题逻辑公式来解决高阶多态的域问题。


<details>
  <summary>Details</summary>
Motivation: 类型与效应系统有助于程序员组织程序中的数据和计算效应，但由于其复杂性和现有推断算法在表现力、直观性和可判定性之间的妥协，并未广泛采用。

Method: 本文提出了一种效应推断算法，通过将效应约束转化为命题逻辑公式，并延迟求解以处理高阶多态的域问题。

Result: 算法在Rocq证明助手中进行了形式化验证，并已在一个现实的编程语言中成功实现。

Conclusion: 该算法在保持表现力和直观性的同时，解决了高阶多态中的效应推断问题，为类型与效应系统的广泛应用提供了可能性。

Abstract: Type-and-effect systems help the programmer to organize data and
computational effects in a program. While for traditional type systems
expressive variants with sophisticated inference algorithms have been developed
and widely used in programming languages, type-and-effect systems did not yet
gain widespread adoption. One reason for this is that type-and-effect systems
are more complex and the existing inference algorithms make compromises between
expressiveness, intuitiveness, and decidability. In this work, we present an
effect inference algorithm for a type-and-effect system with subtyping,
expressive higher-rank polymorphism, and intuitive set-like semantics of
effects. In order to deal with scoping issues of higher-rank polymorphism, we
delay solving of effect constraints by transforming them into formulae of
propositional logic. We prove soundness and completeness of our algorithm with
respect to a declarative type-and-effect system. All the presented results have
been formalized in the Rocq proof assistant, and the algorithm has been
successfully implemented in a realistic programming language.

</details>


### [6] [Compiling the Mimosa programming language to RTOS tasks](https://arxiv.org/abs/2510.20547)
*Nikolaus Huber,Susanne Graf,Philipp Rümmer,Wang Yi*

Main category: cs.PL

TL;DR: 本文介绍了基于MIMOS计算模型的Mimosa编程语言的编译方案，将嵌入式系统软件描述为一组通过FIFO队列通信的时间触发进程。


<details>
  <summary>Details</summary>
Motivation: 旨在为Mimosa编程语言提供一个正式的编译方案，并解决嵌入式系统中时间触发进程的协调问题。

Method: 借鉴了Lustre编译方案，并将其适配到Mimosa语义中，同时展示了如何将协调层映射到实时操作系统原语。

Result: 提供了一个正式的编译方案，并能有效地将Mimosa程序映射到实时操作系统原语。

Conclusion: 该方法为Mimosa语言提供了高效的编译支持，适用于嵌入式系统的实时性和协调需求。

Abstract: This paper introduces a compilation scheme for programs written in the Mimosa
programming language, which builds upon the MIMOS model of computation. Mimosa
describes embedded systems software as a collection of time-triggered processes
which communicate through FIFO queues. We formally describe an adaptation of
the Lustre compilation scheme to the semantics of Mimosa and show how the
coordination layer can be mapped to real-time operating system primitives.

</details>


### [7] [SafeFFI: Efficient Sanitization at the Boundary Between Safe and Unsafe Code in Rust and Mixed-Language Applications](https://arxiv.org/abs/2510.20688)
*Oliver Braunsdorf,Tim Lange,Konrad Hohentanner,Julian Horsch,Johannes Kinder*

Main category: cs.PL

TL;DR: SafeFFI是一个优化Rust二进制文件中内存安全检测的系统，通过在unsafe和safe代码边界插入检查，显著减少运行时检测的开销，同时保持正确性。


<details>
  <summary>Details</summary>
Motivation: Rust中的unsafe代码虽然必要，但可能导致内存安全问题。现有的sanitizer工具虽然能捕获错误，但引入了大量不必要的检查，影响性能。

Method: SafeFFI通过在unsafe和safe代码边界插入内存安全检查，将内存安全的强制执行交给Rust类型系统，避免昂贵的全程序分析和减少编译开销。

Result: 在流行的Rust库和已知易受攻击的代码上，SafeFFI显著减少了sanitizer检查（高达98%），同时保持了正确性并捕获所有时空内存安全问题。

Conclusion: SafeFFI是一种高性能的内存安全检测系统，优于现有技术，适用于需要unsafe代码的场景。

Abstract: Unsafe Rust code is necessary for interoperability with C/C++ libraries and
implementing low-level data structures, but it can cause memory safety
violations in otherwise memory-safe Rust programs. Sanitizers can catch such
memory errors at runtime, but introduce many unnecessary checks even for memory
accesses guaranteed safe by the Rust type system. We introduce SafeFFI, a
system for optimizing memory safety instrumentation in Rust binaries such that
checks occur at the boundary between unsafe and safe code, handing over the
enforcement of memory safety from the sanitizer to the Rust type system. Unlike
previous approaches, our design avoids expensive whole-program analysis and
adds much less compile-time overhead (2.64x compared to over 8.83x). On a
collection of popular Rust crates and known vulnerable Rust code, SafeFFI
achieves superior performance compared to state-of-the-art systems, reducing
sanitizer checks by up to 98%, while maintaining correctness and flagging all
spatial and temporal memory safety violations.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [8] [Optimized Distortion in Linear Social Choice](https://arxiv.org/abs/2510.20020)
*Luise Ge,Gregory Kehne,Yevgeniy Vorobeychik*

Main category: cs.GT

TL;DR: 该论文首次研究了线性效用函数的失真问题，分析了确定性和随机投票规则的失真，并提出了多项式时间实例最优算法以减少失真。


<details>
  <summary>Details</summary>
Motivation: 现有的偏好排序方法可能导致次优结果，特别是在候选者可以表示为向量且效用为参数化函数的场景下，如推荐系统和意见调查。

Method: 论文研究了确定性和随机投票规则的线性社会选择的失真，并引入了多项式时间实例最优算法来最小化失真。

Result: 研究得出了仅依赖于候选嵌入维度的失真界限，与候选者或选民的数量无关，并在推荐系统和意见调查中进行了实证评估。

Conclusion: 论文表明，在候选者嵌入的场景下，线性效用函数的失真可以通过多项式时间算法有效优化，优于传统的投票规则。

Abstract: Social choice theory offers a wealth of approaches for selecting a candidate
on behalf of voters based on their reported preference rankings over options.
When voters have underlying utilities for these options, however, using
preference rankings may lead to suboptimal outcomes vis-\`a-vis utilitarian
social welfare. Distortion is a measure of this suboptimality, and provides a
worst-case approach for developing and analyzing voting rules when utilities
have minimal structure. However in many settings, such as common paradigms for
value alignment, alternatives admit a vector representation, and it is natural
to suppose that utilities are parametric functions thereof. We undertake the
first study of distortion for linear utility functions. Specifically, we
investigate the distortion of linear social choice for deterministic and
randomized voting rules. We obtain bounds that depend only on the dimension of
the candidate embedding, and are independent of the numbers of candidates or
voters. Additionally, we introduce poly-time instance-optimal algorithms for
minimizing distortion given a collection of candidates and votes. We
empirically evaluate these in two real-world domains: recommendation systems
using collaborative filtering embeddings, and opinion surveys utilizing
language model embeddings, benchmarking several standard rules against our
instance-optimal algorithms.

</details>


### [9] [Strategic Costs of Perceived Bias in Fair Selection](https://arxiv.org/abs/2510.20606)
*L. Elisa Celis,Lingxiao Huang,Milind Sohoni,Nisheeth K. Vishnoi*

Main category: cs.GT

TL;DR: 本文通过博弈论模型分析了不同社会经济群体在公平选拔系统中的努力选择和成就差异，揭示了感知驱动的偏见如何在不公平的环境下传播。


<details>
  <summary>Details</summary>
Motivation: 研究旨在解释为什么在看似公平的选拔系统中，种族、性别和阶级间的差距依然存在，揭示感知差异如何影响个体的战略选择。

Method: 作者构建了一个博弈论模型，描述候选人基于成本和预期回报的战略性努力选择，并通过纳什均衡分析群体的表现差异。

Result: 研究发现感知差异会导致合理的努力选择差异，从而在不公平的环境中传播差距；同时提出了成本敏感的优化框架以减少不平等。

Conclusion: 研究表明，技术社会环境通过塑造个体激励机制，连接了理性选择和结构性不平等之间的鸿沟，为减少差距提供了理论支持。

Abstract: Meritocratic systems, from admissions to hiring, aim to impartially reward
skill and effort. Yet persistent disparities across race, gender, and class
challenge this ideal. Some attribute these gaps to structural inequality;
others to individual choice. We develop a game-theoretic model in which
candidates from different socioeconomic groups differ in their perceived
post-selection value--shaped by social context and, increasingly, by AI-powered
tools offering personalized career or salary guidance. Each candidate
strategically chooses effort, balancing its cost against expected reward;
effort translates into observable merit, and selection is based solely on
merit. We characterize the unique Nash equilibrium in the large-agent limit and
derive explicit formulas showing how valuation disparities and institutional
selectivity jointly determine effort, representation, social welfare, and
utility. We further propose a cost-sensitive optimization framework that
quantifies how modifying selectivity or perceived value can reduce disparities
without compromising institutional goals. Our analysis reveals a
perception-driven bias: when perceptions of post-selection value differ across
groups, these differences translate into rational differences in effort,
propagating disparities backward through otherwise "fair" selection processes.
While the model is static, it captures one stage of a broader feedback cycle
linking perceptions, incentives, and outcome--bridging rational-choice and
structural explanations of inequality by showing how techno-social environments
shape individual incentives in meritocratic systems.

</details>
