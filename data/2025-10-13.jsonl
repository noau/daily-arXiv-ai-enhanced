{"id": "2510.08742", "categories": ["cs.GT"], "pdf": "https://arxiv.org/pdf/2510.08742", "abs": "https://arxiv.org/abs/2510.08742", "authors": ["Amir Ban"], "title": "Unending Sequential Auctions", "comment": "Accepted to WINE 2025", "summary": "Sequential auctions for identical items with unit-demand, private-value\nbuyers are common and often occur periodically without end, as new bidders\nreplace departing ones. We model bidder uncertainty by introducing a\nprobability that a bidder must exit the auction in each period. Treating the\nsequential auction as a Markov process, we demonstrate the existence of a\nunique steady state.\n  In the absence of uncertainty, the steady state resembles a posted-price\nmechanism: bidders with values above a threshold almost surely win items by\nrepeatedly bidding the threshold price, while those below the threshold almost\nsurely do not. The equilibrium price corresponds to the threshold value that\nbalances supply (bidders with values above the threshold) and demand (auction\nwinners).\n  When uncertainty is introduced, the threshold value persists but becomes less\nprecise, growing \"fuzzier\" as uncertainty increases. This uncertainty benefits\nlow-value bidders, those below the threshold, by giving them a significant\nchance of winning. Surprisingly, high-value bidders also benefit from\nuncertainty, up to a certain value limit, as it lowers equilibrium bids and\nincreases their expected utility. On the other hand, this bidder uncertainty\noften reduces the auctioneer's utility."}
{"id": "2510.08788", "categories": ["cs.GT", "math.OC"], "pdf": "https://arxiv.org/pdf/2510.08788", "abs": "https://arxiv.org/abs/2510.08788", "authors": ["Andrey Pudovikov", "Alexandra Khirianova", "Ekaterina Solodneva", "Gleb Molodtsov", "Aleksandr Katrutsa", "Yuriy Dorn", "Egor Samosvat"], "title": "Robust autobidding for noisy conversion prediction models", "comment": null, "summary": "Managing millions of digital auctions is an essential task for modern\nadvertising auction systems. The main approach to managing digital auctions is\nan autobidding approach, which depends on the Click-Through Rate and Conversion\nRate values. While these quantities are estimated with ML models, their\nprediction uncertainty directly impacts advertisers' revenue and bidding\nstrategies. To address this issue, we propose RobustBid, an efficient method\nfor robust autobidding taking into account uncertainty in CTR and CVR\npredictions. Our approach leverages advanced, robust optimization techniques to\nprevent large errors in bids if the estimates of CTR/CVR are perturbed. We\nderive the analytical solution of the stated robust optimization problem, which\nleads to the runtime efficiency of the RobustBid method. The synthetic,\niPinYou, and BAT benchmarks are used in our experimental evaluation of\nRobustBid. We compare our method with the non-robust baseline and the RiskBid\nalgorithm in terms of total conversion volume (TCV) and average cost-per-click\n($CPC_{avg}$) performance metrics. The experiments demonstrate that RobustBid\nprovides bids that yield larger TCV and smaller $CPC_{avg}$ than competitors in\nthe case of large perturbations in CTR/CVR predictions."}
{"id": "2510.08869", "categories": ["cs.GT"], "pdf": "https://arxiv.org/pdf/2510.08869", "abs": "https://arxiv.org/abs/2510.08869", "authors": ["Patrick Mesana", "Gilles Caporossi", "Sebastien Gambs"], "title": "Measuring the Hidden Cost of Data Valuation through Collective Disclosure", "comment": null, "summary": "Data valuation methods assign marginal utility to each data point that has\ncontributed to the training of a machine learning model. If used directly as a\npayout mechanism, this creates a hidden cost of valuation, in which\ncontributors with near-zero marginal value would receive nothing, even though\ntheir data had to be collected and assessed. To better formalize this cost, we\nintroduce a conceptual and game-theoretic model, the Information Disclosure\nGame, between a Data Union (sometimes also called a data trust), a member-run\nagent representing contributors, and a Data Consumer (e.g., a platform). After\nfirst aggregating members' data, the DU releases information progressively by\nadding Laplacian noise under a differentially-private mechanism. Through\nsimulations with strategies guided by data Shapley values and multi-armed\nbandit exploration, we demonstrate on a Yelp review helpfulness prediction task\nthat data valuation inherently incurs an explicit acquisition cost and that the\nDU's collective disclosure policy changes how this cost is distributed across\nmembers."}
{"id": "2510.09084", "categories": ["cs.GT", "cs.DB", "cs.DS"], "pdf": "https://arxiv.org/pdf/2510.09084", "abs": "https://arxiv.org/abs/2510.09084", "authors": ["Dildar Ali", "Suman Benerjee", "Yamuna Prasad"], "title": "Approximately Bisubmodular Regret Minimization in Billboard and Social Media Advertising", "comment": "12 Pages", "summary": "In a typical \\emph{billboard advertisement} technique, a number of digital\nbillboards are owned by an \\emph{influence provider}, and several commercial\nhouses approach the influence provider for a specific number of views of their\nadvertisement content on a payment basis. If the influence provider provides\nthe demanded or more influence, then he will receive the full payment else a\npartial payment. In the context of an influence provider, if he provides more\nor less than the advertisers demanded influence, it is a loss for him. This is\nformalized as 'Regret', and naturally, in the context of the influence\nprovider, the goal will be to allocate the billboard slots among the\nadvertisers such that the total regret is minimized. In this paper, we study\nthis problem as a discrete optimization problem and propose two solution\napproaches. The first one selects the billboard slots from the available ones\nin an incremental greedy manner, and we call this method the Budget Effective\nGreedy approach. In the second one, we introduce randomness in the first one,\nwhere we do it for a sample of slots instead of calculating the marginal gains\nof all the billboard slots. We analyze both algorithms to understand their time\nand space complexity. We implement them with real-life datasets and conduct a\nnumber of experiments. We observe that the randomized budget effective greedy\napproach takes reasonable computational time while minimizing the regret."}
{"id": "2510.08645", "categories": ["cs.GR", "cs.CV"], "pdf": "https://arxiv.org/pdf/2510.08645", "abs": "https://arxiv.org/abs/2510.08645", "authors": ["Xunyang Zhu", "Hongfei Ye", "Yifei Wang", "Taoran Liu", "Jianjun Chen"], "title": "Generating Sizing Fields for Mesh Generation via GCN-based Simplification of Adaptive Background Grids", "comment": "28 pages, 9 figures, 2 tables", "summary": "The sizing field defined on a triangular background grid is pivotal for\ncontrolling the quality and efficiency of unstructured mesh generation.\nHowever, creating an optimal background grid that is geometrically conforming,\ncomputationally lightweight, and free from artifacts like banding is a\nsignificant challenge. This paper introduces a novel, adaptive background grid\nsimplification (ABGS) framework based on a Graph Convolutional Network (GCN).\nWe reformulate the grid simplification task as an edge score regression problem\nand train a GCN model to efficiently predict optimal edge collapse candidates.\nThe model is guided by a custom loss function that holistically considers both\ngeometric fidelity and sizing field accuracy. This data-driven approach\nreplaces a costly procedural evaluation, accelerating the simplification\nprocess. Experimental results demonstrate the effectiveness of our framework\nacross diverse and complex engineering models. Compared to the initial dense\ngrids, our simplified background grids achieve an element reduction of 74%-94%,\nleading to a 35%-88% decrease in sizing field query times."}
{"id": "2510.08726", "categories": ["cs.PL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.08726", "abs": "https://arxiv.org/abs/2510.08726", "authors": ["Yifan Zhao", "Egan Johnson", "Prasanth Chatarasi", "Vikram Adve", "Sasa Misailovic"], "title": "Neptune: Advanced ML Operator Fusion for Locality and Parallelism on GPUs", "comment": null, "summary": "Operator fusion has become a key optimization for deep learning, which\ncombines multiple deep learning operators to improve data reuse and reduce\nglobal memory transfers. However, existing tensor compilers struggle to fuse\ncomplex reduction computations involving loop-carried dependencies, such as\nattention mechanisms.\n  The paper introduces Neptune, a tensor compiler for advanced operator fusion\nfor sequences of reduction operators. Neptune presents a new approach for\nadvanced operator fusion, which intentionally breaks some existing dependencies\nand compensates by constructing algebraic correction expressions that allow the\nkernel to produce the correct result.\n  On ten attention-based benchmarks, Neptune, starting from simple attention\ncode and a high-level scheduling template, outperforms existing compilers like\nTriton, TVM, and FlexAttention, including Triton-based implementations of\nFlashAttention. Across four different GPU architectures from NVIDIA and AMD,\nNeptune-generated kernels have average speedup of $1.35\\times$ over the next\nbest alternative, demonstrating its effectiveness for deep learning workloads."}
{"id": "2510.08656", "categories": ["cs.GR", "cs.AI", "cs.CV"], "pdf": "https://arxiv.org/pdf/2510.08656", "abs": "https://arxiv.org/abs/2510.08656", "authors": ["Yiming Liang", "Huan Yu", "Zili Wang", "Shuyou Zhang", "Guodong Yi", "Jin Wang", "Jianrong Tan"], "title": "A 3D Generation Framework from Cross Modality to Parameterized Primitive", "comment": null, "summary": "Recent advancements in AI-driven 3D model generation have leveraged cross\nmodality, yet generating models with smooth surfaces and minimizing storage\noverhead remain challenges. This paper introduces a novel multi-stage framework\nfor generating 3D models composed of parameterized primitives, guided by\ntextual and image inputs. In the framework, A model generation algorithm based\non parameterized primitives, is proposed, which can identifies the shape\nfeatures of the model constituent elements, and replace the elements with\nparameterized primitives with high quality surface. In addition, a\ncorresponding model storage method is proposed, it can ensure the original\nsurface quality of the model, while retaining only the parameters of\nparameterized primitives. Experiments on virtual scene dataset and real scene\ndataset demonstrate the effectiveness of our method, achieving a Chamfer\nDistance of 0.003092, a VIoU of 0.545, a F1-Score of 0.9139 and a NC of 0.8369,\nwith primitive parameter files approximately 6KB in size. Our approach is\nparticularly suitable for rapid prototyping of simple models."}
{"id": "2510.08889", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.08889", "abs": "https://arxiv.org/abs/2510.08889", "authors": ["Songlin Jia", "Craig Liu", "Siyuan He", "Haotian Deng", "Yuyan Bao", "Tiark Rompf"], "title": "Typestate via Revocable Capabilities", "comment": null, "summary": "Managing stateful resources safely and expressively is a longstanding\nchallenge in programming languages, especially in the presence of aliasing.\nWhile scope-based constructs such as Java's synchronized blocks offer ease of\nreasoning, they restrict expressiveness and parallelism. Conversely,\nimperative, flow-sensitive management enables fine-grained control but demands\nsophisticated typestate analyses and often burdens programmers with explicit\nstate tracking.\n  In this work, we present a novel approach that unifies the strengths of both\nparadigms by extending flow-insensitive capability mechanisms into\nflow-sensitive typestate tracking. Our system decouples capability lifetimes\nfrom lexical scopes, allowing functions to provide, revoke, and return\ncapabilities in a flow-sensitive manner, based on the existing mechanisms\nexplored for the safety and ergonomics of scoped capability programming.\n  We implement our approach as an extension to the Scala 3 compiler, leveraging\npath-dependent types and implicit resolution to enable concise, statically\nsafe, and expressive typestate programming. Our prototype generically supports\na wide range of stateful patterns, including file operations, advanced locking\nprotocols, DOM construction, and session types. This work demonstrates that\nexpressive and safe typestate management can be achieved with minimal\nextensions to existing capability-based languages, paving the way for more\nrobust and ergonomic stateful programming."}
{"id": "2510.09078", "categories": ["cs.GR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.09078", "abs": "https://arxiv.org/abs/2510.09078", "authors": ["Gurprit Singh", "Wenzel Jakob"], "title": "MCMC: Bridging Rendering, Optimization and Generative AI", "comment": "SIGGRAPH Asia 2024 Courses. arXiv admin note: text overlap with\n  arXiv:2208.11970 by other authors", "summary": "Generative artificial intelligence (AI) has made unprecedented advances in\nvision language models over the past two years. During the generative process,\nnew samples (images) are generated from an unknown high-dimensional\ndistribution. Markov Chain Monte Carlo (MCMC) methods are particularly\neffective in drawing samples from such complex, high-dimensional distributions.\nThis makes MCMC methods an integral component for models like EBMs, ensuring\naccurate sample generation.\n  Gradient-based optimization is at the core of modern generative models. The\nupdate step during the optimization forms a Markov chain where the new update\ndepends only on the current state. This allows exploration of the parameter\nspace in a memoryless manner, thus combining the benefits of gradient-based\noptimization and MCMC sampling. MCMC methods have shown an equally important\nrole in physically based rendering where complex light paths are otherwise\nquite challenging to sample from simple importance sampling techniques.\n  A lot of research is dedicated towards bringing physical realism to samples\n(images) generated from diffusion-based generative models in a data-driven\nmanner, however, a unified framework connecting these techniques is still\nmissing. In this course, we take the first steps toward understanding each of\nthese components and exploring how MCMC could potentially serve as a bridge,\nlinking these closely related areas of research. Our course aims to provide\nnecessary theoretical and practical tools to guide students, researchers and\npractitioners towards the common goal of generative physically based rendering.\nAll Jupyter notebooks with demonstrations associated to this tutorial can be\nfound on the project webpage: https://sinbag.github.io/mcmc/"}
{"id": "2510.08939", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.08939", "abs": "https://arxiv.org/abs/2510.08939", "authors": ["Haotian Deng", "Siyuan He", "Songlin Jia", "Yuyan Bao", "Tiark Rompf"], "title": "Free to Move: Reachability Types with Flow-Sensitive Effects for Safe Deallocation and Ownership Transfer", "comment": null, "summary": "We present a flow-sensitive effect system for reachability types that\nsupports explicit memory management, including Rust-style move semantics, in\nhigher-order impure functional languages. Our system refines the existing\nreachability qualifier with polymorphic \\emph{use} and \\emph{kill} effects that\nrecord how references are read, written, transferred, and deallocated. The\neffect discipline tracks operations performed on each resource using\nqualifiers, enabling the type system to express ownership transfer, contextual\nfreshness, and destructive updates without regions or linearity. We formalize\nthe calculus, its typing and effect rules, and a compositional operational\nsemantics that validates use-after-free safety. All metatheoretic results,\nincluding preservation, progress, and effect soundness, are mechanized. The\nsystem models idioms such as reference deallocation, move semantics, reference\nswapping, while exposing precise safety guarantee. Together, these\ncontributions integrate reachability-based reasoning with explicit resource\ncontrol, advancing the state of the art in safe manual memory management for\nhigher-order functional languages."}
{"id": "2510.09081", "categories": ["cs.GR"], "pdf": "https://arxiv.org/pdf/2510.09081", "abs": "https://arxiv.org/abs/2510.09081", "authors": ["Bram Kraaijeveld", "Andrei C. Jalba", "Anna Vilanova", "Maxime Chamberland"], "title": "Real-Time Rendering of Dynamic Line Sets using Voxel Ray Tracing", "comment": null, "summary": "Real-time rendering of dynamic line sets is relevant in many visualization\ntasks, including unsteady flow visualization and interactive white matter\nreconstruction from Magnetic Resonance Imaging. High-quality global\nillumination and transparency are important for conveying the spatial structure\nof dense line sets, yet remain difficult to achieve at interactive rates. We\npropose an efficient voxel-based ray-tracing framework for rendering large\ndynamic line sets with ambient occlusion and ground-truth transparency. The\nframework introduces a voxelization algorithm that supports efficient\nconstruction of acceleration structures for both voxel cone tracing and ray\ntracing. To further reduce per-frame preprocessing cost, we developed a\nvoxel-based culling method that restricts acceleration structure construction\nto camera-visible voxels. Together, these contributions enable high-quality,\nreal-time rendering of large-scale dynamic line sets with physically accurate\ntransparency. The results show that our method outperforms the state of the art\nin quality and performance when rendering (semi-)opaque dynamic line sets."}
{"id": "2510.08969", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2510.08969", "abs": "https://arxiv.org/abs/2510.08969", "authors": ["Bjarne Stroustrup"], "title": "Concept-Based Generic Programming in C++", "comment": null, "summary": "We present programming techniques to illustrate the facilities and principles\nof C++ generic programming using concepts. Concepts are C++'s way to express\nconstraints on generic code. As an initial example, we provide a simple type\nsystem that eliminates narrowing conversions and provides range checking\nwithout unnecessary notational or run-time overheads. Concepts are used\nthroughout to provide user-defined extensions to the type system. The aim is to\nshow their utility and the fundamental ideas behind them, rather than to\nprovide a detailed or complete explanation of C++'s language support for\ngeneric programming or the extensive support provided by the standard library.\nGeneric programming is an integral part of C++, rather than an isolated\nsub-language. In particular, key facilities support general programming as well\nas generic programming (e.g., uniform notation for types, lambdas, variadic\ntemplates, and C++26 static reflection). Finally, we give design rationales and\norigins for key parts of the concept design, including use patterns, the\nrelationship to Object-Oriented Programming, value arguments, notation, concept\ntype-matching, and definition checking."}
{"id": "2510.09489", "categories": ["cs.GR"], "pdf": "https://arxiv.org/pdf/2510.09489", "abs": "https://arxiv.org/abs/2510.09489", "authors": ["Deborah Pintani", "Ariel Caputo", "Noah Lewis", "Marc Stamminger", "Fabio Pellacini", "Andrea Giachetti"], "title": "Two-Stage Gaussian Splatting Optimization for Outdoor Scene Reconstruction", "comment": null, "summary": "Outdoor scene reconstruction remains challenging due to the stark contrast\nbetween well-textured, nearby regions and distant backgrounds dominated by low\ndetail, uneven illumination, and sky effects. We introduce a two-stage Gaussian\nSplatting framework that explicitly separates and optimizes these regions,\nyielding higher-fidelity novel view synthesis. In stage one, background\nprimitives are initialized within a spherical shell and optimized using a loss\nthat combines a background-only photometric term with two geometric\nregularizers: one constraining Gaussians to remain inside the shell, and\nanother aligning them with local tangential planes. In stage two, foreground\nGaussians are initialized from a Structure-from-Motion reconstruction, added\nand refined using the standard rendering loss, while the background set remains\nfixed but contributes to the final image formation. Experiments on diverse\noutdoor datasets show that our method reduces background artifacts and improves\nperceptual quality compared to state-of-the-art baselines. Moreover, the\nexplicit background separation enables automatic, object-free environment map\nestimation, opening new possibilities for photorealistic outdoor rendering and\nmixed-reality applications."}
{"id": "2510.09591", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.09591", "abs": "https://arxiv.org/abs/2510.09591", "authors": ["Saad Ahmed Bazaz", "Mirza Omer Beg"], "title": "A Multilingual Python Programming Language", "comment": "For project homepage, see https://universalpython.github.io/", "summary": "All widely used and useful programming languages have a common problem. They\nrestrict entry on the basis of knowledge of the English language. The lack of\nknowledge of English poses a major hurdle to many newcomers who do not have the\nresources, in terms of time and money, to learn the English language. Studies\nshow that people learn better in their own language. Therefore, we propose a\nlanguage transpiler built on top of the Python programming language, called\nUniversalPython, which allows one to write Python in their own human language.\nWe demonstrate the ability to create an \"Urdu Python\" with this transpiler. In\nthe future, we aim to scale the language to encapsulate more human languages to\nincrease the availability of programming. The source code for this transpiler\nis open-source, and available at\nhttps://github.com/universalpython/universalpython"}
