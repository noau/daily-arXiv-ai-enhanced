<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 2]
- [cs.PL](#cs.PL) [Total: 3]
- [cs.GT](#cs.GT) [Total: 5]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [Fuse3D: Generating 3D Assets Controlled by Multi-Image Fusion](https://arxiv.org/abs/2602.17040)
*Xuancheng Jin,Rengan Xie,Wenting Zheng,Rui Wang,Hujun Bao,Yuchi Huo*

Main category: cs.GR

TL;DR: Fuse3D是一种新方法，能够通过多张条件图像生成3D资产，实现从全局视角到局部细节的多层次区域控制。


<details>
  <summary>Details</summary>
Motivation: 现有3D生成方法仅能处理单一控制目标，无法利用多张图像独立控制3D资产的不同区域，限制了应用的灵活性。

Method: Fuse3D引入了多条件融合模块整合多图像区域的视觉特征，自动对齐2D图像区域与3D区域的语义线索，并通过局部注意力增强策略解决控制冲突。

Result: 实验表明，Fuse3D能够灵活地将多个2D图像区域融合为连贯的3D结构，生成高质量的3D资产。

Conclusion: Fuse3D是首个能够从多张条件图像可控生成3D资产的方法，显著提升了3D生成的灵活性和质量。

Abstract: Recently, generating 3D assets with the control of condition images has achieved impressive quality. However, existing 3D generation methods are limited to handling a single control objective and lack the ability to utilize multiple images to independently control different regions of a 3D asset, which hinders their flexibility in applications. We propose Fuse3D, a novel method that enables generating 3D assets under the control of multiple images, allowing for the seamless fusion of multi-level regional controls from global views to intricate local details. First, we introduce a Multi-Condition Fusion Module to integrate the visual features from multiple image regions. Then, we propose a method to automatically align user-selected 2D image regions with their associated 3D regions based on semantic cues. Finally, to resolve control conflicts and enhance local control features from multi-condition images, we introduce a Local Attention Enhancement Strategy that flexibly balances region-specific feature fusion. Overall, we introduce the first method capable of controllable 3D asset generation from multiple condition images. The experimental results indicate that Fuse3D can flexibly fuse multiple 2D image regions into coherent 3D structures, resulting in high-quality 3D assets. Code and data for this paper are at https://jinnmnm.github.io/Fuse3d.github.io/.

</details>


### [2] [InstantRetouch: Personalized Image Retouching without Test-time Fine-tuning Using an Asymmetric Auto-Encoder](https://arxiv.org/abs/2602.17044)
*Temesgen Muruts Weldengus,Binnan Liu,Fei Kou,Youwei Lyu,Jinwei Chen,Qingnan Fan,Changqing Zou*

Main category: cs.GR

TL;DR: InstantRetouch是一个无需测试时微调即可个性化图像修饰的框架，通过非对称自编码器和检索增强修饰技术实现内容感知的风格迁移。


<details>
  <summary>Details</summary>
Motivation: 现有个性化图像修饰方法需要用户特定的微调或泛化效果不佳，因此作者提出了一种无需微调的通用框架。

Method: 使用非对称自编码器编码修饰风格为解耦的潜在表示，并通过检索增强修饰技术自适应地将风格应用到新图像。

Result: InstantRetouch在单参考、多参考和混合风格场景下实现了优异的个性化修饰效果，并能泛化到照片风格迁移任务。

Conclusion: 该框架为个性化图像修饰提供了一种高效且通用的解决方案，无需测试时微调即可适应多样化的修饰风格。

Abstract: Personalized image retouching aims to adapt retouching style of individual users from reference examples, but existing methods often require user-specific fine-tuning or fail to generalize effectively. To address these challenges, we introduce $\textbf{InstantRetouch}$, a general framework for personalized image retouching that instantly adapts to user retouching styles without any test-time fine-tuning. It employs an $\textit{asymmetric auto-encoder}$ to encode the retouching style from paired examples into a content disentangled latent representation that enables faithful transfer of the retouching style to new images. To adaptively apply the encoded retouching style to new images, we further propose $\textit{retrieval-augmented retouching}$ (RAR), which retrieves and aggregates style latents from reference pairs most similar in content to the query image. With these components, $\textbf{InstantRetouch}$ enables superior and generic content-aware retouching personalization across diverse scenarios, including single-reference, multi-reference, and mixed-style setups, while also generalizing out of the box to photorealistic style transfer.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [3] [Haskell meets Evariste](https://arxiv.org/abs/2602.16809)
*Paulo R. Pereira,Jose N. Oliveira*

Main category: cs.PL

TL;DR: 该论文探讨了通过一种称为easy-hard-split的策略来提升Haskell函数的文档质量和设计清晰度。


<details>
  <summary>Details</summary>
Motivation: 编程是一项复杂且容易出错的任务，高质量的文档对代码重用和生产力至关重要。然而，现有软件库的文档质量参差不齐。

Method: 作者以Hackage库中的Haskell函数为例，将其与其他语言的类似函数进行比较，并应用easy-hard-split策略来提升文档和设计的清晰度。

Result: 研究表明，easy-hard-split策略不仅易于在函数式编程中使用，还能有效提升程序分析和合成的质量。

Conclusion: 通过easy-hard-split策略，可以在提升文档质量的同时，增强代码的可读性和重用性。

Abstract: Since its birth as a new scientific body of knowledge in the late 1950s, computer programming has become a fundamental skill needed in many other disciplines. However, programming is not easy, it is prone to errors and code re-use is key for productivity. This calls for high-quality documentation in software libraries, which is quite often not the case. Taking a few Haskell functions available from the Hackage repository as case-studies, and comparing their descriptions with similar functions in other languages, this paper shows how clarity and good conceptual design can be achieved by following a so-called easy-hard-split formal strategy that is quite general and productive, even if used informally. This strategy is easy to use in functional programming and can be applied to both program analysis and synthesis.

</details>


### [4] [A Reversible Semantics for Janus](https://arxiv.org/abs/2602.16913)
*Ivan Lanese,Germán Vidal*

Main category: cs.PL

TL;DR: Janus是一种可逆编程语言的典范，但其小步语义在正向计算时会丢失信息，无法满足可逆性的关键属性—循环引理。本文提出了一种新型的小步语义，既保留了等效性，又真正实现了可逆性。


<details>
  <summary>Details</summary>
Motivation: Janus作为一种可逆编程语言，其小步语义在正向计算时会丢失信息，无法满足可逆性的关键属性（如循环引理）。这限制了它在调试或扩展并发原语等方面的应用。

Method: 本文提出了一种新型的小步语义，通过基于“程序计数器”的定义来解决高抽象级别编程语言中的可逆性问题。

Result: 新型小步语义不仅保留了与原语义的等效性，还真正实现了可逆性，满足了如循环引理等关键属性。

Conclusion: 该研究成功解决了Janus小步语义的可逆性问题，为高抽象级别编程语言的可逆语义设计提供了新思路。

Abstract: Janus is a paradigmatic example of reversible programming language. Indeed, Janus programs can be executed backwards as well as forwards. However, its small-step semantics (useful, e.g., for debugging or as a basis for extensions with concurrency primitives) is not reversible, since it loses information while computing forwards. E.g., it does not satisfy the Loop Lemma, stating that any reduction has an inverse, a main property of reversibility in process calculi, where small-step semantics is commonly used. We present here a novel small-step semantics which is actually reversible, while remaining equivalent to the previous one. It involves the non-trivial challenge of defining a semantics based on a "program counter" for a high-level programming language.

</details>


### [5] [Mason: Type- and Name-Guided Program Synthesis](https://arxiv.org/abs/2602.16981)
*Jasper Geer,Fox Huston,Jeffrey S. Foster*

Main category: cs.PL

TL;DR: Mason是一种工具，能够通过部分程序片段合成面向对象程序，并自动插入设计模式，减少了编写重复代码的需求。


<details>
  <summary>Details</summary>
Motivation: 面向对象程序设计常需要大量重复的样板代码来实现设计模式，这不仅繁琐还分散了开发者的注意力。Mason的目标是简化这一过程。

Method: Mason采用了一种名为"类型和名称引导合成"的新技术，通过枚举求解器遍历部分程序生成类型约束，并利用程序转换来满足约束。此外，Mason还引入了基于执行跟踪的非局部回溯启发式和模式语言。

Result: Mason在一系列基准测试中表现良好，尤其是在满足类型约束的候选程序较少时。其扩展功能在候选程序较多时也能显著提升性能。

Conclusion: Mason在利用设计模式合成多类面向对象程序方面迈出了重要一步，展示了其在简化编程任务中的潜力。

Abstract: Object-oriented programs tend to be written using many common coding idioms, such as those captured by design patterns. While design patterns are useful, implementing them is often tedious and repetitive, requiring boilerplate code that distracts the programmer from more essential details. In this paper, we introduce Mason, a tool that synthesizes object-oriented programs from partial program pieces, and we apply it to automatically insert design patterns into programs. At the core of Mason is a novel technique we call type- and name-guided synthesis, in which an enumerative solver traverses a partial program to generate typing constraints; discharges constraints via program transformations guided by the names of constrained types and members; and backtracks when a constraint is violated or a candidate program fails unit tests. We also introduce two extensions to Mason: a non-local backtracking heuristic that uses execution traces, and a language of patterns that impose syntactic restrictions on missing names. We evaluate Mason on a suite of benchmarks to which Mason must add various well-known design patterns implemented as a library of program pieces. We find that Mason performs well when very few candidate programs satisfy its typing constraints and that our extensions can improve Mason's performance significantly when this is not the case. We believe that Mason takes an important step forward in synthesizing multi-class object-oriented programs using design patterns.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [6] [Bloc Voting on Single Peaked Preferences](https://arxiv.org/abs/2602.16734)
*Ariel Calver,Serena Pallan,Alice,Park,Jennifer Wilson*

Main category: cs.GT

TL;DR: 分析单峰偏好下Bloc投票中获胜联盟的形成，探讨候选人和获胜者数量较少时获胜联盟中候选人的邻接条件，评估其对Condorcet准则的扩展满足程度，并通过蒙特卡洛模拟研究其在不同选民行为假设下的出现频率。


<details>
  <summary>Details</summary>
Motivation: 研究Bloc投票机制下获胜联盟的特性，特别是在选民偏好为单峰分布时的表现，以理解多赢家投票方法中Condorcet准则的扩展适用性。

Method: 通过分析小规模候选人和获胜者数量的情况，确定获胜联盟中候选人的邻接条件；评估获胜联盟与Condorcet准则扩展的匹配度；利用蒙特卡洛模拟研究不同选民行为假设下联盟的出现频率。

Result: 在小规模候选人和获胜者数量的情况下，获胜联盟中的候选人通常是邻接的；部分联盟满足Condorcet准则的扩展；蒙特卡洛模拟揭示了不同选民行为对联盟形成的影响。

Conclusion: Bloc投票在单峰偏好下形成的获胜联盟表现良好，特别是在小规模情境中，但对Condorcet准则的扩展仍需进一步研究。蒙特卡洛模拟提供了其在实际选民行为中的适用性参考。

Abstract: We analyze the winning coalitions that arise under Bloc voting when voters preferences are single-peaked. For small numbers of candidates and numbers of winners, we determine conditions under which candidates in winning coalitions are adjacent. We also analyze the results of pairwise contests between winning and losing candidates and assess when the winning coalitions satisfy several proposed extensions of the Condorcet criterion to multiwinner voting methods. Finally, we use Monte Carlo simulations to investigate how frequently these coalitions arise under different assumptions about voter behavior.

</details>


### [7] [Signaling in Data Markets via Free Samples](https://arxiv.org/abs/2602.16919)
*Nivasini Ananthakrishnan,Alireza Fallah,Michael I. Jordan*

Main category: cs.GT

TL;DR: 研究了一个数据买家通过从多个数据卖家购买样本估计未知参数的场景，探讨了免费试用阶段和拍卖阶段的博弈行为。


<details>
  <summary>Details</summary>
Motivation: 研究如何在数据市场中，通过免费试用和拍卖机制促进数据质量的透明化和高效交易。

Method: 采用多阶段博弈模型，第一阶段为免费试用，第二阶段为采购拍卖，设计了近似最优的贝叶斯激励相容机制。

Result: 免费试用在某些参数下无法实现，但在竞争足够强时，存在卖家提供最大允许样本量的唯一均衡。

Conclusion: 免费试用和拍卖机制在数据市场中具有潜力，尤其在竞争激烈的环境中效果显著。

Abstract: We study a setting in which a data buyer seeks to estimate an unknown parameter by purchasing samples from one of K data sellers. Each seller has privately known data quality (e.g., high vs. low variance) and a private per-sample cost. We consider a multi-stage game in which the first stage is a free-trial stage in which the sellers have the option of signaling data quality by offering a few samples of data for free. Buyers update their beliefs based on the sample variance of the free data and then run a procurement auction to buy data in a second stage. For the auction stage, we characterize an approximately optimal Bayesian incentive compatible mechanism: the buyer selects a single seller by minimizing a belief-adjusted virtual cost and chooses the purchased sample size as a function of posterior quality and virtual cost. For the free-trial stage, we characterize the equilibrium, taking the above mechanism as the continuation game. Free trials may fail to emerge: for some parameters, all sellers reveal zero samples. However, under sufficiently strong competition (large K), there is an equilibrium in which sellers reveal the maximum allowable number of samples; in fact, it is the unique equilibrium.

</details>


### [8] [Discovering Multiagent Learning Algorithms with Large Language Models](https://arxiv.org/abs/2602.16928)
*Zun Li,John Schultz,Daniel Hennes,Marc Lanctot*

Main category: cs.GT

TL;DR: 本研究提出了一种名为AlphaEvolve的进化编码代理，利用大型语言模型自动发现新的多智能体学习算法，成功应用于博弈论学习的两个不同领域，并演化出优于当前最优基线的方法。


<details>
  <summary>Details</summary>
Motivation: 传统的多智能体强化学习在非完美信息博弈中的进展依赖人工迭代改进，而现有基础方法（如CFR和PSRO）的有效变体设计依赖于人类直觉。本文旨在通过AlphaEvolve自动探索多智能体学习算法，减少人工干预。

Method: 使用AlphaEvolve进化编码代理，自动发现新的算法变体。分别在迭代遗憾最小化和基于种群训练的算法范式中演化出新算法VAD-CFR和SHOR-PSRO。

Result: VAD-CFR通过波动敏感折扣等机制优于当前最优基线（如Discounted Predictive CFR+）；SHOR-PSRO通过混合元求解器和动态退火技术表现出优于标准静态元求解器的收敛性。

Conclusion: AlphaEvolve能够自动发现高性能的多智能体学习算法变体，减少了对人工设计的依赖，并为博弈论学习提供了新的方法和工具。

Abstract: Much of the advancement of Multi-Agent Reinforcement Learning (MARL) in imperfect-information games has historically depended on manual iterative refinement of baselines. While foundational families like Counterfactual Regret Minimization (CFR) and Policy Space Response Oracles (PSRO) rest on solid theoretical ground, the design of their most effective variants often relies on human intuition to navigate a vast algorithmic design space. In this work, we propose the use of AlphaEvolve, an evolutionary coding agent powered by large language models, to automatically discover new multiagent learning algorithms. We demonstrate the generality of this framework by evolving novel variants for two distinct paradigms of game-theoretic learning. First, in the domain of iterative regret minimization, we evolve the logic governing regret accumulation and policy derivation, discovering a new algorithm, Volatility-Adaptive Discounted (VAD-)CFR. VAD-CFR employs novel, non-intuitive mechanisms-including volatility-sensitive discounting, consistency-enforced optimism, and a hard warm-start policy accumulation schedule-to outperform state-of-the-art baselines like Discounted Predictive CFR+. Second, in the regime of population based training algorithms, we evolve training-time and evaluation-time meta strategy solvers for PSRO, discovering a new variant, Smoothed Hybrid Optimistic Regret (SHOR-)PSRO. SHOR-PSRO introduces a hybrid meta-solver that linearly blends Optimistic Regret Matching with a smoothed, temperature-controlled distribution over best pure strategies. By dynamically annealing this blending factor and diversity bonuses during training, the algorithm automates the transition from population diversity to rigorous equilibrium finding, yielding superior empirical convergence compared to standard static meta-solvers.

</details>


### [9] [Learning to Recommend in Unknown Games](https://arxiv.org/abs/2602.16998)
*Arwa Alanqary,Zakaria Baba,Manxi Wu,Alexandre M. Bayen*

Main category: cs.GT

TL;DR: 本研究探讨了在多智能体游戏环境中通过推荐学习偏好的问题，展示了在量化响应反馈下如何以对数样本复杂度学习智能体的效用函数，并设计了一种低后悔的在线算法。


<details>
  <summary>Details</summary>
Motivation: 在多智能体环境中，智能体的效用函数通常未知，如何通过学习推荐行为的反馈来推断这些效用函数是一个重要问题。

Method: 研究考虑了两种行为反馈模型（最佳响应和量化响应），分析其对效用函数可学习性的影响，并设计了一种在线算法以减少后悔。

Result: 量化响应反馈下，游戏能以对数样本复杂度学习效用函数；最佳响应反馈则只能识别更大的效用函数集。在线算法在不同反馈模型下均表现出低后悔。

Conclusion: 研究为战略多智能体环境中的AI推荐系统提供了理论基础，强调了推荐行为在战略交互中的重要性。

Abstract: We study preference learning through recommendations in multi-agent game settings, where a moderator repeatedly interacts with agents whose utility functions are unknown. In each round, the moderator issues action recommendations and observes whether agents follow or deviate from them. We consider two canonical behavioral feedback models-best response and quantal response-and study how the information revealed by each model affects the learnability of agents' utilities. We show that under quantal-response feedback the game is learnable, up to a positive affine equivalence class, with logarithmic sample complexity in the desired precision, whereas best-response feedback can only identify a larger set of agents' utilities. We give a complete geometric characterization of this set. Moreover, we introduce a regret notion based on agents' incentives to deviate from recommendations and design an online algorithm with low regret under both feedback models, with bounds scaling linearly in the game dimension and logarithmically in time. Our results lay a theoretical foundation for AI recommendation systems in strategic multi-agent environments, where recommendation compliances are shaped by strategic interaction.

</details>


### [10] [Prophet Inequality with Conservative Prediction](https://arxiv.org/abs/2602.17358)
*Johannes Brüstle,Ilan Reuven Cohen,Stefano Leonardi*

Main category: cs.GT

TL;DR: 该研究在经典的先知不等式模型中引入了一个保守的最大值预测，通过参数α量化预测质量，提出了一种阈值策略，能够在α未知时平衡一致性和鲁棒性，并在α已知时达到最优竞争比。


<details>
  <summary>Details</summary>
Motivation: 传统先知不等式模型缺乏对预测信息的利用，本研究旨在通过引入预测信息来提高在线停止策略的性能，同时保证算法的鲁棒性。

Method: 研究提出了一种基于阈值的策略，无需知道预测准确度α，同时针对已知α的情况设计了另一种策略，理论分析了不同策略的竞争比。

Result: 在α未知时，策略在α=0时保持1/2的竞争比，α=1时提升到3/4；在α已知时，策略达到最优竞争比1/(2−α)。研究还证明无法同时做到在α=1时超过3/4且在α=0时保持1/2。

Conclusion: 研究通过引入预测信息改进了先知不等式模型的性能，提出了高效的阈值策略，并确定了性能的理论极限。

Abstract: Prophet inequalities compare online stopping strategies against an omniscient "prophet" using distributional knowledge. In this work, we augment this model with a conservative prediction of the maximum realized value. We quantify the quality of this prediction using a parameter $α\in [0,1]$, ranging from inaccurate to perfect. Our goal is to improve performance when predictions are accurate (consistency) while maintaining theoretical guarantees when they are not (robustness). We propose a threshold-based strategy oblivious to $α$ (i.e., with $α$ unknown to the algorithm) that matches the classic competitive ratio of $1/2$ at $α=0$ and improves smoothly to $3/4$ at $α=1$. We further prove that simultaneously achieving better than $3/4$ at $α=1$ while maintaining $1/2$ at $α=0$ is impossible. Finally, when $α$ is known in advance, we present a strategy achieving a tight competitive ratio of $\frac{1}{2-α}$.

</details>
