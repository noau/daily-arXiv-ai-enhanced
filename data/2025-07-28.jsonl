{"id": "2507.18664", "categories": ["cs.GR", "cs.CV", "I.3.2; I.4.10"], "pdf": "https://arxiv.org/pdf/2507.18664", "abs": "https://arxiv.org/abs/2507.18664", "authors": ["Aidan Murray", "Eddie Waite", "Caleb Ross", "Scarlet Mitchell", "Alexander Bradley", "Joanna Jamrozy", "Kenny Mitchell"], "title": "Generating real-time detailed ground visualisations from sparse aerial point clouds", "comment": "CVMP Short Paper. 1 page, 3 figures, CVMP 2022: The 19th ACM SIGGRAPH\n  European Conference on Visual Media Production, London. This work was\n  supported by the European Union's Horizon 2020 research and innovation\n  programme under Grant 101017779", "summary": "Building realistic wide scale outdoor 3D content with sufficient visual\nquality to observe at walking eye level or from driven vehicles is often\ncarried out by large teams of artists skilled in modelling, texturing, material\nshading and lighting, which typically leads to both prohibitive costs and\nreduced accuracy honoring the variety of real world ground truth landscapes. In\nour proposed method, we define a process to automatically amplify real-world\nscanned data and render real-time in animated 3D to explore at close range with\nhigh quality for training, simulation, video game and visualisation\napplications."}
{"id": "2507.18899", "categories": ["cs.GR"], "pdf": "https://arxiv.org/pdf/2507.18899", "abs": "https://arxiv.org/abs/2507.18899", "authors": ["Thomas Lechner", "Ben Watson", "Uri Wilensky", "Martin Felsen"], "title": "Procedural city modeling", "comment": null, "summary": "We propose a method to procedurally generate a familiar yet complex human\nartifact: the city. We are not trying to reproduce existing cities, but to\ngenerate artificial cities that are convincing and plausible by capturing\ndevelopmental behavior. In addition, our results are meant to build upon\nthemselves, such that they ought to look compelling at any point along the\ntransition from village to metropolis. Our approach largely focuses upon land\nusage and building distribution for creating realistic city environments,\nwhereas previous attempts at city modeling have mainly focused on populating\nroad networks. Finally, we want our model to be self automated to the point\nthat the only necessary input is a terrain description, but other high-level\nand low-level parameters can be specified to support artistic contributions.\nWith the aid of agent based simulation we are generating a system of agents and\nbehaviors that interact with one another through their effects upon a simulated\nenvironment. Our philosophy is that as each agent follows a simple behavioral\nrule set, a more complex behavior will tend to emerge out of the interactions\nbetween the agents and their differing rule sets. By confining our model to a\nset of simple rules for each class of agents, we hope to make our model\nextendible not only in regard to the types of structures that are produced, but\nalso in describing the social and cultural influences prevalent in all cities"}
{"id": "2507.18972", "categories": ["cs.GR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2507.18972", "abs": "https://arxiv.org/abs/2507.18972", "authors": ["Gromit Yeuk-Yin Chan", "Luis Gustavo Nonato", "Themis Palpanas", "Cl√°udio T. Silva", "Juliana Freire"], "title": "TiVy: Time Series Visual Summary for Scalable Visualization", "comment": "to be published in TVCG (IEEE VIS 2025)", "summary": "Visualizing multiple time series presents fundamental tradeoffs between\nscalability and visual clarity. Time series capture the behavior of many\nlarge-scale real-world processes, from stock market trends to urban activities.\nUsers often gain insights by visualizing them as line charts, juxtaposing or\nsuperposing multiple time series to compare them and identify trends and\npatterns. However, existing representations struggle with scalability: when\ncovering long time spans, leading to visual clutter from too many small\nmultiples or overlapping lines. We propose TiVy, a new algorithm that\nsummarizes time series using sequential patterns. It transforms the series into\na set of symbolic sequences based on subsequence visual similarity using\nDynamic Time Warping (DTW), then constructs a disjoint grouping of similar\nsubsequences based on the frequent sequential patterns. The grouping result, a\nvisual summary of time series, provides uncluttered superposition with fewer\nsmall multiples. Unlike common clustering techniques, TiVy extracts similar\nsubsequences (of varying lengths) aligned in time. We also present an\ninteractive time series visualization that renders large-scale time series in\nreal-time. Our experimental evaluation shows that our algorithm (1) extracts\nclear and accurate patterns when visualizing time series data, (2) achieves a\nsignificant speed-up (1000X) compared to a straightforward DTW clustering. We\nalso demonstrate the efficiency of our approach to explore hidden structures in\nmassive time series data in two usage scenarios."}
{"id": "2507.19461", "categories": ["cs.GT"], "pdf": "https://arxiv.org/pdf/2507.19461", "abs": "https://arxiv.org/abs/2507.19461", "authors": ["Jugal Garg", "Aniket Murhekar"], "title": "Existence of 2-EFX Allocations of Chores", "comment": "19 pages", "summary": "We study the fair division of indivisible chores among agents with additive\ndisutility functions. We investigate the existence of allocations satisfying\nthe popular fairness notion of envy-freeness up to any chore (EFX), and its\nmultiplicative approximations. The existence of $4$-EFX allocations was\nrecently established by Garg, Murhekar, and Qin (2025). We improve this\nguarantee by proving the existence of $2$-EFX allocations for all instances\nwith additive disutilities. This approximation was previously known only for\nrestricted instances such as bivalued disutilities (Lin, Wu, and Zhou (2025))\nor three agents (Afshinmehr, Ansaripour, Danaei, and Mehlhorn (2024)).\n  We obtain our result by providing a general framework for achieving\napproximate-EFX allocations. The approach begins with a suitable initial\nallocation and performs a sequence of local swaps between the bundles of\nenvious and envied agents. For our main result, we begin with an initial\nallocation that satisfies envy-freeness up to one chore (EF1) and\nPareto-optimality (PO); the existence of such an allocation was recently\nestablished in a major breakthrough by Mahara (2025). We further demonstrate\nthe strength and generality of our framework by giving simple and unified\nproofs of existing results, namely (i) $2$-EFX for bivalued instances, (ii)\n2-EFX for three agents, (iii) EFX when the number of chores is at most twice\nthe number of agents, and (iv) $4$-EFX for all instances. We expect this\nframework to have broader applications in approximate-EFX due to its simplicity\nand generality."}
{"id": "2507.18792", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18792", "abs": "https://arxiv.org/abs/2507.18792", "authors": ["Zixu Zhou"], "title": "Decompiling Rust: An Empirical Study of Compiler Optimizations and Reverse Engineering Challenges", "comment": null, "summary": "Decompiling Rust binaries is challenging due to the language's rich type\nsystem, aggressive compiler optimizations, and widespread use of high-level\nabstractions. In this work, we conduct a benchmark-driven evaluation of\ndecompilation quality across core Rust features and compiler build modes. Our\nautomated scoring framework shows that generic types, trait methods, and error\nhandling constructs significantly reduce decompilation quality, especially in\nrelease builds. Through representative case studies, we analyze how specific\nlanguage constructs affect control flow, variable naming, and type information\nrecovery. Our findings provide actionable insights for tool developers and\nhighlight the need for Rust-aware decompilation strategies."}
{"id": "2507.18885", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.18885", "abs": "https://arxiv.org/abs/2507.18885", "authors": ["Qiyuan Xu", "Renxi Wang", "Haonan Li", "David Sanan", "Conrad Watt"], "title": "IsaMini: Redesigned Isabelle Proof Lanugage for Machine Learning", "comment": null, "summary": "Neural Theorem Proving (NTP) employs deep learning methods, particularly\nLarge Language Models (LLMs), to automate formal proofs in proof assistants.\nThis approach holds promise for reducing the dramatic labor costs or\ncomputation costs required in proof engineering, which is fundamental to formal\nverification and other software engineering methods. The paper explores the\npotential of improving NTP by redesigning the proof language, given that LLMs'\ncapabilities depend highly on representations. We introduce \\emph{MiniLang}, a\nredesigned proof language for Isabelle/HOL incorporating an improved version of\nSledgehammer. Experiments show MiniLang benefits two fine-tuned LLMs by\nimproving the success rate on the PISA benchmark by up to 29\\% in comparison to\ngeneration of Isar proof script. The success rate under one attempt (so-called\n\\emph{pass@1}) reaches 69.1\\%, exceeding the previous Baldur's pass@64\n(65.7\\%); The pass@8 reaches 79.2\\%, exceeding the state-of-the-art on PISA\n(71.0\\%) achieved by Magnushammer."}
{"id": "2507.19015", "categories": ["cs.PL", "cs.LO", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.19015", "abs": "https://arxiv.org/abs/2507.19015", "authors": ["Samuel Xifaras", "Panagiotis Manolios", "Andrew T. Walter", "William Robertson"], "title": "An Enumerative Embedding of the Python Type System in ACL2s", "comment": "In Proceedings ACL2 2025, arXiv:2507.18567", "summary": "Python is a high-level interpreted language that has become an industry\nstandard in a wide variety of applications. In this paper, we take a first step\ntowards using ACL2s to reason about Python code by developing an embedding of a\nsubset of the Python type system in ACL2s. The subset of Python types we\nsupport includes many of the most commonly used type annotations as well as\nuser-defined types comprised of supported types. We provide ACL2s definitions\nof these types, as well as defdata enumerators that are customized to provide\ncode coverage and identify errors in Python programs. Using the ACL2s\nembedding, we can generate instances of types that can then be used as inputs\nto fuzz Python programs, which allows us to identify bugs in Python code that\nare not detected by state-of-the-art Python type checkers. We evaluate our work\nagainst four open-source repositories, extracting their type information and\ngenerating inputs for fuzzing functions with type signatures that are in the\nsupported subset of Python types. Note that we only use the type signatures of\nfunctions to generate inputs and treat the bodies of functions as black boxes.\nWe measure code coverage, which ranges from about 68% to more than 80%, and\nidentify code patterns that hinder coverage such as complex branch conditions\nand external file system dependencies. We conclude with a discussion of the\nresults and recommendations for future work."}
{"id": "2507.19176", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.19176", "abs": "https://arxiv.org/abs/2507.19176", "authors": ["Weijun Chen", "Yuxi Fu", "Huan Long"], "title": "A Programming Language for Feasible Solutions", "comment": null, "summary": "Runtime efficiency and termination are crucial properties in the studies of\nprogram verification. Instead of dealing with these issues in an ad hoc manner,\nit would be useful to develop a robust framework in which such properties are\nguaranteed by design. This paper introduces a new imperative programming\nlanguage whose design is grounded in a static type system that ensures the\nfollowing equivalence property: All definable programs are guaranteed to run in\npolynomial time; Conversely, all problems solvable in polynomial time can be\nsolved by some programs of the language. The contribution of this work is\ntwofold. On the theoretical side, the foundational equivalence property is\nestablished, and the proof of the equivalence theorem is non-trivial. On the\npractical side, a programming approach is proposed that can streamline program\nanalysis and verification for feasible computations. An interpreter for the\nlanguage has been implemented, demonstrating the feasibility of the approach in\npractice."}
