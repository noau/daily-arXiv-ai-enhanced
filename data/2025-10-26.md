<div id=toc></div>

# Table of Contents

- [cs.GR](#cs.GR) [Total: 1]
- [cs.PL](#cs.PL) [Total: 6]
- [cs.GT](#cs.GT) [Total: 2]


<div id='cs.GR'></div>

# cs.GR [[Back]](#toc)

### [1] [Interactive Hypergraph Visual Analytics for Exploring Large and Complex Image Collections](https://arxiv.org/abs/2510.20050)
*Floris Gisolf,Zeno J. M. H. Geradts,Marcel Worring*

Main category: cs.GR

TL;DR: 提出了一种用于大规模复杂图像集合的交互式视觉分析方法，通过超图构建和可视化技术帮助领域专家高效解析图像间的复杂关系。


<details>
  <summary>Details</summary>
Motivation: 传统聚类和分类方法难以有效表示图像间复杂、重叠的关系，尤其是在缺乏标记数据或预训练模型的情况下，需要更先进的视觉分析方法。

Method: 采用交互式视觉分析方法，包括：(1) 从原始图像数据构建超图的管道，(2) 结合空间超图表示和矩阵可视化的交互技术，(3) 基于真实图像集合的评估提供实用建议。

Result: 该方法支持迭代探索，帮助领域专家从数万张图像中高效提取信息，证明了其在处理大规模图像集合时的有效性。

Conclusion: 提出的视觉分析方法能够有效解决图像集合中复杂关系的可视化问题，为领域专家提供了强大的工具。

Abstract: Analyzing large complex image collections in domains like forensics, accident
investigation, or social media analysis involves interpreting intricate,
overlapping relationships among images. Traditional clustering and
classification methods fail to adequately represent these complex
relationships, particularly when labeled data or suitable pre-trained models
are unavailable. Hypergraphs effectively capture overlapping relationships, but
to translate their complexity into information and insights for domain expert
users visualization is essential. We propose an interactive visual analytics
approach specifically designed for the construction, exploration, and analysis
of hypergraphs on large-scale complex image collections. Our core contributions
include: (1) a scalable pipeline for constructing hypergraphs directly from raw
image data, including a similarity measure to evaluate constructed hypergraphs
against a ground truth, (2) interactive visualization techniques that integrate
spatial hypergraph representations, interactive grids, and matrix
visualizations, enabling users to dynamically explore and interpret
relationships without becoming overwhelmed and disoriented, and (3) practical
insights on how domain experts can effectively use the application, based on
evaluation with real-life image collections. Our results demonstrate that our
visual analytics approach facilitates iterative exploration, enabling domain
experts to efficiently derive insights from image collections containing tens
of thousands of images.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [2] [Prompt Decorators: A Declarative and Composable Syntax for Reasoning, Formatting, and Control in LLMs](https://arxiv.org/abs/2510.19850)
*Mostapha Kalami Heris*

Main category: cs.PL

TL;DR: 该论文介绍了Prompt Decorators，一种声明式、可组合的语法，通过紧凑的控制标记（如+++Reasoning、+++Tone）来管理大型语言模型（LLMs）的行为，从而提升推理透明度、降低提示复杂性并标准化模型行为。


<details>
  <summary>Details</summary>
Motivation: 传统提示工程依赖冗长的自然语言指令，限制了可重复性、模块化和可解释性。为了解决这一问题，论文提出了Prompt Decorators框架。

Method: 论文设计了一种声明式语法Prompt Decorators，通过核心装饰器（分为认知与生成、表达与系统两大家族）来管理LLMs的行为维度（如推理风格、结构或语气），并提供统一的语法、作用域模型和处理流程。

Result: 示例用例展示了Prompt Decorators在提升推理透明度、降低提示复杂性和标准化模型行为方面的效果。

Conclusion: 论文总结了Prompt Decorators对互操作性、行为一致性和可扩展AI系统开发的意义。

Abstract: Large Language Models (LLMs) are central to reasoning, writing, and
decision-support workflows, yet users lack consistent control over how they
reason and express outputs. Conventional prompt engineering relies on verbose
natural-language instructions, limiting reproducibility, modularity, and
interpretability. This paper introduces Prompt Decorators, a declarative,
composable syntax that governs LLM behavior through compact control tokens such
as +++Reasoning, +++Tone(style=formal), and +++Import(topic="Systems
Thinking"). Each decorator modifies a behavioral dimension, such as reasoning
style, structure, or tone, without changing task content. The framework
formalizes twenty core decorators organized into two functional families
(Cognitive & Generative and Expressive & Systemic), each further decomposed
into subcategories that govern reasoning, interaction, expression, and
session-control. It defines a unified syntax, scoping model, and deterministic
processing pipeline enabling predictable and auditable behavior composition. By
decoupling task intent from execution behavior, Prompt Decorators create a
reusable and interpretable interface for prompt design. Illustrative use cases
demonstrate improved reasoning transparency, reduced prompt complexity, and
standardized model behavior across domains. The paper concludes with
implications for interoperability, behavioral consistency, and the development
of declarative interfaces for scalable AI systems.

</details>


### [3] [A Specification's Realm: Characterizing the Knowledge Required for Executing a Given Algorithm Specification](https://arxiv.org/abs/2510.19853)
*Assaf Marron,David Harel*

Main category: cs.PL

TL;DR: 该论文提出了算法规范的“领域”概念，总结了执行算法所需的前提知识，并探讨了其方法论和自动化生成的可能性。


<details>
  <summary>Details</summary>
Motivation: 为了解决算法规范在机械执行中的清晰性和独立性需求，论文提出了算法规范的“领域”概念，旨在明确执行算法所需的知识。

Method: 通过系统性分析，总结了算法规范领域的关键组成部分，包括语法语义、领域知识、实体关系等，并探讨了利用大型语言模型和现有文档自动化生成领域的可能性。

Result: 提出了算法规范的领域文档，可用于方法论实现和形式化验证，并讨论了如何评估执行忠实性的问题。

Conclusion: 论文为算法规范的执行和验证提供了理论基础，并指出未来研究方向，如自动化生成和忠实性评估。

Abstract: An algorithm specification in natural language or pseudocode is expected to
be clear and explicit enough to enable mechanical execution. In this position
paper we contribute an initial characterization of the knowledge that an
executing agent, human or machine, should possess in order to be able to carry
out the instructions of a given algorithm specification as a stand-alone
entity, independent of any system implementation. We argue that, for that
algorithm specification, such prerequisite knowledge, whether unique or shared
with other specifications, can be summarized in a document of practical size.
We term this document the realm of the algorithm specification. The generation
of such a realm is itself a systematic analytical process, significant parts of
which can be automated with the help of large language models and the reuse of
existing documents. The algorithm-specification's realm would consist of
specification language syntax and semantics, domain knowledge restricted to the
referenced entities, inter-entity relationships, relevant underlying
cause-and-effect rules, and detailed instructions and means for carrying out
certain operations. Such characterization of the realm can contribute to
methodological implementation of the algorithm specification in diverse systems
and to its formalization for mechanical verification. The paper also touches
upon the question of assessing execution faithfulness, which is distinct from
correctness: in the absence of a reference interpretation of natural language
or pseudocode specification with a given vocabulary, how can we determine if an
observed agent's execution indeed complies with the input specification.

</details>


### [4] [Deconstructed Proto-Quipper: A Rational Reconstruction](https://arxiv.org/abs/2510.20018)
*Ryan Kavanagh,Chuta Sano,Brigitte Pientka*

Main category: cs.PL

TL;DR: Proto-Quipper-A是一个重构的Proto-Quipper语言版本，旨在简化量子电路的静态生成和推理，使用线性λλ-演算和adjoint逻辑基础，提供更简单的语义和规范化证明。


<details>
  <summary>Details</summary>
Motivation: Proto-Quipper语言的操作语义复杂，难以用标准编程语言技术推理和机械化，因此需要一种更简单且易于理解的重构版本。

Method: 引入Proto-Quipper-A，基于线性λλ-演算和adjoint逻辑基础，重构Proto-Quipper语言的电路编程抽象，并提供简单的call-by-value语义。

Result: Proto-Quipper-A具有简单的语义和规范化特性，能够避免现有线性逻辑关系的复杂性，并通过标准逻辑关系证明规范化。

Conclusion: Proto-Quipper-A为Proto-Quipper语言提供了一个更加基础和易于处理的版本，适合作为量子编程语言的静态电路生成基础。

Abstract: The Proto-Quipper family of programming languages aims to provide a formal
foundation for the Quipper quantum programming language. Unfortunately,
Proto-Quipper languages have complex operational semantics: they are inherently
effectful, and they rely on set-theoretic operations and fresh name generation
to manipulate quantum circuits. This makes them difficult to reason about using
standard programming language techniques and, ultimately, to mechanize. We
introduce Proto-Quipper-A, a rational reconstruction of Proto-Quipper languages
for static circuit generation. It uses a linear $\lambda$-calculus to describe
quantum circuits with normal forms that closely correspond to box-and-wire
circuit diagrams. Adjoint-logical foundations integrate this circuit language
with a linear/non-linear functional language and let us reconstruct
Proto-Quipper's circuit programming abstractions using more primitive
adjoint-logical operations. Proto-Quipper-A enjoys a simple call-by-value
reduction semantics, and to illustrate its tractability as a foundation for
Proto-Quipper languages, we show that it is normalizing. We show how to use
standard logical relations to prove normalization of linear and substructural
systems, thereby avoiding the inherent complexity of existing linear logical
relations.

</details>


### [5] [Deciding not to Decide: Sound and Complete Effect Inference in the Presence of Higher-Rank Polymorphism](https://arxiv.org/abs/2510.20532)
*Patrycja Balik,Szymon Jędras,Piotr Polesiuk*

Main category: cs.PL

TL;DR: 本文提出了一种类型与效应系统的效应推断算法，支持子类型化、高阶多态性和直观的集合效应语义，并通过命题逻辑公式处理作用域问题。


<details>
  <summary>Details</summary>
Motivation: 尽管传统类型系统已有多种表达能力强的变体和推断算法，类型与效应系统因其复杂性和现有算法在表达性、直观性和可判定性之间的妥协，尚未得到广泛应用。

Method: 通过将效应约束转化为命题逻辑公式，延迟求解效应约束以避免高阶多态的作用域问题，提出了一种效应推断算法。

Result: 算法被证明与声明式类型与效应系统的声音性和完备性相符，并在Rocq证明助手中形式化，以及在一个实际的编程语言中成功实现。

Conclusion: 本文提出的算法解决了类型与效应系统在表达性、直观性和可判定性之间的平衡问题，为其更广泛应用提供了技术基础。

Abstract: Type-and-effect systems help the programmer to organize data and
computational effects in a program. While for traditional type systems
expressive variants with sophisticated inference algorithms have been developed
and widely used in programming languages, type-and-effect systems did not yet
gain widespread adoption. One reason for this is that type-and-effect systems
are more complex and the existing inference algorithms make compromises between
expressiveness, intuitiveness, and decidability. In this work, we present an
effect inference algorithm for a type-and-effect system with subtyping,
expressive higher-rank polymorphism, and intuitive set-like semantics of
effects. In order to deal with scoping issues of higher-rank polymorphism, we
delay solving of effect constraints by transforming them into formulae of
propositional logic. We prove soundness and completeness of our algorithm with
respect to a declarative type-and-effect system. All the presented results have
been formalized in the Rocq proof assistant, and the algorithm has been
successfully implemented in a realistic programming language.

</details>


### [6] [Compiling the Mimosa programming language to RTOS tasks](https://arxiv.org/abs/2510.20547)
*Nikolaus Huber,Susanne Graf,Philipp Rümmer,Wang Yi*

Main category: cs.PL

TL;DR: 本文介绍了一种用于Mimosa编程语言的编译方案，基于MIMOS计算模型，将嵌入式系统软件描述为时间触发进程集合，并通过FIFO队列通信。


<details>
  <summary>Details</summary>
Motivation: Mimosa编程语言需要一个高效的编译方案，以适应其基于时间触发进程和FIFO队列通信的嵌入式系统语义。

Method: 通过对Lustre编译方案的适应性调整，将Mimosa语言的协调层映射到实时操作系统原语中。

Result: 研究展示了如何将Mimosa语言的语义与实时操作系统原语相结合，实现了高效的编译方案。

Conclusion: 本文提出的编译方案为Mimosa语言的嵌入式系统开发提供了有效的工具，并验证了其可行性。

Abstract: This paper introduces a compilation scheme for programs written in the Mimosa
programming language, which builds upon the MIMOS model of computation. Mimosa
describes embedded systems software as a collection of time-triggered processes
which communicate through FIFO queues. We formally describe an adaptation of
the Lustre compilation scheme to the semantics of Mimosa and show how the
coordination layer can be mapped to real-time operating system primitives.

</details>


### [7] [SafeFFI: Efficient Sanitization at the Boundary Between Safe and Unsafe Code in Rust and Mixed-Language Applications](https://arxiv.org/abs/2510.20688)
*Oliver Braunsdorf,Tim Lange,Konrad Hohentanner,Julian Horsch,Johannes Kinder*

Main category: cs.PL

TL;DR: SafeFFI是一种优化Rust二进制文件中内存安全检测的系统，通过在安全代码和非安全代码边界进行检查，减少不必要的运行时检查，同时保持内存安全性。


<details>
  <summary>Details</summary>
Motivation: Rust中非安全代码在与C/C++库交互和实现低级数据结构时是必要的，但可能导致内存安全问题。现有的消毒工具虽然能捕捉这类错误，但会在所有内存访问中添加不必要的检查。

Method: SafeFFI在Rust二进制文件中优化内存安全检测，仅在非安全和安全代码边界进行检查，避免了昂贵的全程序分析和编译时开销。

Result: 在流行的Rust crate和已知易受攻击代码上，SafeFFI减少了高达98%的消毒检查，性能优于现有系统，同时保持正确性并捕捉所有时空内存安全违规。

Conclusion: SafeFFI通过优化检测边界，显著提升了性能并保持了内存安全性，为非安全Rust代码提供了一个高效且可靠的解决方案。

Abstract: Unsafe Rust code is necessary for interoperability with C/C++ libraries and
implementing low-level data structures, but it can cause memory safety
violations in otherwise memory-safe Rust programs. Sanitizers can catch such
memory errors at runtime, but introduce many unnecessary checks even for memory
accesses guaranteed safe by the Rust type system. We introduce SafeFFI, a
system for optimizing memory safety instrumentation in Rust binaries such that
checks occur at the boundary between unsafe and safe code, handing over the
enforcement of memory safety from the sanitizer to the Rust type system. Unlike
previous approaches, our design avoids expensive whole-program analysis and
adds much less compile-time overhead (2.64x compared to over 8.83x). On a
collection of popular Rust crates and known vulnerable Rust code, SafeFFI
achieves superior performance compared to state-of-the-art systems, reducing
sanitizer checks by up to 98%, while maintaining correctness and flagging all
spatial and temporal memory safety violations.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [8] [Optimized Distortion in Linear Social Choice](https://arxiv.org/abs/2510.20020)
*Luise Ge,Gregory Kehne,Yevgeniy Vorobeychik*

Main category: cs.GT

TL;DR: 该论文研究了线性效用函数在投票规则中的扭曲问题，提出了基于候选嵌入维度的边界条件及实例最优算法，并在推荐系统和意见调查中进行了实证评估。


<details>
  <summary>Details</summary>
Motivation: 传统社会选择理论基于投票者的偏好排序选择候选人，但若投票者对选项有潜在效用函数，仅用偏好排序可能导致次优结果。扭曲问题成为量化这种次优性的关键。

Method: 论文研究了确定性及随机投票规则下的线性社会选择扭曲问题，提出了依赖候选嵌入维度的边界条件，并设计了多项式时间内的实例最优算法以减少扭曲。

Result: 结果表明，扭曲边界仅依赖于候选嵌入的维度，而与候选人或投票者数量无关。实证评估中，实例最优算法在推荐系统和意见调查中表现优于标准规则。

Conclusion: 论文首次系统研究了线性效用函数的扭曲问题，提供了理论和算法上的创新，并在实际应用中验证了其有效性。

Abstract: Social choice theory offers a wealth of approaches for selecting a candidate
on behalf of voters based on their reported preference rankings over options.
When voters have underlying utilities for these options, however, using
preference rankings may lead to suboptimal outcomes vis-\`a-vis utilitarian
social welfare. Distortion is a measure of this suboptimality, and provides a
worst-case approach for developing and analyzing voting rules when utilities
have minimal structure. However in many settings, such as common paradigms for
value alignment, alternatives admit a vector representation, and it is natural
to suppose that utilities are parametric functions thereof. We undertake the
first study of distortion for linear utility functions. Specifically, we
investigate the distortion of linear social choice for deterministic and
randomized voting rules. We obtain bounds that depend only on the dimension of
the candidate embedding, and are independent of the numbers of candidates or
voters. Additionally, we introduce poly-time instance-optimal algorithms for
minimizing distortion given a collection of candidates and votes. We
empirically evaluate these in two real-world domains: recommendation systems
using collaborative filtering embeddings, and opinion surveys utilizing
language model embeddings, benchmarking several standard rules against our
instance-optimal algorithms.

</details>


### [9] [Strategic Costs of Perceived Bias in Fair Selection](https://arxiv.org/abs/2510.20606)
*L. Elisa Celis,Lingxiao Huang,Milind Sohoni,Nisheeth K. Vishnoi*

Main category: cs.GT

TL;DR: 论文通过博弈论模型分析了不同社会经济群体在选拔系统中的不平等现象，揭示了感知差异如何影响努力和选拔结果的公平性。


<details>
  <summary>Details</summary>
Motivation: 研究旨在解释为何在标榜公平的选拔系统中，种族、性别和阶级之间的差异依然存在。

Method: 使用博弈论模型，分析不同群体在选拔系统中的策略选择，并推导纳什均衡。

Result: 模型显示感知差异会导致不同群体的努力不同，从而在不公平的未来价值预期下产生不平等结果。

Conclusion: 研究揭示了感知偏差在选拔系统中的作用，提出了通过调整选拔标准或感知价值来减少不平等的优化框架。

Abstract: Meritocratic systems, from admissions to hiring, aim to impartially reward
skill and effort. Yet persistent disparities across race, gender, and class
challenge this ideal. Some attribute these gaps to structural inequality;
others to individual choice. We develop a game-theoretic model in which
candidates from different socioeconomic groups differ in their perceived
post-selection value--shaped by social context and, increasingly, by AI-powered
tools offering personalized career or salary guidance. Each candidate
strategically chooses effort, balancing its cost against expected reward;
effort translates into observable merit, and selection is based solely on
merit. We characterize the unique Nash equilibrium in the large-agent limit and
derive explicit formulas showing how valuation disparities and institutional
selectivity jointly determine effort, representation, social welfare, and
utility. We further propose a cost-sensitive optimization framework that
quantifies how modifying selectivity or perceived value can reduce disparities
without compromising institutional goals. Our analysis reveals a
perception-driven bias: when perceptions of post-selection value differ across
groups, these differences translate into rational differences in effort,
propagating disparities backward through otherwise "fair" selection processes.
While the model is static, it captures one stage of a broader feedback cycle
linking perceptions, incentives, and outcome--bridging rational-choice and
structural explanations of inequality by showing how techno-social environments
shape individual incentives in meritocratic systems.

</details>
