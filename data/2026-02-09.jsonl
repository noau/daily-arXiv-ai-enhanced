{"id": "2602.06361", "categories": ["cs.GT", "cs.IT", "cs.LG", "stat.ML"], "pdf": "https://arxiv.org/pdf/2602.06361", "abs": "https://arxiv.org/abs/2602.06361", "authors": ["Zihan Li", "Yan Hao Ling", "Jonathan Scarlett", "Warut Suksompong"], "title": "Envy-Free Allocation of Indivisible Goods via Noisy Queries", "comment": null, "summary": "We introduce a problem of fairly allocating indivisible goods (items) in which the agents' valuations cannot be observed directly, but instead can only be accessed via noisy queries. In the two-agent setting with Gaussian noise and bounded valuations, we derive upper and lower bounds on the required number of queries for finding an envy-free allocation in terms of the number of items, $m$, and the negative-envy of the optimal allocation, $Δ$. In particular, when $Δ$ is not too small (namely, $Δ\\gg m^{1/4}$), we establish that the optimal number of queries scales as $\\frac{\\sqrt m }{(Δ/ m)^2} = \\frac{m^{2.5}}{Δ^2}$ up to logarithmic factors. Our upper bound is based on non-adaptive queries and a simple thresholding-based allocation algorithm that runs in polynomial time, while our lower bound holds even under adaptive queries and arbitrary computation time."}
{"id": "2602.06582", "categories": ["cs.GT", "econ.TH"], "pdf": "https://arxiv.org/pdf/2602.06582", "abs": "https://arxiv.org/abs/2602.06582", "authors": ["Manuel Eberl", "Patrick Lederer"], "title": "The Impossibility of Strategyproof Rank Aggregation", "comment": "Published as full paper at AAMAS 2026", "summary": "In rank aggregation, the goal is to combine multiple input rankings into a single output ranking. In this paper, we analyze rank aggregation methods, so-called social welfare functions (SWFs), with respect to strategyproofness, which requires that no agent can misreport his ranking to obtain an output ranking that is closer to his true ranking in terms of the Kemeny distance. As our main result, we show that no anonymous SWF satisfies unanimity and strategyproofness when there are at least four alternatives. This result is proven by SAT solving, a computer-aided theorem proving technique, and verified by Isabelle, a highly trustworthy interactive proof assistant. Further, we prove by hand that strategyproofness is incompatible with majority consistency, a variant of Condorcet-consistency for SWFs. Lastly, we show that all SWFs in two natural classes have a large incentive ratio and are thus highly manipulable."}
{"id": "2602.06598", "categories": ["cs.GT"], "pdf": "https://arxiv.org/pdf/2602.06598", "abs": "https://arxiv.org/abs/2602.06598", "authors": ["Yang Li", "Alexander Skopalik", "Marc Uetz"], "title": "Selfish routing games with priority lanes", "comment": null, "summary": "We study selfish routing games where users can choose between regular and priority service for each network edge on their chosen path. Priority users pay an additional fee, but in turn they may travel the edge prior to non-priority users, hence experiencing potentially less congestion. For this model, we establish existence of equilibria for linear latency functions and prove uniqueness of edge latencies, despite potentially different strategic choices in equilibrium. Our main contribution demonstrates that marginal cost pricing achieves system optimality: When priority fees equal marginal externality costs, the equilibrium flow coincides with the socially optimal flow, hence the price of anarchy equals $1$. This voluntary priority mechanism therefore provides an incentive-compatible alternative to mandatory congestion pricing, whilst achieving the same result. We also discuss the limitations of a uniform pricing scheme for the priority option."}
{"id": "2602.06776", "categories": ["cs.GT", "cs.LG"], "pdf": "https://arxiv.org/pdf/2602.06776", "abs": "https://arxiv.org/abs/2602.06776", "authors": ["Haris Aziz", "Ling Gai", "Yuhang Guo", "Jeremy Vollen"], "title": "Fair Transit Stop Placement: A Clustering Perspective and Beyond", "comment": null, "summary": "We study the transit stop placement (TrSP) problem in general metric spaces, where agents travel between source-destination pairs and may either walk directly or utilize a shuttle service via selected transit stops. We investigate fairness in TrSP through the lens of justified representation (JR) and the core, and uncover a structural correspondence with fair clustering. Specifically, we show that a constant-factor approximation to proportional fairness in clustering can be used to guarantee a constant-factor biparameterized approximation to core. We establish a lower bound of 1.366 on the approximability of JR, and moreover show that no clustering algorithm can approximate JR within a factor better than 3. Going beyond clustering, we propose the Expanding Cost Algorithm, which achieves a tight 2.414-approximation for JR, but does not give any bounded core guarantee. In light of this, we introduce a parameterized algorithm that interpolates between these approaches, and enables a tunable trade-off between JR and core. Finally, we complement our results with an experimental analysis using small-market public carpooling data."}
{"id": "2602.06735", "categories": ["cs.GR", "astro-ph.EP", "astro-ph.IM"], "pdf": "https://arxiv.org/pdf/2602.06735", "abs": "https://arxiv.org/abs/2602.06735", "authors": ["Hanno Rein"], "title": "Real time, cross platform visualizations with zero dependencies for the N-body package REBOUND", "comment": "9 pages, 2 figures. Published in JoVI. Interactive article available at https://journals.aau.dk/index.php/jovi/article/view/8312/8847", "summary": "Visualizations have become an indispensable part of the scientific process. A vibrant ecosystem of visualization tools exists, catering to a wide variety of different needs. Real-time visualizations of numerical simulations offer scientists immediate feedback about the status of their simulations and can also be valuable educational and outreach tools. Developing a visualization tool with support for different operating systems, CPU/GPU architectures, and programming languages can be a challenge. It is common to use one or more graphics or UI libraries to act as abstraction layers and hide the underlying complexity. Whereas external libraries greatly simplify the initial programming effort, we argue that relying on them introduces new dependencies and problems, such as a higher entry barriers for new developers and users, and uncertainty regarding long-term support. In this paper we present a new approach for real time visualizations which we have implemented for the N-body package REBOUND. We propose to use a web browser to handle GPU accelerated rendering. This enables us to offer 3D, interactive visualizations on all major operating systems. What makes our new approach unique is that we achieve this without the need for any external libraries. We utilize WebAssembly to reuse existing OpenGL visualization code. Using communication via HTTP and a custom built-in web server, we are able to provide both local and remote real time visualizations. In addition to the browser based real time visualization, our approach offers other additional operating modes, including simulations running entirely within the browser, visualizations within jupyter notebooks, and traditional standalone visualizations using OpenGL. We focus on the implementation in REBOUND but the concepts and ideas discussed can be applied to many other areas in need of scientific and non-scientific real time visualizations."}
{"id": "2602.06142", "categories": ["cs.PL", "cs.AI", "cs.CL", "cs.LG", "cs.PF"], "pdf": "https://arxiv.org/pdf/2602.06142", "abs": "https://arxiv.org/abs/2602.06142", "authors": ["Amir H. Ashouri", "Shayan Shirahmad Gale Bagi", "Kavin Satheeskumar", "Tejas Srikanth", "Jonathan Zhao", "Ibrahim Saidoun", "Ziwen Wang", "Bryan Chan", "Tomasz S. Czajkowski"], "title": "Protean Compiler: An Agile Framework to Drive Fine-grain Phase Ordering", "comment": "Version 1- Submitted for a possible publication in 2026", "summary": "The phase ordering problem has been a long-standing challenge since the late 1970s, yet it remains an open problem due to having a vast optimization space and an unbounded nature, making it an open-ended problem without a finite solution, one can limit the scope by reducing the number and the length of optimizations. Traditionally, such locally optimized decisions are made by hand-coded algorithms tuned for a small number of benchmarks, often requiring significant effort to be retuned when the benchmark suite changes. In the past 20 years, Machine Learning has been employed to construct performance models to improve the selection and ordering of compiler optimizations, however, the approaches are not baked into the compiler seamlessly and never materialized to be leveraged at a fine-grained scope of code segments. This paper presents Protean Compiler: An agile framework to enable LLVM with built-in phase-ordering capabilities at a fine-grained scope. The framework also comprises a complete library of more than 140 handcrafted static feature collection methods at varying scopes, and the experimental results showcase speedup gains of up to 4.1% on average and up to 15.7% on select Cbench applications wrt LLVM's O3 by just incurring a few extra seconds of build time on Cbench. Additionally, Protean compiler allows for an easy integration with third-party ML frameworks and other Large Language Models, and this two-step optimization shows a gain of 10.1% and 8.5% speedup wrt O3 on Cbench's Susan and Jpeg applications. Protean compiler is seamlessly integrated into LLVM and can be used as a new, enhanced, full-fledged compiler. We plan to release the project to the open-source community in the near future."}
{"id": "2602.06386", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2602.06386", "abs": "https://arxiv.org/abs/2602.06386", "authors": ["Liam O'Connor", "Pilar Selene Linares Arevalo", "Christine Rizkallah"], "title": "Uniqueness is Separation", "comment": null, "summary": "Value independence is enormously beneficial for reasoning about software systems at scale. These benefits carry over into the world of formal verification. Reasoning about programs algebraically is a simple affair in a proof assistant, whereas programs with unconstrained mutation necessitate much more complex techniques, such as Separation Logic, where invariants about memory safety, aliasing, and state changes must be established by manual proof. Uniqueness type systems allow programs to be compiled to code that uses mutation for efficiency, while retaining a semantics that enjoys value independence for reasoning. The restrictions of these type systems, however, are often too onerous for realistic software. Thus, most uniqueness type systems include some \"escape hatch\" where the benefits of value independence for reasoning are lost, but the restrictions of uniqueness types are lifted. To formally verify a system with such mixed guarantees, the value independence guarantees from uniqueness types must be expressed in terms of imperative, mutable semantics. In other words, we ought to express value independence as an assertion in Separation Logic."}
{"id": "2602.06466", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2602.06466", "abs": "https://arxiv.org/abs/2602.06466", "authors": ["Lydia Zoghbi", "David Thien", "Ranjit Jhala", "Deian Stefan", "Caleb Stanford"], "title": "Auditing Rust Crates Effectively", "comment": null, "summary": "We introduce Cargo Scan, the first interactive program analysis tool designed to help developers audit third-party Rust code. Real systems written in Rust rely on thousands of transitive dependencies. These dependencies are as dangerous in Rust as they are in other languages (e.g., C or JavaScript) -- and auditing these dependencies today means manually inspecting every line of code. Unlike for most industrial languages, though, we can take advantage of Rust's type and module system to minimize the amount of code that developers need to inspect to the code that is potentially dangerous. Cargo Scan models such potentially dangerous code as effects and performs a side-effects analysis, tailored to Rust, to identify effects and track them across crate and module boundaries. In most cases (69.2%) developers can inspect flagged effects and decide whether the code is potentially dangerous locally. In some cases, however, the safety of an effect depends on the calling context -- how a function is called, potentially by a crate the developer imports later. Hence, Cargo Scan tracks context-dependent information using a call-graph, and collects audit results into composable and reusable audit files. In this paper, we describe our experience auditing Rust crates with Cargo Scan. In particular, we audit the popular client and server HTTP crate, hyper, and all of its dependencies; our experience shows that Cargo Scan can reduce the auditing burden of potentially dangerous code to a median of 0.2% of lines of code when compared to auditing whole crates. Looking at the Rust ecosystem more broadly, we find that Cargo Scan can automatically classify ~3.5K of the top 10K crates on crates.io as safe; of the crates that do require manual inspection, we find that most of the potentially dangerous side-effects are concentrated in roughly 3% of these crates."}
{"id": "2602.06680", "categories": ["cs.PL", "cs.DC"], "pdf": "https://arxiv.org/pdf/2602.06680", "abs": "https://arxiv.org/abs/2602.06680", "authors": ["Ali Rasim Kocal", "Michael Schwarz", "Simmo Saan", "Helmut Seidl"], "title": "Same Engine, Multiple Gears: Parallelizing Fixpoint Iteration at Different Granularities (Extended Version)", "comment": null, "summary": "Fixpoint iteration constitutes the algorithmic core of static analyzers. Parallelizing the fixpoint engine can significantly reduce analysis times. Previous approaches typically fix the granularity of tasks upfront, e.g., at the level of program threads or procedures - yielding an engine permanently stuck in one gear. Instead, we propose to parallelize a generic fixpoint engine in a way that is parametric in the task granularity - meaning that our engine can be run in different gears. We build on the top-down solver TD, extended with support for mixed-flow sensitivity, and realize two competing philosophies for parallelization, both building on a task pool that schedules tasks to a fixed number of workers. The nature of tasks differs between the philosophies. In the immediate approach, all tasks access a single thread-safe hash table maintaining solver state, while in the independent approach, each task has its own state and exchanges data with other tasks via a publish/subscribe data structure. We have equipped the fixpoint engine of the static analysis framework Goblint with implementations following both philosophies and report on our results for large real-world programs."}
{"id": "2602.06715", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2602.06715", "abs": "https://arxiv.org/abs/2602.06715", "authors": ["Toby Ueno", "Ankush Das"], "title": "Practical Refinement Session Type Inference (Extended Version)", "comment": null, "summary": "Session types express and enforce safe communication in concurrent message-passing systems by statically capturing the interaction protocols between processes in the type. Recent works extend session types with arithmetic refinements, which enable additional fine-grained description of communication, but impose additional annotation burden on the programmer. To alleviate this burden, we propose a type inference algorithm for a session type system with arithmetic refinements. We develop a theory of subtyping for session types, including an algorithm which we prove sound with respect to a semantic definition based on type simulation. We also provide a formal inference algorithm that generates type and arithmetic constraints, which are then solved using the Z3 SMT solver. The algorithm has been implemented on top of the Rast language, and includes 3 key optimizations that make inference feasible and practical. We evaluate the efficacy of our inference engine by evaluating it on 6 challenging benchmarks, ranging from unary and binary natural numbers to linear $λ$-calculus. We show the performance benefits provided by our optimizations in coercing Z3 into solving the arithmetic constraints in reasonable time."}
{"id": "2602.06934", "categories": ["cs.PL", "cs.AI", "cs.DC", "cs.LO", "cs.MA"], "pdf": "https://arxiv.org/pdf/2602.06934", "abs": "https://arxiv.org/abs/2602.06934", "authors": ["Ehud Shapiro"], "title": "Implementing Grassroots Logic Programs with Multiagent Transition Systems and AI", "comment": null, "summary": "Grassroots Logic Programs (GLP) is a concurrent logic programming language with variables partitioned into paired \\emph{readers} and \\emph{writers}, conjuring both linear logic and futures/promises: an assignment is produced at most once via the sole occurrence of a writer (promise) and consumed at most once via the sole occurrence of its paired reader (future), and may contain additional readers and/or writers, enabling the concise expression of rich multidirectional communication modalities.\n  GLP was designed as a language for grassroots platforms -- distributed systems with multiple instances that can operate independently of each other and of any global resource, and can coalesce into ever larger instances -- with its target architecture being smartphones communicating peer-to-peer. The operational semantics of Concurrent (single-agent) GLP and of multiagent GLP (maGLP) were defined via transition systems/multiagent transition systems, respectively.\n  Here, we describe the mathematics developed to facilitate the workstation- and smartphone-based implementations of GLP by AI in Dart. We developed dGLP -- implementation-ready deterministic operational semantics for single-agent GLP -- and proved it correct with respect to the Concurrent GLP operational semantics; dGLP was used by AI as a formal spec, from which it developed a workstation-based implementation of GLP. We developed madGLP -- an implementation-ready multiagent operational semantics for maGLP -- and proved it correct with respect to the maGLP operational semantics; madGLP is deterministic at the agent level (not at the system level due to communication asynchrony), and is being used by AI as a formal spec from which it develops a smartphone-based implementation of maGLP."}
