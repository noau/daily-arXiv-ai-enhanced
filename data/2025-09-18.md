<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 4]
- [cs.GT](#cs.GT) [Total: 5]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Catalpa: GC for a Low-Variance Software Stack](https://arxiv.org/abs/2509.13429)
*Anthony Arnold,Mark Marron*

Main category: cs.PL

TL;DR: 论文提出了一种名为Catalpa的新型垃圾收集器设计，旨在通过编程语言和运行时系统设计，减少延迟和变异性，同时保持高吞吐量和低内存开销。


<details>
  <summary>Details</summary>
Motivation: 工业开发者更关注应用程序的95th和99th百分位尾延迟，而非平均响应时间。论文旨在设计一种能满足这一需求的软件栈。

Method: 利用Bosque语言的不变性和无引用循环特性，设计了一种具有有限收集停顿、固定内存开销且无需与应用程序代码同步的垃圾收集器。

Result: Catalpa收集器有效减少了延迟和变异性，同时保持了高吞吐量和低内存开销。

Conclusion: 该设计通过编程语言特性优化了垃圾收集器性能，满足了工业应用中对低延迟和高可用性的需求。

Abstract: The performance of an application/runtime is usually conceptualized as a
continuous function where, the lower the amount of memory/time used on a given
workload, then the better the compiler/runtime is. However, in practice, good
performance of an application is viewed as more of a binary function - either
the application responds in under, say 100 ms, and is fast enough for a user to
barely notice, or it takes a noticeable amount of time, leaving the user
waiting and potentially abandoning the task. Thus, performance really means how
often the application is fast enough to be usable, leading industrial
developers to focus on the 95th and 99th percentile tail-latencies as heavily,
or moreso, than average response time. Our vision is to create a software stack
that actively supports these needs via programming language and runtime system
design. In this paper we present a novel garbage-collector design, the Catalpa
collector, for the Bosque programming language and runtime. This allocator is
designed to minimize latency and variability while maintaining high-throughput
and incurring small memory overheads. To achieve these goals we leverage
various features of the Bosque language, including immutability and
reference-cycle freedom, to construct a collector that has bounded collection
pauses, incurs fixed-constant memory overheads, and does not require any
barriers or synchronization with application code.

</details>


### [2] [Extended Abstract: Towards a Performance Comparison of Syntax and Type-Directed NbE](https://arxiv.org/abs/2509.13489)
*Chester J. F. Gould,William J. Bowman*

Main category: cs.PL

TL;DR: 本文探讨了依赖类型检查器中两种类型相等性检查方法的性能与表达能力差异，旨在提供一个直接比较的平台。


<details>
  <summary>Details</summary>
Motivation: 依赖类型检查器中类型相等性检查方法的性能与表达能力差异尚未被精确量化，缺乏直接比较的平台。

Method: 开发一个现实的平台，用于直接比较语法导向和类型导向的相等性检查方法。

Result: 分析了类型导向检查方法的速度差异及其改进可能性。

Conclusion: 本文为未来优化类型导向相等性检查方法提供了实验基础和分析框架。

Abstract: A key part of any dependent type-checker is the method for checking whether
two types are equal. A common claim is that syntax-directed equality is more
performant, although type-directed equality is more expressive. However, this
claim is difficult to make precise, since implementations choose only one or
the other approach, making a direct comparison impossible. We present some
work-in-progress developing a realistic platform for direct, apples-to-apples,
comparison of the two approaches, quantifying how much slower type-directed
equality checking is, and analyzing why and how it can be improved.

</details>


### [3] [CLMTracing: Black-box User-level Watermarking for Code Language Model Tracing](https://arxiv.org/abs/2509.13982)
*Boyu Zhang,Ping He,Tianyu Du,Xuhong Zhang,Lei Yun,Kingsum Chow,Jianwei Yin*

Main category: cs.PL

TL;DR: CLMTracing是一种用于开源代码语言模型的黑盒水印框架，支持用户级跟踪，并通过规则水印和保留实用性的注入方法提升IP保护。


<details>
  <summary>Details</summary>
Motivation: 随着开源代码语言模型的广泛应用，知识产权保护变得至关重要。现有水印技术无法满足黑盒环境下用户级跟踪的需求。

Method: CLMTracing采用基于规则的水印和保留实用性的注入方法，并结合参数选择算法和对抗训练以增强水印抗攻击能力。

Result: 综合评估表明，CLMTracing在多个先进代码模型中有效，且在无害性和抗攻击性方面优于现有基线。

Conclusion: CLMTracing通过创新的水印方法，成功提升了代码语言模型的知识产权保护能力，尤其是在黑盒环境和用户级跟踪方面的表现显著。

Abstract: With the widespread adoption of open-source code language models (code LMs),
intellectual property (IP) protection has become an increasingly critical
concern. While current watermarking techniques have the potential to identify
the code LM to protect its IP, they have limitations when facing the more
practical and complex demand, i.e., offering the individual user-level tracing
in the black-box setting. This work presents CLMTracing, a black-box code LM
watermarking framework employing the rule-based watermarks and
utility-preserving injection method for user-level model tracing. CLMTracing
further incorporates a parameter selection algorithm sensitive to the robust
watermark and adversarial training to enhance the robustness against watermark
removal attacks. Comprehensive evaluations demonstrate CLMTracing is effective
across multiple state-of-the-art (SOTA) code LMs, showing significant harmless
improvements compared to existing SOTA baselines and strong robustness against
various removal attacks.

</details>


### [4] [Parallelizable Feynman-Kac Models for Universal Probabilistic Programming](https://arxiv.org/abs/2509.14092)
*Michele Boreale,Luisa Collodi*

Main category: cs.PL

TL;DR: 该研究为概率程序（PPs）的形式操作语义提供了可证明正确且高效的顺序蒙特卡洛（SMC）推理方法，特别关注具有无限循环中的任意测度采样和条件/重加权的通用PPs。


<details>
  <summary>Details</summary>
Motivation: 研究动机在于为概率程序的推理提供一个数学上严格且可计算的框架，尤其是在处理无限循环和复杂采样操作时。

Method: 研究方法包括为概率程序图（PPGs）定义基于无限执行迹的期望语义，并证明一个有限近似定理以支持Feynman-Kac模型框架。进一步，研究者提出VPF（向量化粒子滤波算法），专门用于PPGs。

Result: 实验结果显示，VPF在性能上优于当前最先进的概率程序推理工具。

Conclusion: 该研究通过形式语义和算法优化，为概率程序的顺序蒙特卡洛推理提供了一种高效且可靠的方法。

Abstract: We study provably correct and efficient instantiations of Sequential Monte
Carlo (SMC) inference in the context of formal operational semantics of
Probabilistic Programs (PPs). We focus on universal PPs featuring sampling from
arbitrary measures and conditioning/reweighting in unbounded loops. We first
equip Probabilistic Program Graphs (PPGs), an automata-theoretic description
format of PPs, with an expectation-based semantics over infinite execution
traces, which also incorporates trace weights. We then prove a finite
approximation theorem that provides bounds to this semantics based on
expectations taken over finite, fixed-length traces. This enables us to frame
our semantics within a Feynman-Kac (FK) model, and ensures the consistency of
the Particle Filtering (PF) algorithm, an instance of SMC, with respect to our
semantics. Building on these results, we introduce VPF, a vectorized version of
the PF algorithm tailored to PPGs and our semantics. Experiments conducted with
a proof-of-concept implementation of VPF show very promising results compared
to state-of-the-art PP inference tools.

</details>


<div id='cs.GT'></div>

# cs.GT [[Back]](#toc)

### [5] [Delta Matters: An Analytically Tractable Model for $β$-$δ$ Discounting Agents](https://arxiv.org/abs/2509.13637)
*Yasunori Akagi,Takeshi Kurashima*

Main category: cs.GT

TL;DR: 研究扩展了时间不一致行为的模型，放松了δ=1的限制，证明了在0 < δ ≤ 1的一般情况下仍可封闭描述代理行为，并推导了代理放弃任务的条件和最优干预方法。


<details>
  <summary>Details</summary>
Motivation: 理解时间不一致行为并设计有效干预是计算机科学与行为经济学的关键挑战，先前研究仅关注δ=1的情况，限制了模型的适用性。

Method: 研究使用β-δ折扣模型（准双曲折扣），放松δ=1的约束，分析0 < δ ≤ 1的一般情况，推导代理行为的封闭描述，并开发计算最优干预的方法。

Result: 结果显示代理行为和最优干预严重依赖于δ的值，固定δ=1可能简化现实决策过程。

Conclusion: 研究揭示δ的值对代理行为和干预策略具有关键影响，扩展了先前研究的局限性，为更真实的决策建模提供了基础。

Abstract: Humans exhibit time-inconsistent behavior, in which planned actions diverge
from executed actions. Understanding time inconsistency and designing
appropriate interventions is a key research challenge in computer science and
behavioral economics. Previous work focuses on progress-based tasks and derives
a closed-form description of agent behavior, from which they obtain optimal
intervention strategies. They model time-inconsistency using the
$\beta$-$\delta$ discounting (quasi-hyperbolic discounting), but the analysis
is limited to the case $\delta = 1$. In this paper, we relax that constraint
and show that a closed-form description of agent behavior remains possible for
the general case $0 < \delta \le 1$. Based on this result, we derive the
conditions under which agents abandon tasks and develop efficient methods for
computing optimal interventions. Our analysis reveals that agent behavior and
optimal interventions depend critically on the value of $\delta$, suggesting
that fixing $\delta = 1$ in many prior studies may unduly simplify real-world
decision-making processes.

</details>


### [6] [Efficient Last-Iterate Convergence in Regret Minimization via Adaptive Reward Transformation](https://arxiv.org/abs/2509.13653)
*Hang Ren,Yulin Wu,Shuhan Qi,Jiajia Zhang,Xiaozhen Sun,Tianzi Ma,Xuan Wang*

Main category: cs.GT

TL;DR: 论文提出了一种自适应技术，用于改进奖励转换（RT）框架中的遗憾最小化方法，解决了手动调参的敏感性问题，增强了在正规形式游戏和扩展形式游戏中求解纳什均衡的收敛性和实用性。


<details>
  <summary>Details</summary>
Motivation: 传统遗憾最小化方法在计算平均策略时需要大量资源或引入额外误差，且奖励转换框架对参数敏感，导致收敛缓慢或陷入局部最优。本文旨在通过自适应技术解决这些问题。

Method: 提出自适应方法，动态调整RT框架中的参数，平衡探索与利用，优化遗憾累积，适用于RT Regret Matching和RT Counterfactual Regret Minimization及其变种。

Result: 实验结果表明，该方法显著加速收敛速度，并在线性收敛方面优于现有最佳算法。

Conclusion: 自适应技术不仅解决了RT框架的实践挑战，还在理论上和实际性能上提供了更好的保障，推动了遗憾最小化方法在正规形式游戏和扩展形式游戏中的应用。

Abstract: Regret minimization is a powerful method for finding Nash equilibria in
Normal-Form Games (NFGs) and Extensive-Form Games (EFGs), but it typically
guarantees convergence only for the average strategy. However, computing the
average strategy requires significant computational resources or introduces
additional errors, limiting its practical applicability. The Reward
Transformation (RT) framework was introduced to regret minimization to achieve
last-iterate convergence through reward function regularization. However, it
faces practical challenges: its performance is highly sensitive to manually
tuned parameters, which often deviate from theoretical convergence conditions,
leading to slow convergence, oscillations, or stagnation in local optima.
  Inspired by previous work, we propose an adaptive technique to address these
issues, ensuring better consistency between theoretical guarantees and
practical performance for RT Regret Matching (RTRM), RT Counterfactual Regret
Minimization (RTCFR), and their variants in solving NFGs and EFGs more
effectively. Our adaptive methods dynamically adjust parameters, balancing
exploration and exploitation while improving regret accumulation, ultimately
enhancing asymptotic last-iterate convergence and achieving linear convergence.
Experimental results demonstrate that our methods significantly accelerate
convergence, outperforming state-of-the-art algorithms.

</details>


### [7] [Nash Equilibria in Games with Playerwise Concave Coupling Constraints: Existence and Computation](https://arxiv.org/abs/2509.14032)
*Philip Jordan,Maryam Kamgarpour*

Main category: cs.GT

TL;DR: 该论文研究了在连续静态游戏中纳什均衡的存在与计算问题，特别关注玩家策略受共享耦合约束的情况，提出了在较弱条件下均衡存在的证明，并提出了一种基于独立梯度方法的计算算法。


<details>
  <summary>Details</summary>
Motivation: 研究动机在于探索纳什均衡在受共享耦合约束的连续静态游戏中的存在性与计算问题，这些约束依赖于玩家的联合策略。现有的研究成果依赖强假设，不适用于此类游戏。

Method: 论文利用拓扑不动点理论和对玩家凹约束下可行集收缩性的新结构洞察，证明了纳什均衡在较弱条件下的存在性，并提出了一种基于对数障碍正则化梯度上升的自适应步长独立梯度方法。

Result: 研究结果表明，在具有势函数的游戏中，提出的算法可以从初始可行策略出发，在精确梯度反馈下以$\mathcal{O}(\epsilon^{-3})$的迭代次数收敛到$\epsilon$-近似约束纳什均衡。

Conclusion: 论文在较弱条件下证明了纳什均衡的存在性，并提出了一种有效的计算方法，为受共享耦合约束的连续静态游戏提供了理论支持与实用工具。

Abstract: We study the existence and computation of Nash equilibria in continuous
static games where the players' admissible strategies are subject to shared
coupling constraints, i.e., constraints that depend on their \emph{joint}
strategies. Specifically, we focus on a class of games characterized by
playerwise concave utilities and playerwise concave constraints. Prior results
on the existence of Nash equilibria are not applicable to this class, as they
rely on strong assumptions such as joint convexity of the feasible set. By
leveraging topological fixed point theory and novel structural insights into
the contractibility of feasible sets under playerwise concave constraints, we
give an existence proof for Nash equilibria under weaker conditions. Having
established existence, we then focus on the computation of Nash equilibria via
independent gradient methods under the additional assumption that the utilities
admit a potential function. To account for the possibly nonconvex feasible
region, we employ a log barrier regularized gradient ascent with adaptive
stepsizes. Starting from an initial feasible strategy profile and under exact
gradient feedback, the proposed method converges to an $\epsilon$-approximate
constrained Nash equilibrium within $\mathcal{O}(\epsilon^{-3})$ iterations.

</details>


### [8] [Generalised Reachability Games Revisited](https://arxiv.org/abs/2509.14091)
*Sougata Bose,Daniel Hausmann,Soumyajit Paul,Sven Schewe,Tansholpan Zhanabekova*

Main category: cs.GT

TL;DR: 该论文研究了具有广义可达性目标的图上的双人游戏的复杂性，扩展了已知的可处理类，并证明了优化变体在大多数情况下是难以解决的。


<details>
  <summary>Details</summary>
Motivation: 论文的动机在于进一步探索广义可达性游戏的复杂性，特别是当目标集的数量和大小变化时游戏的解法效率。

Method: 作者通过分析广义可达性游戏的复杂性，扩展了已知的可处理类，并研究了优化变体的问题，特别是目标集大小的优化。

Result: 结果显示，广义可达性游戏的目标集从单一目标扩展到对数数量的任意大小目标集时，游戏仍可解；而优化变体在大多数情况下是NP难的。

Conclusion: 论文的结论指出，尽管广义可达性游戏在某些情况下可解，但其优化变体通常难以解决，除非目标集均为单例且玩家能保证访问最大数量的目标集。

Abstract: Classic reachability games on graphs are zero-sum games, where the goal of
one player, Eve, is to visit a vertex from a given target set, and that of
other player, Adam, is to prevent this. Generalised reachability games, studied
by Fijalkow and Horn, are a generalisation of reachability objectives, where
instead of a single target set, there is a family of target sets and Eve must
visit all of them in any order. In this work, we further study the complexity
of solving two-player games on graphs with generalised reachability objectives.
Our results are twofold: first, we provide an improved complexity picture for
generalised reachability games, expanding the known tractable class from games
in which all target sets are singleton to additionally allowing a logarithmic
number of target sets of arbitrary size. Second, we study optimisation variants
of generalised reachability with a focus on the size of the target sets. For
these problems, we show intractability for most interesting cases.
Particularly, in contrast to the tractability in the classic variant for
singleton target sets, the optimisation problem is NP-hard when Eve tries to
maximise the number of singleton target sets that are visited. Tractability can
be recovered in the optimisation setting when all target sets are singleton by
requiring that Eve pledges a maximum sized subset of target sets that she can
guarantee to visit.

</details>


### [9] [Sound Value Iteration for Simple Stochastic Games](https://arxiv.org/abs/2509.14112)
*Muqsit Azeem,Jan Kretinsky,Maximilian Weininger*

Main category: cs.GT

TL;DR: 本文扩展了声音值迭代（SVI）算法，使其适用于随机游戏（SG）和具有端组件的MDP，解决了技术挑战并提出了优化。


<details>
  <summary>Details</summary>
Motivation: 尽管声音值迭代（SVI）能提供精确的上下界并加快收敛速度，但它不适用于随机游戏（SG）或具有端组件的MDP。本文旨在解决这一问题。

Method: 通过改进SVI算法，特别针对端组件提出不同的处理方法，并进行了多项优化。

Result: 实验表明，扩展后的SVI算法在具有概率循环的系统上具有潜力。

Conclusion: 本文成功扩展了SVI算法，使其适用于更广泛的场景，并通过优化提升了性能。

Abstract: Algorithmic analysis of Markov decision processes (MDP) and stochastic games
(SG) in practice relies on value-iteration (VI) algorithms. Since basic VI does
not provide guarantees on the precision of the result, variants of VI have been
proposed that offer such guarantees. In particular, sound value iteration (SVI)
not only provides precise lower and upper bounds on the result, but also
converges faster in the presence of probabilistic cycles. Unfortunately, it is
neither applicable to SG, nor to MDP with end components. In this paper, we
extend SVI and cover both cases. The technical challenge consists mainly in
proper treatment of end components, which require different handling than in
the literature. Moreover, we provide several optimizations of SVI. Finally, we
evaluate our prototype implementation experimentally to demonstrate its
potential on systems with probabilistic cycles.

</details>
