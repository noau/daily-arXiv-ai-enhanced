{"id": "2507.16051", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.16051", "abs": "https://arxiv.org/abs/2507.16051", "authors": ["Juan Altmayer Pizzorno", "Emery D. Berger"], "title": "RightTyper: Effective and Efficient Type Annotation for Python", "comment": null, "summary": "Python type annotations bring the benefits of static type checking to the\nlanguage. However, manually writing annotations can be time-consuming and\ntedious. The result is that most real-world Python code remains largely\nuntyped. Past approaches to annotating types in Python code fall short in a\nnumber of ways. Static approaches struggle with dynamic features and infer\noverly broad types. AI-based methods are inherently unsound and can miss rare\nor user-defined types. Dynamic methods can impose extreme runtime overheads,\ndegrading performance by up to 270x, abort execution as they exhaust resources,\nand even infer incorrect types that lead to runtime errors. Crucially, all\nprior work assumes implicitly that the code to be annotated is already correct.\nThis assumption is generally unwarranted, especially for large codebases that\nhave been untyped.\n  This paper presents RightTyper, a novel approach for Python that overcomes\nthese disadvantages. RightTyper not only generates precise type annotations\nbased on actual program behavior, improving recall in type checking relative to\nprior approaches. It also turns type checking into anomaly detection, allowing\nthe type checker to identify corner cases that the programmer can audit for\nunintended behavior. RightTyper is also fast and space-efficient, imposing just\n30% performance overhead on average. RightTyper achieves these characteristics\nby a principled yet pervasive use of sampling--guided by self-profiling--along\nwith statistical filtering and careful resolution and aggregation of type\ninformation."}
{"id": "2507.16086", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.16086", "abs": "https://arxiv.org/abs/2507.16086", "authors": ["Andrew Marmaduke", "Apoorv Ingle", "J. Garrett Morris"], "title": "Understanding Haskell-style Overloading via Open Data and Open Functions", "comment": null, "summary": "We present a new, uniform semantics for Haskell-style overloading. We realize\nour approach in a new core language, System F$_\\mathrm{D}$, whose metatheory we\nmechanize in the Lean4 interactive theorem prover. System F$_\\mathrm{D}$ is\ndistinguished by its open data types and open functions, each given by a\ncollection of instances rather than by a single definition. We show that System\nF$_\\mathrm{D}$ can encode advanced features of Haskell's of type class systems,\nmore expressively than current semantics of these features, and without\nassuming additional type equality axioms."}
{"id": "2507.16089", "categories": ["cs.PL", "cs.DB"], "pdf": "https://arxiv.org/pdf/2507.16089", "abs": "https://arxiv.org/abs/2507.16089", "authors": ["Michael J. Sullivan", "Zhibo Chen", "Elvis Pranskevichus", "Robert J. Simmons", "Victor Petrovykh", "Aljaž Mur Eržen", "Yury Selivanov"], "title": "Querying Graph-Relational Data", "comment": null, "summary": "For applications that store structured data in relational databases, there is\nan impedance mismatch between the flat representations encouraged by relational\ndata models and the deeply nested information that applications expect to\nreceive. In this work, we present the graph-relational database model, which\nprovides a flexible, compositional, and strongly-typed solution to this\n\"object-relational mismatch.\" We formally define the graph-relational database\nmodel and present a static and dynamic semantics for queries. In addition, we\ndiscuss the realization of the graph-relational database model in EdgeQL, a\ngeneral-purpose SQL-style query language, and the Gel system, which compiles\nEdgeQL schemas and queries into PostgreSQL queries. Gel facilitates the kind of\nobject-shaped data manipulation that is frequently provided inefficiently by\nobject-relational mapping (ORM) technologies, while achieving most of the\nefficiency that comes from require writing complex PostgreSQL queries directly."}
{"id": "2507.16660", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.16660", "abs": "https://arxiv.org/abs/2507.16660", "authors": ["Xuran Cai"], "title": "Enhancing Compiler Optimization Efficiency through Grammatical Decompositions of Control-Flow Graphs", "comment": null, "summary": "This thesis addresses the complexities of compiler optimizations, such as\nregister allocation and Lifetime-optimal Speculative Partial Redundancy\nElimination (LOSPRE), which are often handled using tree decomposition\nalgorithms. However, these methods frequently overlook important sparsity\naspects of Control Flow Graphs (CFGs) and result in high computational costs.\nWe introduce the SPL (Series-Parallel-Loop) decomposition, a novel framework\nthat offers optimal solutions to these challenges. A key contribution is the\nformulation of a general solution for Partial Constraint Satisfaction Problems\n(PCSPs) within graph structures, applied to three optimization problems. First,\nSPL decomposition enhances register allocation by accurately modeling variable\ninterference graphs, leading to efficient register assignments and improved\nperformance across benchmarks. Second, it optimizes LOSPRE by effectively\nidentifying and eliminating redundancies in program execution. Finally, the\nthesis focuses on optimizing the placement of bank selection instructions to\nenhance data retrieval efficiency and reduce latency. Extensive experimentation\ndemonstrates significant performance improvements over existing methods,\nestablishing SPL decomposition as a powerful tool for complex compiler\noptimizations, including register allocation, LOSPRE, and bank selection."}
{"id": "2507.16209", "categories": ["cs.GT", "cs.DS"], "pdf": "https://arxiv.org/pdf/2507.16209", "abs": "https://arxiv.org/abs/2507.16209", "authors": ["Telikepalli Kavitha", "Surya Panchapakesan", "Rohit Vaish", "Vignesh Viswanathan", "Jatin Yadav"], "title": "Best-of-Both-Worlds Guarantees with Fairer Endings", "comment": "46 pages. Abstract shortened to meet arXiv requirements", "summary": "Fair allocation of indivisible goods is a fundamental problem at the\ninterface of economics and computer science. Traditional approaches focus\neither on randomized allocations that are fair in expectation or deterministic\nallocations that are approximately fair. Recent work reconciles both these\napproaches via best-of-both-worlds guarantees, wherein one seeks randomized\nallocations that are fair in expectation (ex-ante fair) while being supported\non approximately fair allocations (ex-post fair). Prior work has shown that\nunder additive valuations, there always exists a randomized allocation that is\nex-ante stochastic-dominance envy-free (sd-EF) and ex-post envy-free up to one\ngood (EF1).\n  Our work is motivated by the goal of achieving stronger ex-post fairness\nguarantees such as envy-freeness up to any good (EFX) along with meaningful\nex-ante guarantees. We make the following contributions:\n  1) We first consider lexicographic preferences, a subdomain of additive\nvaluations where ex-post EFX allocations always exist and can be computed\nefficiently. On the negative side, we show that ex-ante sd-EF is fundamentally\nincompatible with ex-post EFX, prompting a relaxation of the ex-ante benchmark.\nWe then present a poly. time algorithm that achieves ex-post EFX and PO\ntogether with ex-ante 9/10-EF. Our algorithm uses dependent rounding and\nleverages structural properties of EFX and PO allocations.\n  2)For monotone valuations, we study EFX-with-charity: a relaxation of EFX\nwhere some goods remain unallocated, with no agent envying the unallocated\npool. We show that ex-post EFX-with-charity can be achieved alongside ex-ante\n0.5-EF.\n  3)Finally, for subadditive valuations, we strengthen our previous ex-post\nguarantee to EFX-with-bounded-charity, where at most n-1 goods (n= no. of\nagents) remain unallocated, at the price of weakening the ex-ante guarantee to\n0.5-proportionality."}
{"id": "2507.15979", "categories": ["cs.GR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.15979", "abs": "https://arxiv.org/abs/2507.15979", "authors": ["Marcel C. Bühler", "Ye Yuan", "Xueting Li", "Yangyi Huang", "Koki Nagano", "Umar Iqbal"], "title": "Dream, Lift, Animate: From Single Images to Animatable Gaussian Avatars", "comment": null, "summary": "We introduce Dream, Lift, Animate (DLA), a novel framework that reconstructs\nanimatable 3D human avatars from a single image. This is achieved by leveraging\nmulti-view generation, 3D Gaussian lifting, and pose-aware UV-space mapping of\n3D Gaussians. Given an image, we first dream plausible multi-views using a\nvideo diffusion model, capturing rich geometric and appearance details. These\nviews are then lifted into unstructured 3D Gaussians. To enable animation, we\npropose a transformer-based encoder that models global spatial relationships\nand projects these Gaussians into a structured latent representation aligned\nwith the UV space of a parametric body model. This latent code is decoded into\nUV-space Gaussians that can be animated via body-driven deformation and\nrendered conditioned on pose and viewpoint. By anchoring Gaussians to the UV\nmanifold, our method ensures consistency during animation while preserving fine\nvisual details. DLA enables real-time rendering and intuitive editing without\nrequiring post-processing. Our method outperforms state-of-the-art approaches\non ActorsHQ and 4D-Dress datasets in both perceptual quality and photometric\naccuracy. By combining the generative strengths of video diffusion models with\na pose-aware UV-space Gaussian mapping, DLA bridges the gap between\nunstructured 3D representations and high-fidelity, animation-ready avatars."}
{"id": "2507.16463", "categories": ["cs.GR", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.16463", "abs": "https://arxiv.org/abs/2507.16463", "authors": ["Fabrizio Nunnari", "Shailesh Mishra", "Patrick Gebhard"], "title": "MMS Player: an open source software for parametric data-driven animation of Sign Language avatars", "comment": null, "summary": "This paper describes the MMS-Player, an open source software able to\nsynthesise sign language animations from a novel sign language representation\nformat called MMS (MultiModal Signstream). The MMS enhances gloss-based\nrepresentations by adding information on parallel execution of signs, timing,\nand inflections. The implementation consists of Python scripts for the popular\nBlender 3D authoring tool and can be invoked via command line or HTTP API.\nAnimations can be rendered as videos or exported in other popular 3D animation\nexchange formats. The software is freely available under GPL-3.0 license at\nhttps://github.com/DFKI-SignLanguage/MMS-Player."}
