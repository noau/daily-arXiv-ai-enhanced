{"id": "2509.13306", "categories": ["cs.GR"], "pdf": "https://arxiv.org/pdf/2509.13306", "abs": "https://arxiv.org/abs/2509.13306", "authors": ["Zeyu Ma", "Adam Finkelstein", "Jia Deng"], "title": "Temporally Smooth Mesh Extraction for Procedural Scenes with Long-Range Camera Trajectories using Spacetime Octrees", "comment": "Accepted as a Conference Paper to Siggraph Asia 2025", "summary": "The procedural occupancy function is a flexible and compact representation\nfor creating 3D scenes. For rasterization and other tasks, it is often\nnecessary to extract a mesh that represents the shape. Unbounded scenes with\nlong-range camera trajectories, such as flying through a forest, pose a unique\nchallenge for mesh extraction. A single static mesh representing all the\ngeometric detail necessary for the full camera path can be prohibitively large.\nTherefore, independent meshes can be extracted for different camera views, but\nthis approach may lead to popping artifacts during transitions. We propose a\ntemporally coherent method for extracting meshes suitable for long-range camera\ntrajectories in unbounded scenes represented by an occupancy function. The key\nidea is to perform 4D mesh extraction using a new spacetime tree structure\ncalled a binary-octree. Experiments show that, compared to existing baseline\nmethods, our method offers superior visual consistency at a comparable cost.\nThe code and the supplementary video for this paper are available at\nhttps://github.com/princeton-vl/BinocMesher."}
{"id": "2509.12593", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.12593", "abs": "https://arxiv.org/abs/2509.12593", "authors": ["Yimin Zhang", "Mario de Sousa"], "title": "Converting IEC 61131-3 LD into SFC Using Large Language Model: Dataset and Testing", "comment": null, "summary": "In the domain of Programmable Logic Controller (PLC) programming, converting\na Ladder Diagram (LD) into a Sequential Function Chart (SFC) is an inherently\nchallenging problem, primarily due to the lack of domain-specific knowledge and\nthe issue of state explosion in existing algorithms. However, the rapid\ndevelopment of Artificial Intelligence (AI) - especially Large Language Model\n(LLM) - offers a promising new approach.\n  Despite this potential, data-driven approaches in this field have been\nhindered by a lack of suitable datasets. To address this gap, we constructed\nseveral datasets consisting of paired textual representations of SFC and LD\nprograms that conform to the IEC 61131-3 standard.\n  Based on these datasets, we explored the feasibility of automating the LD-SFC\nconversion using LLM. Our preliminary experiments show that a fine-tuned LLM\nmodel achieves up to 91% accuracy on certain dataset, with the lowest observed\naccuracy being 79%, suggesting that with proper training and representation,\nLLMs can effectively support LD-SFC conversion. These early results highlight\nthe viability and future potential of this approach."}
{"id": "2509.13006", "categories": ["cs.PL", "cs.MS", "math.OC", "90C05, 90c06, 90c10", "D.3.4; G.4"], "pdf": "https://arxiv.org/pdf/2509.13006", "abs": "https://arxiv.org/abs/2509.13006", "authors": ["Shermin Khosravi", "David Bremner"], "title": "Efficient Compilation of Algorithms into Compact Linear Programs", "comment": "Preliminary version will appear in CASCON 2025", "summary": "Linear Programming (LP) is widely applied in industry and is a key component\nof various other mathematical problem-solving techniques. Recent work\nintroduced an LP compiler translating polynomial-time, polynomial-space\nalgorithms into polynomial-size LPs using intuitive high-level programming\nlanguages, offering a promising alternative to manually specifying each set of\nconstraints through Algebraic Modeling Languages (AMLs). However, the resulting\nLPs, while polynomial in size, are often extremely large, posing challenges for\nexisting LP solvers. In this paper, we propose a novel approach for generating\nsubstantially smaller LPs from algorithms. Our goal is to establish\nminimum-size compact LP formulations for problems in P having natural\nformulations with exponential extension complexities. Our broader vision is to\nenable the systematic generation of Compact Integer Programming (CIP)\nformulations for problems with exponential-size IPs having polynomial-time\nseparation oracles. To this end, we introduce a hierarchical linear pipelining\ntechnique that decomposes nested program structures into synchronized regions\nwith well-defined execution transitions -- functions of compile-time\nparameters. This decomposition allows us to localize LP constraints and\nvariables within each region, significantly reducing LP size without the loss\nof generality, ensuring the resulting LP remains valid for all inputs of size\n$n$. We demonstrate the effectiveness of our method on two benchmark problems\n-- the makespan problem, which has exponential extension complexity, and the\nweighted minimum spanning tree problem -- both of which have exponential-size\nnatural LPs. Our results show up to a $25$-fold reduction in LP size and\nsubstantial improvements in solver performance across both commercial and\nnon-commercial LP solvers."}
{"id": "2509.13019", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2509.13019", "abs": "https://arxiv.org/abs/2509.13019", "authors": ["Frédéric Fort", "David Nowak", "Vlad Rusu"], "title": "Pleasant Imperative Program Proofs with GallinaC", "comment": "In Proceedings FROM 2025, arXiv:2509.11877", "summary": "Even with the increase of popularity of functional programming, imperative\nprogramming remains a key programming paradigm, especially for programs\noperating at lower levels of abstraction. When such software offers key\ncomponents of a Trusted Computing Base (TCB), e.g. an operating system kernel,\nit becomes desirable to provide mathematical correctness proofs.\n  However, current real-world imperative programming languages possess\n\"expressive\", i.e. overly permissive, semantics. Thus, producing correctness\nproofs of such programs becomes tedious and error-prone, requiring to take care\nof numerous \"administrative\" details. Ideally, a proof-oriented imperative\nlanguage should feature well-behaved semantics while allowing imperative\nidioms.\n  To obtain a high-degree of confidence in the correctness of such a language,\nits tools should be developed inside a proof-assistant such that program proofs\nare machine checked.\n  We present GallinaC, a shallow embedding of a Turing-complete imperative\nlanguage directly inside the functional programming language of the Rocq proof\nassistant, Gallina. In particular, it features a truly generic and unbounded\nwhile loop. Having a functional core means proofs about GallinaC programs may\nuse the same tactics as proofs about pure functional ones.\n  Work on GallinaC is still under progress, but we present first promising\nresults. A prototype implementation has shown the viability of GallinaC with\nthe correctness proof of a list reversal procedure for linked-lists of unknown\nsize. We currently focus on the forward simulation between the GallinaC\nintermediate representation (IR) and Cminor, the entry language of the CompCert\nback-end."}
{"id": "2509.13022", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.13022", "abs": "https://arxiv.org/abs/2509.13022", "authors": ["Andrei Nacu", "Dorel Lucanu"], "title": "Navigating the Python Type Jungle", "comment": "In Proceedings FROM 2025, arXiv:2509.11877", "summary": "Python's typing system has evolved pragmatically into a powerful but\ntheoretically fragmented system, with scattered specifications. This paper\nproposes a formalization to address this fragmentation. The central\ncontribution is a formal foundation that uses concepts from type theory to\ndemonstrate that Python's type system can be elegantly described. This work\naims to serve as a crucial first step toward the future development of type\ninference tools."}
{"id": "2509.13128", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2509.13128", "abs": "https://arxiv.org/abs/2509.13128", "authors": ["Raphaël Monat"], "title": "Try-Mopsa: Relational Static Analysis in Your Pocket", "comment": null, "summary": "Static analyzers are complex pieces of software with large dependencies. They\ncan be difficult to install, which hinders adoption and creates barriers for\nstudents learning static analysis. This work introduces Try-Mopsa: a\nscaled-down version of the Mopsa static analysis platform, compiled into\nJavaScript to run purely as a client-side application in web browsers.\nTry-Mopsa provides a responsive interface that works on both desktop and mobile\ndevices. Try-Mopsa features all the core components of Mopsa. In particular, it\nsupports relational numerical domains. We present the interface, changes and\nadaptations required to have a pure JavaScript version of Mopsa. We envision\nTry-Mopsa as a convenient platform for onboarding or teaching purposes."}
{"id": "2509.13261", "categories": ["cs.PL", "D.3.4"], "pdf": "https://arxiv.org/pdf/2509.13261", "abs": "https://arxiv.org/abs/2509.13261", "authors": ["Noé De Santo", "Stephanie Weirich"], "title": "Rebound: Efficient, Expressive, and Well-Scoped Binding", "comment": "15 pages, 5 figures, 3 tables. To be published in Proceedings of the\n  18th ACM SIGPLAN International Haskell Symposium (Haskell 2025)", "summary": "We introduce the Rebound library that supports well-scoped term\nrepresentations in Haskell and automates the definition of substitution,\nalpha-equivalence, and other operations that work with binding structures. The\nkey idea of our design is the use of first-class environments that map\nvariables to expressions in some new scope. By statically tracking scopes,\nusers of this library gain confidence that they have correctly maintained the\nsubtle invariants that stem from using de Bruijn indices. Behind the scenes,\nRebound uses environments to optimize the application of substitutions, while\nproviding explicit access to these data structures when desired. We demonstrate\nthat this library is expressive by using it to implement a wide range of\nlanguage features with sophisticated uses of binding and several different\noperations that use this abstract syntax. Our examples include pi-forall, a\ntutorial implementation of a type checker for a dependently-typed programming\nlanguage. Finally, we benchmark Rebound to understand its performance\ncharacteristics and find that it produces faster code than competing libraries."}
